{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":".md-typeset h1, .md-content__button { display: none; } Formal Modeling and Analysis of Distributed Systems Challenge : Distributed systems are notoriously hard to get right. Programming these systems is challenging because of the need to reason about correctness in the presence of myriad possible interleaving of messages and failures. Unsurprisingly, it is common for service teams to uncover correctness bugs after deployment. Formal methods can play an important role in addressing this challenge! P Overview: P is a state machine based programming language for formally modeling and specifying complex distributed systems. P allows programmers to model their system design as a collection of communicating state machines. P supports several backend analysis engines (based on automated reasoning techniques like model checking and symbolic execution) to check that the distributed system modeled in P satisfy the desired correctness specifications. The following talk provides an overview of P, its impact in academia and industry, and answers the main question that gets asked most by service teams and developers: \"why do formal modeling?\" : (P @ StrangeLoop) Formal Modeling and Analysis of Distributed Systems (Finding Critical Bugs Early!!) Impact : P is currently being used extensively inside Amazon (AWS) for analysis of complex distributed systems. For example, Amazon S3 used P to formally reason about the core distributed protocols involved in its strong consistency launch. Teams across AWS are now using P for thinking and reasoning about their systems formally. P is also being used for programming safe robotics systems in Academia. P was first used to implement and validate the USB device driver stack that ships with Microsoft Windows 8 and Windows Phone. Experience and lessons learned : In our experience of using P inside AWS, Academia, and Microsoft. We have observed that P has helped developers in three critical ways: (1) P as a thinking tool : Writing formal specifications in P forces developers to think about their system design rigorously, and in turn helped in bridging gaps in their understanding of the system. A large fraction of the bugs can be eliminated in the process of writing specifications itself! (2) P as a bug finder : Model checking helped find corner case bugs in system design that were missed by stress and integration testing. (3) P helped boost developer velocity : After the initial overhead of creating the formal models, future update,s and feature additions could be rolled out faster as these non-trivial changes are rigorously validated before implementation. Programming concurrent, distributed systems is fun but challenging, however, a pinch of programming language design with a dash of automated reasoning can go a long way in addressing the challenge and amplifying the fun!. Let the fun begin! You can find most of the information about the P framework on this webpage: what is P? , getting started , tutorials , case studies and related research publications . If you have any further questions, please feel free to create an issue , ask on discussions , or email us Contributions P has always been a collaborative project between industry and academia (since 2013) . The P team welcomes contributions and suggestions from all of you!! .","title":"Home"},{"location":"#let-the-fun-begin","text":"You can find most of the information about the P framework on this webpage: what is P? , getting started , tutorials , case studies and related research publications . If you have any further questions, please feel free to create an issue , ask on discussions , or email us Contributions P has always been a collaborative project between industry and academia (since 2013) . The P team welcomes contributions and suggestions from all of you!! .","title":"Let the fun begin!"},{"location":"casestudies/","text":"[AWS] Amazon S3 Strong Consistency In Dec 2020, Amazon S3 launched Strong Consistency with guaranteed strong read-after-write consistency . The S3 team leveraged automated reasoning for ensuring the correctness of S3's Strong Consistency design. Werner had a detailed blog post about the challenges involved. Qoute from Werners blog: Diving Deep on S3 Consistency Common testing techniques like unit testing and integration testing are valuable, necessary tools in any production system. But they aren\u2019t enough when you need to build a system with such a high bar for correctness. We want a system that\u2019s \u201cprovably correct\u201d, not just \u201cprobably correct.\u201d So, for strong consistency, we utilized a variety of techniques for ensuring that what we built is correct, and continues to be correct as the system evolves. We employed integration tests, deductive proofs of our proposed cache coherence algorithm, model checking to formalize our consistency design and to demonstrate its correctness, and we expanded on our model checking to examine actual runnable code. P was used for creating formal models of all the core distributed protocols involved in S3's strong consistency and checking that the system model satisfies the desired correctness guarantees. Details about P and how it is being used by the S3 team can be found in the AWS Pi-Week Talk : Use of Automated Reasoning for S3 Strong Consistency Launch . [AWS] Amazon IoT Devices: OTA Protocol AWS FreeRTOS is a real-time operating system designed to run on IoT devices to enable them to interact easily and reliably with AWS services. The Over the Air (OTA) update functionality makes it possible to update a device with security fixes quickly and reliably. The OTA Library , a part of the overall OTA functionality that runs on the IoT devices, enables customers to learn of available updates, download the updates, check their cryptographic signatures, and apply them. The OTA system is a complex piece of software that performs firmware updates reliably and securely --- keeping all devices in a consistent state --- in the presence of arbitrary failures of devices and communication. The heart of the OTA system is an intricate distributed protocol, the OTA protocol, that co-ordinates the execution of the different agents involved. P was used for creating formal models of the OTA protocol and checking its correctness. During this process the team found 3 bugs in the model that pointed to potential issues in the actual implementation itself. Related Blog: Using Formal Methods to validate OTA Protocol [UC Berkeley] Programming Safe Robotics Systems DRONA is a software framework for programming safe distributed mobile robotics systems. DRONA uses P language for implementing and model-checking the correctness of robotics software stack. The C code generated from P compiler can be deployed on Robot Operating System (ROS). More details about the DRONA framework and simulation videos are available here: https://drona-org.github.io/Drona/ See the fun demo video using P to control a quadrocopter and make sense of the MavLink stream, all visualized in a live DGML diagram. [UC Berkeley] Programming Secure Distributed Systems Programming secure distributed systems that have a formal guarantee of no information leakage is challenging. PSec framework extended the P language to enable programming secure distributed systems. PSec leverages Intel SGX enclaves to ensure that the security guarantees provided by the P language are enforced at runtime. By combining information flow control with hardware enclaves, PSec prevents programmers from inadvertently leaking sensitive information while sending data securely across machines. PSec was used to program several real-world examples, including a One Time Passcode application and a Secure Electronic Voting System. Details about the PSec framework can be found here . [Microsoft] Windows USB 3.0 Device Drivers Event-driven asynchronous programs typically have layers of design, where the higher layers reason with how the various components (or machines) interact, and the protocol they follow, and where as lower layers manage more data-intensive computations, controlling local devices, etc. However, the programs often get written in traditional languages that offer no mechanisms to capture these abstractions, and hence over time leads to code where the individual layers are no longer discernible. High-level protocols, though often first designed on paper using clean graphical state-machine abstractions, eventually get lost in code, and hence verification tools for such programs face the daunting task of extracting these models from the programs. The natural solution to the above problem is to build a programming language for asynchronous event-driven programs that preserves the protocol abstractions in code. Apart from the difficulty in designing such a language, this task is plagued by the reluctance of programmers to adopt a new language of programming and the discipline that it brings. However, this precise solution was pioneered by the P programming framework, where, during the development of Windows 8, the team building the USB driver stack used P for modeling, implementing, and model-checking of the USB 3.0 device drivers ( paper ) Related Blog: Building robust USB 3.0 support P: A programming language designed for asynchrony, fault-tolerance and uncertainty","title":"Case Studies"},{"location":"casestudies/#aws-amazon-s3-strong-consistency","text":"In Dec 2020, Amazon S3 launched Strong Consistency with guaranteed strong read-after-write consistency . The S3 team leveraged automated reasoning for ensuring the correctness of S3's Strong Consistency design. Werner had a detailed blog post about the challenges involved. Qoute from Werners blog: Diving Deep on S3 Consistency Common testing techniques like unit testing and integration testing are valuable, necessary tools in any production system. But they aren\u2019t enough when you need to build a system with such a high bar for correctness. We want a system that\u2019s \u201cprovably correct\u201d, not just \u201cprobably correct.\u201d So, for strong consistency, we utilized a variety of techniques for ensuring that what we built is correct, and continues to be correct as the system evolves. We employed integration tests, deductive proofs of our proposed cache coherence algorithm, model checking to formalize our consistency design and to demonstrate its correctness, and we expanded on our model checking to examine actual runnable code. P was used for creating formal models of all the core distributed protocols involved in S3's strong consistency and checking that the system model satisfies the desired correctness guarantees. Details about P and how it is being used by the S3 team can be found in the AWS Pi-Week Talk : Use of Automated Reasoning for S3 Strong Consistency Launch .","title":"[AWS] Amazon S3 Strong Consistency"},{"location":"casestudies/#aws-amazon-iot-devices-ota-protocol","text":"AWS FreeRTOS is a real-time operating system designed to run on IoT devices to enable them to interact easily and reliably with AWS services. The Over the Air (OTA) update functionality makes it possible to update a device with security fixes quickly and reliably. The OTA Library , a part of the overall OTA functionality that runs on the IoT devices, enables customers to learn of available updates, download the updates, check their cryptographic signatures, and apply them. The OTA system is a complex piece of software that performs firmware updates reliably and securely --- keeping all devices in a consistent state --- in the presence of arbitrary failures of devices and communication. The heart of the OTA system is an intricate distributed protocol, the OTA protocol, that co-ordinates the execution of the different agents involved. P was used for creating formal models of the OTA protocol and checking its correctness. During this process the team found 3 bugs in the model that pointed to potential issues in the actual implementation itself. Related Blog: Using Formal Methods to validate OTA Protocol","title":"[AWS] Amazon IoT Devices: OTA Protocol"},{"location":"casestudies/#uc-berkeley-programming-safe-robotics-systems","text":"DRONA is a software framework for programming safe distributed mobile robotics systems. DRONA uses P language for implementing and model-checking the correctness of robotics software stack. The C code generated from P compiler can be deployed on Robot Operating System (ROS). More details about the DRONA framework and simulation videos are available here: https://drona-org.github.io/Drona/ See the fun demo video using P to control a quadrocopter and make sense of the MavLink stream, all visualized in a live DGML diagram.","title":"[UC Berkeley] Programming Safe Robotics Systems"},{"location":"casestudies/#uc-berkeley-programming-secure-distributed-systems","text":"Programming secure distributed systems that have a formal guarantee of no information leakage is challenging. PSec framework extended the P language to enable programming secure distributed systems. PSec leverages Intel SGX enclaves to ensure that the security guarantees provided by the P language are enforced at runtime. By combining information flow control with hardware enclaves, PSec prevents programmers from inadvertently leaking sensitive information while sending data securely across machines. PSec was used to program several real-world examples, including a One Time Passcode application and a Secure Electronic Voting System. Details about the PSec framework can be found here .","title":"[UC Berkeley] Programming Secure Distributed Systems"},{"location":"casestudies/#microsoft-windows-usb-30-device-drivers","text":"Event-driven asynchronous programs typically have layers of design, where the higher layers reason with how the various components (or machines) interact, and the protocol they follow, and where as lower layers manage more data-intensive computations, controlling local devices, etc. However, the programs often get written in traditional languages that offer no mechanisms to capture these abstractions, and hence over time leads to code where the individual layers are no longer discernible. High-level protocols, though often first designed on paper using clean graphical state-machine abstractions, eventually get lost in code, and hence verification tools for such programs face the daunting task of extracting these models from the programs. The natural solution to the above problem is to build a programming language for asynchronous event-driven programs that preserves the protocol abstractions in code. Apart from the difficulty in designing such a language, this task is plagued by the reluctance of programmers to adopt a new language of programming and the discipline that it brings. However, this precise solution was pioneered by the P programming framework, where, during the development of Windows 8, the team building the USB driver stack used P for modeling, implementing, and model-checking of the USB 3.0 device drivers ( paper ) Related Blog: Building robust USB 3.0 support P: A programming language designed for asynchrony, fault-tolerance and uncertainty","title":"[Microsoft] Windows USB 3.0 Device Drivers"},{"location":"manualoutline/","text":"We recommend that you start with the Tutorials to get familiar with the P language and its tool chain. P Top Level Declarations Grammar topDecl: # Top-level P Program Declarations | typeDecl # UserDefinedTypeDeclaration | enumTypeDecl # EnumTypeDeclaration | eventDecl # EventDeclaration | machineDecl # MachineDeclaration | specDecl # SpecDeclaration | funDecl # GlobalFunctionDeclaration | moduleDecl # ModuleDeclaration | testDecl # TestCaseDeclaration ; A P program consists of a collection of following top-level declarations: Top Level Declarations Description User Defined Types P supports users defined types as well as foreign types (types that are defined in external language) Enums P supports declaring enum values that can be used as int constants (update the link) Events Events are used by state machines to communicate with each other State Machines P state machines are used to model or implement the behavior of the system Specification Monitors P specification monitors are used to write the safety and liveness specifications the system must satisfy for correctness Global Functions P supports declaring global functions that can be shared across state machines and spec monitors Module System P supports a module system for implementing and testing the system modularly by dividing it into separate components Test Cases P test cases help programmers to write different finite scenarios under which they would like to check the correctness of their system Models, Specifications, Model Checking Scenario A quick primer on what a model is, versus a specification, and model checking scenarios: (1) A specification says what the system should do (correctness properties). (2) A model captures the details of how the system does it. (3) A model checking scenario provides the finite non-deterministc test-harness or environment under which the model checker should check that the system model satisfies its specifications.","title":"P Program (Outline)"},{"location":"publications/","text":"P Language and Backend Analysis Compositional Programming and Testing of Dynamic Distributed Systems . Ankush Desai, Amar Phanishayee, Shaz Qadeer, and Sanjit Seshia International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), 2018. Lasso detection using Partial State Caching . Rashmi Mudduluru, Pantazis Deligiannis, Ankush Desai, Akash Lal and Shaz Qadeer. Formal Methods in Computer-Aided Design (FMCAD) - 2017 Systematic Testing of Asynchronous Reactive Systems . Ankush Desai, Shaz Qadeer, and Sanjit A. Seshia. Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering (ESEC/FSE 2015). Natural proofs for Asynchronous Programs using Almost-synchronous Invariants . Ankush Desai, Pranav Garg, and P. Madhusudan. International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA) - 2014 P: Safe asynchronous event-driven programming . Ankush Desai, Vivek Gupta, Ethan Jackson, Shaz Qadeer, Sriram Rajamani, and Damien Zufferey. Proceedings of ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 2013. Depth bounded explicit-state model checking . Abhishek Udupa, Ankush Desai and Sriram Rajamani. International SPIN Symposium on Model Checking of Software (SPIN) - 2011 P Case Studies PSec: Programming Secure Distributed Systems using Enclaves . Shivendra Kushwah, Ankush Desai, Pramod Subramanyan, Sanjit A. Seshia. Proceedings of the 2021 ACM Asia Conference on Computer and Communications Security (AsiaCCS) - 2021 Programming Safe Robotics Systems: Challenges and Advances . Ankush Desai, Shaz Qadeer and Sanjit Seshia. International Symposium On Leveraging Applications of Formal Methods, Verification and Validation (ISoLA) - 2018 DRONA: A Framework for Safe Distributed Mobile Robotics . Ankush Desai, Indranil Saha, Jianqiao Yang, Shaz Qadeer, and Sanjit A. Seshia. Proceedings of the 8th ACM/IEEE International Conference on Cyber-Physical Systems (ICCPS), 2017. Combining Model Checking and Runtime Verification for Safe Robotics . Ankush Desai, Tommaso Dreossi and Sanjit Seshia. The 17th International Conference on Runtime Verification (RV) - 2017 Approximate Synchrony: An Abstraction for Distributed Almost-synchronous Systems . Ankush Desai, Sanjit Seshia, Shaz Qadeer, David Broman, and John Eidson. International Conference on Computer Aided Verification (CAV) - 2015 Endlessly Circulating Messages in IEEE 1588-2008 Systems . David Broman, P Derler, Ankush Desai, John Eidson, and Sanjit Seshia. International Symposium on Precision Clock Synchronization for Measurement, Control and Communication (ISPCS) - 2014 PhD Thesis Modular and Safe Event-Driven Programming . Ankush Desai University of California, Berkeley - 2019.","title":"Publications"},{"location":"publications/#p-language-and-backend-analysis","text":"Compositional Programming and Testing of Dynamic Distributed Systems . Ankush Desai, Amar Phanishayee, Shaz Qadeer, and Sanjit Seshia International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), 2018. Lasso detection using Partial State Caching . Rashmi Mudduluru, Pantazis Deligiannis, Ankush Desai, Akash Lal and Shaz Qadeer. Formal Methods in Computer-Aided Design (FMCAD) - 2017 Systematic Testing of Asynchronous Reactive Systems . Ankush Desai, Shaz Qadeer, and Sanjit A. Seshia. Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering (ESEC/FSE 2015). Natural proofs for Asynchronous Programs using Almost-synchronous Invariants . Ankush Desai, Pranav Garg, and P. Madhusudan. International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA) - 2014 P: Safe asynchronous event-driven programming . Ankush Desai, Vivek Gupta, Ethan Jackson, Shaz Qadeer, Sriram Rajamani, and Damien Zufferey. Proceedings of ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 2013. Depth bounded explicit-state model checking . Abhishek Udupa, Ankush Desai and Sriram Rajamani. International SPIN Symposium on Model Checking of Software (SPIN) - 2011","title":"P Language and Backend Analysis"},{"location":"publications/#p-case-studies","text":"PSec: Programming Secure Distributed Systems using Enclaves . Shivendra Kushwah, Ankush Desai, Pramod Subramanyan, Sanjit A. Seshia. Proceedings of the 2021 ACM Asia Conference on Computer and Communications Security (AsiaCCS) - 2021 Programming Safe Robotics Systems: Challenges and Advances . Ankush Desai, Shaz Qadeer and Sanjit Seshia. International Symposium On Leveraging Applications of Formal Methods, Verification and Validation (ISoLA) - 2018 DRONA: A Framework for Safe Distributed Mobile Robotics . Ankush Desai, Indranil Saha, Jianqiao Yang, Shaz Qadeer, and Sanjit A. Seshia. Proceedings of the 8th ACM/IEEE International Conference on Cyber-Physical Systems (ICCPS), 2017. Combining Model Checking and Runtime Verification for Safe Robotics . Ankush Desai, Tommaso Dreossi and Sanjit Seshia. The 17th International Conference on Runtime Verification (RV) - 2017 Approximate Synchrony: An Abstraction for Distributed Almost-synchronous Systems . Ankush Desai, Sanjit Seshia, Shaz Qadeer, David Broman, and John Eidson. International Conference on Computer Aided Verification (CAV) - 2015 Endlessly Circulating Messages in IEEE 1588-2008 Systems . David Broman, P Derler, Ankush Desai, John Eidson, and Sanjit Seshia. International Symposium on Precision Clock Synchronization for Measurement, Control and Communication (ISPCS) - 2014","title":"P Case Studies"},{"location":"publications/#phd-thesis","text":"Modular and Safe Event-Driven Programming . Ankush Desai University of California, Berkeley - 2019.","title":"PhD Thesis"},{"location":"tutsoutline/","text":"P Language Semantics Before we get started with the tutorials, please read this to get an informal overview of the P language semantics. In this tutorial, we use a series of examples along with exercise problems to help you get familiar with the P language and the associated tool chain. How to use this tutorial We recommend that you work through these examples one-by-one by solving the accompanying exercise problems before moving to the next example. If you have any doubts or questions, please feel free to ask them in discussions or create an issue . Also, we assume that you have cloned the P repository locally. git clone https://github.com/p-org/P.git The recommended way to work through this example is to open the P/Tutorial folder in IntelliJ side-by-side a browser using which you can simultaneously read the description for each example and browse the P program. To know more about P language primitives used in the examples, please look them up in the language manual . [Example 1] Client Server We start with a simple client-server example consisting of clients interact with a bank server to withdraw money from their account. The bank server uses a backend database service to store the account balance for its clients. We will use this example to demonstrate how to implement such a system as a collection of P state machines and also check the correctness property that the bank always responds with the correct account balance for a client and a withdraw request always succeeds if there is enough balance in the account. We will also use P's capability to write multiple model checking scenarios and demonstrate how one can replace components in P with its abstraction. What will we learn through this example? We will learn about P state machines, writing simple safety and liveness specifications as P monitors, writing multiple model checking scenarios to check the correctness of a P program, and finally, replacing complex components in P with their abstractions using P's module system. Now that we understand the basic features of the P language, lets spice things up by looking at a well-known distributed protocol, and the obvious choice is to start with the textbook example of a two-phase commit protocol ! [Example 2] Two Phase Commit We use a simplified version of the classic two phase commit protocol to model a transaction commit service. The protocol uses a (single) coordinator to achieve consensus for a transaction spanning across multiple participants. A transaction in our case is simply a put operation for a key-value data store where the data store is replicated across participants. Assumptions: Note that our transaction commit system is ridiculously simplified, for example, it is not fault tolerant to node failures, failure of either coordinator or any of the participants will block the progress forever. Also, we rely on P's send semantics to model the behavior of the underlying network. What will we learn through this example? We will use this example to dive deeper into: (1) modeling non-determinism in distributed systems, in particular, time-outs (2) writing complex safety properties like atomicity of transactions in P and finally, (3) modeling node failures in P using a failure injector state machine. We will also show how P allows invoking foreign code from the P programs. More details in P foreign interface . Wow! we have reached the middle of our tutorials , its time to take a break and have an espresso coffee! In the next example, instead of modeling a distributed protocol, we consider the fun example of modeling an espresso machine and see how we can use P state machines to model a reactive system that must respond correctly to various user inputs. [Example 3] Espresso Machine P has been used in the past to implement device drivers and robotics systems ( case studies and publications ). One of the many challenges in implementing these systems is that they are reactive system and hence, must handle various streams of events (inputs) appropriately depending on their current mode of operation. In this example, we consider the example of an Espresso coffee machine where the user interacts with the coffee machine through its control panel. The control panel must correctly interprets inputs from the user and sends commands to the coffee maker. We use this example to demonstrate how using P state machine, one can capture the required reactive behavior of a coffee maker and define how it must handle different user inputs. What will we learn through this example? This is a just for fun example to demonstrate how to model a reactive system as a P state machine. We also show how using P monitors we can check that the system moves through the correct modes of operation. Energized with the Coffee , lets get back to distributed systems. After the two phase commit protocol, the next protocol that we will jump to is a simple broadcast-based failure detector! By this point in the tutorial, we have gotten familiar with the P language and most of its features. So, working through this example should be super fast! [Example 4] Failure Detector We use a broadcast based failure detector to show how to model lossy network and node failures in P. The failure detector basically broadcasts ping messages to all nodes in the system and uses a timer to wait for a pong response from all nodes. If certain node does not respond with a pong message after multiple attempts, the failure detector marks the node as down and notifies the clients. We check using a liveness specification that if the failure injecter shutsdown a particular node then the failure detector always eventually detects that node has failed and notifies the client. What will we learn through this example? In this example, we demonstrate how to use data nondeterminism to model message loss, unreliable sends, and node failures. We also discuss how to model other types of network nondeterminism. Finally, we give an example of a liveness specification that the failure detector must satisfy. [Common] Timer, Failure Injector, and Shared Memory We have described how to model system's interaction with an OS Timer Timer , and how to model injecting node failures in the system Failure Injector . These models are used in the Two Phase Commit, Espresso Machine, and Failure Detector examples. P is a purely messaging passing based programming language and hence does not support primitives for modeling shared memory based concurrency. But one can always model shared memory concurrency using message passing. We have used this style of modeling when checking the correctness of single node file systems. Please check out Shared Memory example for how to model shared memory concurrency using P. Alright, alright, alright ... lets go!","title":"Outline"},{"location":"tutsoutline/#example-1-client-server","text":"We start with a simple client-server example consisting of clients interact with a bank server to withdraw money from their account. The bank server uses a backend database service to store the account balance for its clients. We will use this example to demonstrate how to implement such a system as a collection of P state machines and also check the correctness property that the bank always responds with the correct account balance for a client and a withdraw request always succeeds if there is enough balance in the account. We will also use P's capability to write multiple model checking scenarios and demonstrate how one can replace components in P with its abstraction. What will we learn through this example? We will learn about P state machines, writing simple safety and liveness specifications as P monitors, writing multiple model checking scenarios to check the correctness of a P program, and finally, replacing complex components in P with their abstractions using P's module system. Now that we understand the basic features of the P language, lets spice things up by looking at a well-known distributed protocol, and the obvious choice is to start with the textbook example of a two-phase commit protocol !","title":"[Example 1] Client Server"},{"location":"tutsoutline/#example-2-two-phase-commit","text":"We use a simplified version of the classic two phase commit protocol to model a transaction commit service. The protocol uses a (single) coordinator to achieve consensus for a transaction spanning across multiple participants. A transaction in our case is simply a put operation for a key-value data store where the data store is replicated across participants. Assumptions: Note that our transaction commit system is ridiculously simplified, for example, it is not fault tolerant to node failures, failure of either coordinator or any of the participants will block the progress forever. Also, we rely on P's send semantics to model the behavior of the underlying network. What will we learn through this example? We will use this example to dive deeper into: (1) modeling non-determinism in distributed systems, in particular, time-outs (2) writing complex safety properties like atomicity of transactions in P and finally, (3) modeling node failures in P using a failure injector state machine. We will also show how P allows invoking foreign code from the P programs. More details in P foreign interface . Wow! we have reached the middle of our tutorials , its time to take a break and have an espresso coffee! In the next example, instead of modeling a distributed protocol, we consider the fun example of modeling an espresso machine and see how we can use P state machines to model a reactive system that must respond correctly to various user inputs.","title":"[Example 2] Two Phase Commit"},{"location":"tutsoutline/#example-3-espresso-machine","text":"P has been used in the past to implement device drivers and robotics systems ( case studies and publications ). One of the many challenges in implementing these systems is that they are reactive system and hence, must handle various streams of events (inputs) appropriately depending on their current mode of operation. In this example, we consider the example of an Espresso coffee machine where the user interacts with the coffee machine through its control panel. The control panel must correctly interprets inputs from the user and sends commands to the coffee maker. We use this example to demonstrate how using P state machine, one can capture the required reactive behavior of a coffee maker and define how it must handle different user inputs. What will we learn through this example? This is a just for fun example to demonstrate how to model a reactive system as a P state machine. We also show how using P monitors we can check that the system moves through the correct modes of operation. Energized with the Coffee , lets get back to distributed systems. After the two phase commit protocol, the next protocol that we will jump to is a simple broadcast-based failure detector! By this point in the tutorial, we have gotten familiar with the P language and most of its features. So, working through this example should be super fast!","title":"[Example 3] Espresso Machine"},{"location":"tutsoutline/#example-4-failure-detector","text":"We use a broadcast based failure detector to show how to model lossy network and node failures in P. The failure detector basically broadcasts ping messages to all nodes in the system and uses a timer to wait for a pong response from all nodes. If certain node does not respond with a pong message after multiple attempts, the failure detector marks the node as down and notifies the clients. We check using a liveness specification that if the failure injecter shutsdown a particular node then the failure detector always eventually detects that node has failed and notifies the client. What will we learn through this example? In this example, we demonstrate how to use data nondeterminism to model message loss, unreliable sends, and node failures. We also discuss how to model other types of network nondeterminism. Finally, we give an example of a liveness specification that the failure detector must satisfy.","title":"[Example 4] Failure Detector"},{"location":"tutsoutline/#common-timer-failure-injector-and-shared-memory","text":"We have described how to model system's interaction with an OS Timer Timer , and how to model injecting node failures in the system Failure Injector . These models are used in the Two Phase Commit, Espresso Machine, and Failure Detector examples. P is a purely messaging passing based programming language and hence does not support primitives for modeling shared memory based concurrency. But one can always model shared memory concurrency using message passing. We have used this style of modeling when checking the correctness of single node file systems. Please check out Shared Memory example for how to model shared memory concurrency using P. Alright, alright, alright ... lets go!","title":"[Common] Timer, Failure Injector, and Shared Memory"},{"location":"videos/","text":"Introductory tutorial on P Background and motivation behind P :: what worked and what didn't: Apple Podcast and Youtube Podcast . Tech Talks and Presentations AWS Pi-Week Talk on \"Amazon S3 Strong Consisteny\" Compositional Programming and Testing of Distributed Systems (OOPSLA, 2018) Programming Safe Robotics Systems (BAIR Talk)","title":"Videos"},{"location":"videos/#introductory-tutorial-on-p","text":"Background and motivation behind P :: what worked and what didn't: Apple Podcast and Youtube Podcast .","title":"Introductory tutorial on P"},{"location":"videos/#tech-talks-and-presentations","text":"AWS Pi-Week Talk on \"Amazon S3 Strong Consisteny\" Compositional Programming and Testing of Distributed Systems (OOPSLA, 2018) Programming Safe Robotics Systems (BAIR Talk)","title":"Tech Talks and Presentations"},{"location":"whatisP/","text":".md-typeset h1, .md-content__button { display: none; } Distributed systems are notoriously hard to get right (i.e., guaranteeing correctness) as the programmer needs to reason about numerous control paths resulting from the myriad interleaving of events (or messages or failures). Unsurprisingly, programmers can easily introduce subtle errors when designing these systems. Moreover, it is extremely difficult to test distributed systems, as most control paths remain untested, and serious bugs lie dormant for months or even years after deployment. The P programming framework takes several steps towards addressing these challenges by providing a unified framework for modeling, specifying, implementing, testing, and verifying complex distributed systems. P Framework The P framework can be divided into three important parts: P Language P provides a high-level state machine based programming language to formally model and specify distributed systems. The syntactic sugar of state machines allows programmers to capture their system design (or protocol logic ) as communicating state machines, which is how programmers generally think about their system's design. P is more of a programming language than a mathematical modelling language and hence, making it easier for the programmers to both: (1) create formal models that are closer to the implementation (sufficiently detailed) and also (2) maintain these models as the system design evolves. P supports specifying and checking both safety as well as liveness specifications (global invariants). Programmers can easily write different scenarios under which they would like to check that the system satisfies the desired correctness specification. The P module system enables programmers to model their system modularly and perform compositional testing to scale the analysis to large distributed systems. Models, Specifications, Model Checking Scenario A quick primer on what a model is, versus a specification, and model checking scenarios: (1) a specification says what the system should do (correctness properties); (2) a model captures the details of how the system does it; (3) a model checking scenario provides the finite non-deterministc test-harness or environment under which the model checker should check that the system model satisfies its specifications. The underlying model of computation for P programs is communicating state machines (or actors ). The detailed formal semantics for P can be found here and an informal discussion here . Backend Analysis Engines P provides a backend analysis engine to systematically explore behaviors of the system model ( resulting from interleaving of messages and failures ) and check that the model satisfies the desired correctness specifications. To reason about complex distributed systems, the P checker needs to tackle the well-known problem of state space explosion . The P checker employs search prioritization heuristics to drive the exploration along different parts of the state space that are most likely to have concurrency related issues. The P checker is really efficient at uncovering deep bugs (i.e., bugs that require complex interleaving of events) in the system design that have a really low probability of occurrence in real-world. On finding a bug, the checker provides a reproducible error-trace which the programmer can use for debugging. Although the current P checker is great at finding deep-hard-to-find bugs (\" Heisenbugs \"), it cannot provide a proof of correctness. We are actively working on addressing this challenge and are building two new backends for P. First, a symbolic execution engine that can scale the P checker to models of large distributed systems and provide sound guarantees of exploring all possible behaviors. Second, a deductive verification engine to perform mathematical proof of correctness for P programs. Both these backends will be released publicly soon. Code Generation The P compiler currently generates C# and C code. The generated code when combined with the P Runtime (that executes the P state machines) can be deployed on any target platform. The generated C code has been used to program device drivers and robotics systems . The generated C# code has been used to program distributed systems . We are currently working on adding support for a Java backend for P. We will also be adding support for generating runtime monitors for specifications that can be then used to check if the implementation conforms to the high-level P specifications. They are currently maintained in the dev branch symbolic-codegen . \u21a9","title":"What is P?"},{"location":"whatisP/#p-framework","text":"The P framework can be divided into three important parts:","title":"P Framework"},{"location":"whatisP/#p-language","text":"P provides a high-level state machine based programming language to formally model and specify distributed systems. The syntactic sugar of state machines allows programmers to capture their system design (or protocol logic ) as communicating state machines, which is how programmers generally think about their system's design. P is more of a programming language than a mathematical modelling language and hence, making it easier for the programmers to both: (1) create formal models that are closer to the implementation (sufficiently detailed) and also (2) maintain these models as the system design evolves. P supports specifying and checking both safety as well as liveness specifications (global invariants). Programmers can easily write different scenarios under which they would like to check that the system satisfies the desired correctness specification. The P module system enables programmers to model their system modularly and perform compositional testing to scale the analysis to large distributed systems. Models, Specifications, Model Checking Scenario A quick primer on what a model is, versus a specification, and model checking scenarios: (1) a specification says what the system should do (correctness properties); (2) a model captures the details of how the system does it; (3) a model checking scenario provides the finite non-deterministc test-harness or environment under which the model checker should check that the system model satisfies its specifications. The underlying model of computation for P programs is communicating state machines (or actors ). The detailed formal semantics for P can be found here and an informal discussion here .","title":"P Language"},{"location":"whatisP/#backend-analysis-engines","text":"P provides a backend analysis engine to systematically explore behaviors of the system model ( resulting from interleaving of messages and failures ) and check that the model satisfies the desired correctness specifications. To reason about complex distributed systems, the P checker needs to tackle the well-known problem of state space explosion . The P checker employs search prioritization heuristics to drive the exploration along different parts of the state space that are most likely to have concurrency related issues. The P checker is really efficient at uncovering deep bugs (i.e., bugs that require complex interleaving of events) in the system design that have a really low probability of occurrence in real-world. On finding a bug, the checker provides a reproducible error-trace which the programmer can use for debugging. Although the current P checker is great at finding deep-hard-to-find bugs (\" Heisenbugs \"), it cannot provide a proof of correctness. We are actively working on addressing this challenge and are building two new backends for P. First, a symbolic execution engine that can scale the P checker to models of large distributed systems and provide sound guarantees of exploring all possible behaviors. Second, a deductive verification engine to perform mathematical proof of correctness for P programs. Both these backends will be released publicly soon.","title":"Backend Analysis Engines"},{"location":"whatisP/#code-generation","text":"The P compiler currently generates C# and C code. The generated code when combined with the P Runtime (that executes the P state machines) can be deployed on any target platform. The generated C code has been used to program device drivers and robotics systems . The generated C# code has been used to program distributed systems . We are currently working on adding support for a Java backend for P. We will also be adding support for generating runtime monitors for specifications that can be then used to check if the implementation conforms to the high-level P specifications. They are currently maintained in the dev branch symbolic-codegen . \u21a9","title":"Code Generation"},{"location":"advanced/PProject/","text":"The current project file interface is a simple mechanism to provide all the required inputs to the compiler in XML format. The P project file below is taken from the TwoPhaseCommit example in Tutorials. <!-- P project file for the Two Phase Commit example --> <Project> <ProjectName> TwoPhaseCommit </ProjectName> <InputFiles> <PFile> ./PSrc/ </PFile> <PFile> ./PSpec/ </PFile> <PFile> ./PTst/ </PFile> <PFile> ./PForeign/ </PFile> </InputFiles> <OutputDir> ./PGenerated/ </OutputDir> <!-- Add the dependencies for the Timer machine --> <IncludeProject> ../Common/Timer/Timer.pproj </IncludeProject> <!-- Add the dependencies for the FailureInjector machine --> <IncludeProject> ../Common/FailureInjector/FailureInjector.pproj </IncludeProject> </Project> The <InputFiles> block provides all the P files that must be compiled together for this project. In <PFile> , you can either specify the path to the P file or to a folder and the P compiler includes all the files in the folder during compilation. The <ProjectName> block provides the name for the project which is used as the output file name. The <OutputDir> block provides the output directory for the generated code. Finally, <IncludeProject> block provides path to other P projects that must be included as dependencies during compilation. The P compiler simply recursively copies all the P files in the dependency projects and compiles them together. This feature provides a way to split the P models for a large system into subprojects that can share models.","title":"P Project File"},{"location":"advanced/debuggingerror/","text":"If you are using an older P version 1.x.x, please find the usage guide here As described in the using P compiler and checker section, running the following command for the ClientServer example finds an error. p check -tc tcSingleClientAbstractServer -i 100 Expected Output $ p check -tc tcSingleClientAbstractServer -i 100 .. Searching for a P compiled file locally in the current folder .. Found a P compiled file: P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll .. Checking P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll .. Test case :: tcSingleClientAbstractServer ... Checker is using 'random' strategy (seed:1415055147). ..... Iteration #1 Checker found a bug. ... Emitting traces: ..... Writing PCheckerOutput/BugFinding/ClientServer_0_0.txt ..... Writing PCheckerOutput/BugFinding/ClientServer_0_0.dgml ..... Writing PCheckerOutput/BugFinding/ClientServer_0_0.schedule ... Elapsed 0.2099244 sec. ... Emitting coverage reports: ..... Writing PCheckerOutput/BugFinding/ClientServer.dgml ..... Writing PCheckerOutput/BugFinding/ClientServer.coverage.txt ..... Writing PCheckerOutput/BugFinding/ClientServer.sci ... Checking statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 1 schedule: 1 fair and 0 unfair. ..... Found 100.00% buggy schedules. ..... Number of scheduling points in fair terminating schedules: 17 (min), 17 (avg), 17 (max). ... Elapsed 0.3671006 sec. . Done [PTool]: Thanks for using P! The P checker on finding a bug generates two artifacts (highlighted in the expected output above): A textual trace file (e.g., ClientServer_0_0.txt ) that has the readable error trace representing the sequence of steps from the intial state to the error state. A schedule file (e.g., ClientServer_0_0.schedule ) that can be used to replay the error trace and single step through the P program with the generated error trace for debugging. Error Trace The *.txt file contains a textual error trace representing the sequence of steps (i.e, messages sent, messages received, machines created) from the initial state to the final error state. In the end of the error trace is the final error message, for example, in the case of ClientServer example above, you must see the following in the end of the error trace. <ErrorLog> Assertion Failed: Bank must accept the withdraw request for 1, bank balance is 11! In most cases, you can ignore the stack trace and information below the ErrorLog . Replaying the Error Schedule One can also replay the error schedule using commandline and enabling verbose feature to dump out the error trace on the commandline. p check --replay <buggy>.schedule -tc <testcaseName> -v For example, p check --replay PCheckerOutput/BugFinding/ClientServer_0_0.schedule \\ -tc tcSingleClientAbstractServer \\ -v","title":"Debugging Error Traces (counter examples)"},{"location":"advanced/debuggingerror/#error-trace","text":"The *.txt file contains a textual error trace representing the sequence of steps (i.e, messages sent, messages received, machines created) from the initial state to the final error state. In the end of the error trace is the final error message, for example, in the case of ClientServer example above, you must see the following in the end of the error trace. <ErrorLog> Assertion Failed: Bank must accept the withdraw request for 1, bank balance is 11! In most cases, you can ignore the stack trace and information below the ErrorLog .","title":"Error Trace"},{"location":"advanced/debuggingerror/#replaying-the-error-schedule","text":"One can also replay the error schedule using commandline and enabling verbose feature to dump out the error trace on the commandline. p check --replay <buggy>.schedule -tc <testcaseName> -v For example, p check --replay PCheckerOutput/BugFinding/ClientServer_0_0.schedule \\ -tc tcSingleClientAbstractServer \\ -v","title":"Replaying the Error Schedule"},{"location":"advanced/importanceliveness/","text":"When reasoning about the correctness of a distributed system, it is really important to specify both safety as well as liveness specifications . The examples in Tutorials show how to specify both safety and liveness specifications using P Monitors. Always specify both safety and liveness specifications Only specifying safety property for a system is not enough, this is mainly because, a system model may be incorrect and in the worst case drop all requests on to the ether and not perform any operation. Such a system trivially satisfies all correctness specifications! Hence, it becomes essential to combine that safety property with liveness properties to check that the system is making progress and servicing the requests. Running the checker on models that have both safety and liveness properties ensures that for all executions explored by the checker, requests are eventually serviced by the system (by sending responses potentially) and all the responses sent by the system satisfy the desired correctness safety specification. This helps ensure that your models are not doing something trivially incorrect like always doing nothing , in which case running the checker on such a model adds no value. For example, in the case of the client server example, the BankBalanceIsAlwaysCorrect safety property checks that the response sent by the bank server is always correct and combining it with the GuaranteedWithDrawProgress liveness property ensures that system will always eventually send a response which will be checked for correctness by the safety property.","title":"Importance of Liveness Specifications"},{"location":"advanced/p2c/","text":"Generating C Program P programs can be compiled to their C equivalents. Compilation to C can be performed by specifying the target language to the P compiler as follow. pc -generate:C myProgram.p Executing this command generates two files in the current directory: myProgram.h and myProgram.c , which are the C equivalent of the P program. Compiling Generated C Program myProgram.h and myProgram.c only contain C representations of the constructs defined in the P program; therefore, a driver C program defining the main function and instantiating one of the machines is needed to start the execution. Below, an example driver program is presented. #include \"myProgram.h\" #include \"Prt.h\" #include <stdio.h> PRT_PROCESS * MAIN_P_PROCESS ; static PRT_BOOLEAN cooperative = PRT_TRUE ; static int threads = 2 ; long threadsRunning = 0 ; pthread_mutex_t threadsRunning_mutex ; static const char * parg = NULL ; void ErrorHandler ( PRT_STATUS status , PRT_MACHINEINST * ptr ) { if ( status == PRT_STATUS_ASSERT ) { fprintf_s ( stdout , \"exiting with PRT_STATUS_ASSERT (assertion failure) \\n \" ); exit ( 1 ); } else if ( status == PRT_STATUS_EVENT_OVERFLOW ) { fprintf_s ( stdout , \"exiting with PRT_STATUS_EVENT_OVERFLOW \\n \" ); exit ( 1 ); } else if ( status == PRT_STATUS_EVENT_UNHANDLED ) { fprintf_s ( stdout , \"exiting with PRT_STATUS_EVENT_UNHANDLED \\n \" ); exit ( 1 ); } else if ( status == PRT_STATUS_QUEUE_OVERFLOW ) { fprintf_s ( stdout , \"exiting with PRT_STATUS_QUEUE_OVERFLOW \\n \" ); exit ( 1 ); } else if ( status == PRT_STATUS_ILLEGAL_SEND ) { fprintf_s ( stdout , \"exiting with PRT_STATUS_ILLEGAL_SEND \\n \" ); exit ( 1 ); } else { fprintf_s ( stdout , \"unexpected PRT_STATUS in ErrorHandler: %d \\n \" , status ); exit ( 2 ); } } void Log ( PRT_STEP step , PRT_MACHINESTATE * senderState , PRT_MACHINEINST * receiver , PRT_VALUE * event , PRT_VALUE * payload ) { PrtPrintStep ( step , senderState , receiver , event , payload ); } void decrement_threadsRunning () { pthread_mutex_lock ( & threadsRunning_mutex ); threadsRunning = threadsRunning - 1 ; pthread_mutex_unlock ( & threadsRunning_mutex ); } long get_threadsRunning () { long c ; pthread_mutex_lock ( & threadsRunning_mutex ); c = threadsRunning ; pthread_mutex_unlock ( & threadsRunning_mutex ); return ( c ); } void PRT_CALL_CONV MyAssert ( PRT_INT32 condition , PRT_CSTRING message ) { if ( condition != 0 ) { return ; } else if ( message == NULL ) { fprintf_s ( stderr , \"ASSERT\" ); } else { fprintf_s ( stderr , \"ASSERT: %s\" , message ); } exit ( 1 ); } static void RunToIdle ( void * process ) { // In the tester we run the state machines until there is no more work to do then we exit // instead of blocking indefinitely. This is then equivalent of the non-cooperative case // where we PrtRunStateMachine once (inside PrtMkMachine). So we do NOT call PrtWaitForWork. // PrtWaitForWork((PRT_PROCESS*)process); PRT_PROCESS_PRIV * privateProcess = ( PRT_PROCESS_PRIV * ) process ; while ( privateProcess -> terminating == PRT_FALSE ) { ; } decrement_threadsRunning (); } int main ( int argc , char * argv []) { PRT_DBG_START_MEM_BALANCED_REGION { PRT_GUID processGuid ; PRT_VALUE * payload ; processGuid . data1 = 1 ; processGuid . data2 = 0 ; processGuid . data3 = 0 ; processGuid . data4 = 0 ; MAIN_P_PROCESS = PrtStartProcess ( processGuid , & P_GEND_IMPL_DefaultImpl , ErrorHandler , Log ); if ( cooperative ) { PrtSetSchedulingPolicy ( MAIN_P_PROCESS , PRT_SCHEDULINGPOLICY_COOPERATIVE ); } if ( parg == NULL ) { payload = PrtMkNullValue (); } else { int i = atoi ( parg ); payload = PrtMkIntValue ( i ); } PrtUpdateAssertFn ( MyAssert ); PRT_UINT32 machineId ; PRT_BOOLEAN foundMainMachine = PrtLookupMachineByName ( \"myMachine\" , & machineId ); if ( foundMainMachine == PRT_FALSE ) { printf ( \"%s \\n \" , \"FAILED TO FIND DroneMachine\" ); exit ( 1 ); } PrtMkMachine ( MAIN_P_PROCESS , machineId , 1 , & payload ); if ( cooperative ) { typedef void * ( * start_routine ) ( void * ); pthread_t tid [ threads ]; for ( int i = 0 ; i < threads ; i ++ ) { threadsRunning ++ ; pthread_create ( & tid [ i ], NULL , ( start_routine ) RunToIdle , ( void * ) MAIN_P_PROCESS ); } while ( get_threadsRunning () != 0 ); } PrtFreeValue ( payload ); PrtStopProcess ( MAIN_P_PROCESS ); } PRT_DBG_END_MEM_BALANCED_REGION } One needs to notice couple of details of the given C program. The program includes myProgram.h as it is calling constructs defined in the C equivalent of the program. Global variables defined at the begining of the program are parameters that are used for different configuration of the program. ErrorHandler is a function defined to provide an interface for the runtime errors. Log is a function defined to print the steps taken by the runtime backend. decrement_threadsRunning and get_threadsRunning are helper functions used for multi-threaded execution. MyAssert is function defined to provide an interface for the runtime assertions. RunToIdle is a function defined to run a given process until termination. main starts the execution by using all the functions and parameters defined previously. First, it starts the main P process by calling PrtStartProcess , which returns a PRT_PROCESS pointer. Next, if the scheduling policy is set to cooperative by the corresponding global variable, then the main function sets the scheduling policy to cooperative. Then, by using the method PrtLookupMachineByName , we look for a machine defined in the program by its name and get its id. With the id we create the machine by calling PrtMkMachine . Notice that if cooperative scheduling is disabled, i.e., task neutral policy is selected, then the execution starts immediately after creating the machine. If cooperative scheduling is enabled, one can either call PrtRunProcess with MAIN_P_PROCESS , i.e., PrtRunProcess(MAIN_P_PROCESS) , which will run the program with cooperative scheduling using only one thread, or run the while loop given in the program. The while loop given in the program distributes the work among the specified number of worker threads. In this case, the program will not exit until all worker threads are done. Now that we have a driver C program, we need to compile the generated C program to an executable. To compile and execute the generated C program with respect to P semantics, we need to link P runtime backend with the C representation of the program and the driver C program during compilation. We recommend using CMake for this purpose, an example CMakeLists.txt is given below. cmake_minimum_required ( VERSION 3.1 ) project ( myProgram ) set ( projectName myProgram ) find_package ( Threads ) include_directories ( /path/to/P/Bld/Drops/Prt/include ) add_definitions ( -DPRT_PLAT_LINUXUSER ) add_executable ( myProgram myProgram.h myProgram.c main.c /path/to/P/Bld/Drops/Prt/include/ext_compat.h /path/to/P/Bld/Drops/Prt/include/libhandler.h /path/to/P/Bld/Drops/Prt/include/libhandler-internal.h /path/to/P/Bld/Drops/Prt/include/Prt.h /path/to/P/Bld/Drops/Prt/include/PrtConfig.h /path/to/P/Bld/Drops/Prt/include/PrtExecution.h /path/to/P/Bld/Drops/Prt/include/PrtLinuxUserConfig.h /path/to/P/Bld/Drops/Prt/include/PrtProgram.h /path/to/P/Bld/Drops/Prt/include/PrtTypes.h /path/to/P/Bld/Drops/Prt/include/PrtValues.h /path/to/P/Bld/Drops/Prt/include/sal.h ) target_link_libraries ( myProgram /path/to/P/Bld/Drops/Prt/lib/libPrt_static.a /path/to/P/Ext/libhandler/out/gcc-amd64-apple-darwin20.6.0/debug/libhandler.a # If you are not using MacOS, you need to change gcc-amd64-apple-darwin20.6.0 accordingly! ) This file links all necessary P runtime backend libraries with the project. To compile, run the following. cmake CMakeLists.txt make After running these commands, the executable myProgram will be in the current directory, which can be executed simply as follows. ./myProgram One can extend this project structure, and build more complicated applications.","title":"P2c"},{"location":"advanced/p2c/#generating-c-program","text":"P programs can be compiled to their C equivalents. Compilation to C can be performed by specifying the target language to the P compiler as follow. pc -generate:C myProgram.p Executing this command generates two files in the current directory: myProgram.h and myProgram.c , which are the C equivalent of the P program.","title":"Generating C Program"},{"location":"advanced/p2c/#compiling-generated-c-program","text":"myProgram.h and myProgram.c only contain C representations of the constructs defined in the P program; therefore, a driver C program defining the main function and instantiating one of the machines is needed to start the execution. Below, an example driver program is presented. #include \"myProgram.h\" #include \"Prt.h\" #include <stdio.h> PRT_PROCESS * MAIN_P_PROCESS ; static PRT_BOOLEAN cooperative = PRT_TRUE ; static int threads = 2 ; long threadsRunning = 0 ; pthread_mutex_t threadsRunning_mutex ; static const char * parg = NULL ; void ErrorHandler ( PRT_STATUS status , PRT_MACHINEINST * ptr ) { if ( status == PRT_STATUS_ASSERT ) { fprintf_s ( stdout , \"exiting with PRT_STATUS_ASSERT (assertion failure) \\n \" ); exit ( 1 ); } else if ( status == PRT_STATUS_EVENT_OVERFLOW ) { fprintf_s ( stdout , \"exiting with PRT_STATUS_EVENT_OVERFLOW \\n \" ); exit ( 1 ); } else if ( status == PRT_STATUS_EVENT_UNHANDLED ) { fprintf_s ( stdout , \"exiting with PRT_STATUS_EVENT_UNHANDLED \\n \" ); exit ( 1 ); } else if ( status == PRT_STATUS_QUEUE_OVERFLOW ) { fprintf_s ( stdout , \"exiting with PRT_STATUS_QUEUE_OVERFLOW \\n \" ); exit ( 1 ); } else if ( status == PRT_STATUS_ILLEGAL_SEND ) { fprintf_s ( stdout , \"exiting with PRT_STATUS_ILLEGAL_SEND \\n \" ); exit ( 1 ); } else { fprintf_s ( stdout , \"unexpected PRT_STATUS in ErrorHandler: %d \\n \" , status ); exit ( 2 ); } } void Log ( PRT_STEP step , PRT_MACHINESTATE * senderState , PRT_MACHINEINST * receiver , PRT_VALUE * event , PRT_VALUE * payload ) { PrtPrintStep ( step , senderState , receiver , event , payload ); } void decrement_threadsRunning () { pthread_mutex_lock ( & threadsRunning_mutex ); threadsRunning = threadsRunning - 1 ; pthread_mutex_unlock ( & threadsRunning_mutex ); } long get_threadsRunning () { long c ; pthread_mutex_lock ( & threadsRunning_mutex ); c = threadsRunning ; pthread_mutex_unlock ( & threadsRunning_mutex ); return ( c ); } void PRT_CALL_CONV MyAssert ( PRT_INT32 condition , PRT_CSTRING message ) { if ( condition != 0 ) { return ; } else if ( message == NULL ) { fprintf_s ( stderr , \"ASSERT\" ); } else { fprintf_s ( stderr , \"ASSERT: %s\" , message ); } exit ( 1 ); } static void RunToIdle ( void * process ) { // In the tester we run the state machines until there is no more work to do then we exit // instead of blocking indefinitely. This is then equivalent of the non-cooperative case // where we PrtRunStateMachine once (inside PrtMkMachine). So we do NOT call PrtWaitForWork. // PrtWaitForWork((PRT_PROCESS*)process); PRT_PROCESS_PRIV * privateProcess = ( PRT_PROCESS_PRIV * ) process ; while ( privateProcess -> terminating == PRT_FALSE ) { ; } decrement_threadsRunning (); } int main ( int argc , char * argv []) { PRT_DBG_START_MEM_BALANCED_REGION { PRT_GUID processGuid ; PRT_VALUE * payload ; processGuid . data1 = 1 ; processGuid . data2 = 0 ; processGuid . data3 = 0 ; processGuid . data4 = 0 ; MAIN_P_PROCESS = PrtStartProcess ( processGuid , & P_GEND_IMPL_DefaultImpl , ErrorHandler , Log ); if ( cooperative ) { PrtSetSchedulingPolicy ( MAIN_P_PROCESS , PRT_SCHEDULINGPOLICY_COOPERATIVE ); } if ( parg == NULL ) { payload = PrtMkNullValue (); } else { int i = atoi ( parg ); payload = PrtMkIntValue ( i ); } PrtUpdateAssertFn ( MyAssert ); PRT_UINT32 machineId ; PRT_BOOLEAN foundMainMachine = PrtLookupMachineByName ( \"myMachine\" , & machineId ); if ( foundMainMachine == PRT_FALSE ) { printf ( \"%s \\n \" , \"FAILED TO FIND DroneMachine\" ); exit ( 1 ); } PrtMkMachine ( MAIN_P_PROCESS , machineId , 1 , & payload ); if ( cooperative ) { typedef void * ( * start_routine ) ( void * ); pthread_t tid [ threads ]; for ( int i = 0 ; i < threads ; i ++ ) { threadsRunning ++ ; pthread_create ( & tid [ i ], NULL , ( start_routine ) RunToIdle , ( void * ) MAIN_P_PROCESS ); } while ( get_threadsRunning () != 0 ); } PrtFreeValue ( payload ); PrtStopProcess ( MAIN_P_PROCESS ); } PRT_DBG_END_MEM_BALANCED_REGION } One needs to notice couple of details of the given C program. The program includes myProgram.h as it is calling constructs defined in the C equivalent of the program. Global variables defined at the begining of the program are parameters that are used for different configuration of the program. ErrorHandler is a function defined to provide an interface for the runtime errors. Log is a function defined to print the steps taken by the runtime backend. decrement_threadsRunning and get_threadsRunning are helper functions used for multi-threaded execution. MyAssert is function defined to provide an interface for the runtime assertions. RunToIdle is a function defined to run a given process until termination. main starts the execution by using all the functions and parameters defined previously. First, it starts the main P process by calling PrtStartProcess , which returns a PRT_PROCESS pointer. Next, if the scheduling policy is set to cooperative by the corresponding global variable, then the main function sets the scheduling policy to cooperative. Then, by using the method PrtLookupMachineByName , we look for a machine defined in the program by its name and get its id. With the id we create the machine by calling PrtMkMachine . Notice that if cooperative scheduling is disabled, i.e., task neutral policy is selected, then the execution starts immediately after creating the machine. If cooperative scheduling is enabled, one can either call PrtRunProcess with MAIN_P_PROCESS , i.e., PrtRunProcess(MAIN_P_PROCESS) , which will run the program with cooperative scheduling using only one thread, or run the while loop given in the program. The while loop given in the program distributes the work among the specified number of worker threads. In this case, the program will not exit until all worker threads are done. Now that we have a driver C program, we need to compile the generated C program to an executable. To compile and execute the generated C program with respect to P semantics, we need to link P runtime backend with the C representation of the program and the driver C program during compilation. We recommend using CMake for this purpose, an example CMakeLists.txt is given below. cmake_minimum_required ( VERSION 3.1 ) project ( myProgram ) set ( projectName myProgram ) find_package ( Threads ) include_directories ( /path/to/P/Bld/Drops/Prt/include ) add_definitions ( -DPRT_PLAT_LINUXUSER ) add_executable ( myProgram myProgram.h myProgram.c main.c /path/to/P/Bld/Drops/Prt/include/ext_compat.h /path/to/P/Bld/Drops/Prt/include/libhandler.h /path/to/P/Bld/Drops/Prt/include/libhandler-internal.h /path/to/P/Bld/Drops/Prt/include/Prt.h /path/to/P/Bld/Drops/Prt/include/PrtConfig.h /path/to/P/Bld/Drops/Prt/include/PrtExecution.h /path/to/P/Bld/Drops/Prt/include/PrtLinuxUserConfig.h /path/to/P/Bld/Drops/Prt/include/PrtProgram.h /path/to/P/Bld/Drops/Prt/include/PrtTypes.h /path/to/P/Bld/Drops/Prt/include/PrtValues.h /path/to/P/Bld/Drops/Prt/include/sal.h ) target_link_libraries ( myProgram /path/to/P/Bld/Drops/Prt/lib/libPrt_static.a /path/to/P/Ext/libhandler/out/gcc-amd64-apple-darwin20.6.0/debug/libhandler.a # If you are not using MacOS, you need to change gcc-amd64-apple-darwin20.6.0 accordingly! ) This file links all necessary P runtime backend libraries with the project. To compile, run the following. cmake CMakeLists.txt make After running these commands, the executable myProgram will be in the current directory, which can be executed simply as follows. ./myProgram One can extend this project structure, and build more complicated applications.","title":"Compiling Generated C Program"},{"location":"advanced/psemantics/","text":"Before getting started with the tutorials, we provide a quick informal overview of the P language semantics so that the readers can keep it at the back of their mind as they walk through the tutorials and the language manual . P is a programming language. P is a state machine based programming language and hence, just like any other imperative programming language it supports basic data types , expressions , and statements that enable programmers to capture complex distributed systems protocol logic as a collection of event-handlers or functions (in P state machines). P State machines. The underlying model of computation for P state machines is similar to that of Gul Agha's Actor-model-of-computation ( wiki ). A P program is a collection of concurrently executing state machines that communicate with eachother by sending events (or messages) asynchronously. Each P state machine has an unbounded FIFO buffer associated with it. Sends are asynchronous , i.e., executing a send operation send t,e,v; adds event e with payload value v into the FIFO buffer of the target machine t . Each state in the P state machine has an entry function associated with it which gets executed when the state machine enters that state. After executing the entry function, the machine tries to dequeue an event from the input buffer or blocks if the buffer is empty. Upon dequeuing an event from the input queue of the machine, the attached handler is executed which might transition the machine to a different state. We will provide more details about the P state machines in tutorials as well as the language manual. For detailed formal semantics of P state machines, we refer the readers to the original P paper and the more recent paper with updated semantics. There are two main distinctions with actor model of computation: (1) P adds the syntactic sugar of state machines to actors, and (2) each state machine in P has an unbounded FIFO buffer associated with it instead of an unbounded bag in actors (semantic difference). [Important] Send semantics in P Sends are reliable, buffered, non-blocking, and directed (not broadcast). Sends are reliable i.e., executing a send operation in P adds an event into the target machines buffer. Hence, if one wants to model message loss it has to be modeled explicitly (discussed in the Failure Detector example in the tutorial). Similarly, as P state machine buffers are FIFO, events are dequeued at the state machine in the causal order in which they were sent. Note that events that are sent by two different concurrent machines will be interleaved by the checker and hence, will appear in different order at the target machine but the events sent by the same machine will always appear in the same order at the target state machine. So, just like message loss, arbitrary message re-ordering also has to be explicitly modeled in P (explained in the Paxos example in the tutorials). In general, we find that re-ordering messages/events coming from the same machine is not important and does not lead to any interesting behaviors. More interesting behaviors happen because of interleaving of messages across different state machines which the P checker explores automatically. Summary, by default, the communication between state machines using send operation follows the above semantics. If you would like to check your system correctness against an arbitrarily network then one would have to model the corresponding send semantics in P explicitly. One can then make the arbitrarily network behave as expected with message duplicates, loss, re-order, etc. If you have any further doubts related to this topic and modeling network semantics when reasoning using P, feel free to get in touch with Ankush Desai. We have several examples of such cases. [Important] New semantics in P State machines in P can be dynamically created during the execution of the Program using the new primitive. Creation of a state machine is also an asynchronous, non-blocking operation. P Monitors. Specifications in P are written as global runtime monitors. These global monitors observe the execution of the system and can assert any global safety or liveness invariants on the system. Note that the monitors are synchronously composed with the P state machines. Details are explained in the language manual and we provide examples in the tutorial. When reasoning about the correctness of a distributed system, it is really important to specify both safety as well as liveness specifications . Always specify both safety and liveness specifications Only specifying safety property for a system is not enough, this is mainly because, a system model may be incorrect and in the worst case drop all requests on to the ether and not perform any operation. Such a system trivially satisfies all correctness specifications! Hence, it becomes essentially to combine that safety property with liveness properties to check that the system is making progress and servicing the requests. Running the checker on models that have both safety and liveness properties ensure that for all executions explored by the checker, requests are eventually serviced by the system (by sending responses potentially) and all the responses sent by the system satisfy the desired correctness safety specification. This helps ensure that your models are not doing something trivially incorrect like always doing nothing , in which case running the checker on such a model adds no value. P Checker. The P Checker explores different possible behaviors of the P program arising out of: (1) concurrency: different interleavings of events from concurrently executing state machines as well as (2) data nondeterminism: different data input choices in the P program modeled using the choose ( see ) operation. The P checker explores different executions of the system that can happen because of these two forms of nondeterminism and asserts that for each of these executions the system satisfies the desired properties specified by the P Monitors.","title":"P Semantics"},{"location":"advanced/structureOfPProgram/","text":"A P program is typically divided into four folders (or parts): PSrc : contains all the state machines representing the implementation (model) of the system or protocol to be verified or tested. PSpec : contains all the specifications representing the correctness properties that the system must satisfy. PTst : contains all the environment or test harness state machines that model the non-deterministic scenarios under which we want to check that the system model in PSrc satisfies the specifications in PSpec . P allows writing different model checking scenarios as test-cases. PForeign : P also supports interfacing with foreign languages like Java , C# , and C/C++ . P allows programmers to implement a part of their protocol logic in these foreign languages and use them in a P program using the foreign types and functions interface ( Foreign ). The PForeign folder contains all the foreign code used in the P program. Recommendation The folder structure described above is just a recommendation. The P compiler does not require any particular folder structure for a P project. The examples in the Tutorials use the same folder structure. Models, Specifications, Model Checking Scenario A quick primer on what a model is, versus a specification, and model checking scenarios: (1) A specification says what the system should do (correctness properties). (2) A model captures the details of how the system does it. (3) A model checking scenario provides the finite non-deterministc test-harness or environment under which the model checker should check that the system model satisfies its specifications.","title":"Structure of a P Program"},{"location":"advanced/psym/install/","text":"PSym is built to be cross-platform and can be used on MacOS, Linux, and Windows. [Steps 1 to 5] Install P Follow the instructions on installing P from Installing P (at least up to and including Step 3 ) [Step 6] Install Maven If you already have Maven 3.3+ installed , ignore this step. To install Maven use: MacOS Installing Maven on MacOS using Homebrew ( details ) brew install maven Dont have Homebrew? Directly use installer . Ubuntu Installing Maven on Ubuntu ( details ) sudo apt install maven Amazon Linux Visit the Maven releases page Identify the latest release or the release you wish to use. Steps for installing Maven 3.8.6 on Amazon Linux (you can use any version of Maven 3.3+): wget https://dlcdn.apache.org/maven/maven-3/3.8.6/binaries/apache-maven-3.8.6-bin.tar.gz tar xfv apache-maven-3.8.6-bin.tar.gz You might do this in your home directory, yielding a folder like /home/$USER/apache-maven-3.8.6 Next, install the software into your environment by adding it to your path, and by defining Maven's environment variables: export M2_HOME=/home/$USER/apache-maven-3.6.3 export M2=$M2_HOME/bin export PATH=$M2:$PATH Windows Installing Maven on Windows ( details ) Troubleshoot: Confirm that Maven is correctly installed on your machine. mvn -version If you get mvn command not found error, mostly likely, you need to add the path to $M2_HOME/bin in your PATH . Great ! You are all set to check your P program with PSym !","title":"Install"},{"location":"advanced/psym/install/#steps-1-to-5-install-p","text":"Follow the instructions on installing P from Installing P (at least up to and including Step 3 )","title":"[Steps 1 to 5] Install P"},{"location":"advanced/psym/install/#step-6-install-maven","text":"If you already have Maven 3.3+ installed , ignore this step. To install Maven use: MacOS Installing Maven on MacOS using Homebrew ( details ) brew install maven Dont have Homebrew? Directly use installer . Ubuntu Installing Maven on Ubuntu ( details ) sudo apt install maven Amazon Linux Visit the Maven releases page Identify the latest release or the release you wish to use. Steps for installing Maven 3.8.6 on Amazon Linux (you can use any version of Maven 3.3+): wget https://dlcdn.apache.org/maven/maven-3/3.8.6/binaries/apache-maven-3.8.6-bin.tar.gz tar xfv apache-maven-3.8.6-bin.tar.gz You might do this in your home directory, yielding a folder like /home/$USER/apache-maven-3.8.6 Next, install the software into your environment by adding it to your path, and by defining Maven's environment variables: export M2_HOME=/home/$USER/apache-maven-3.6.3 export M2=$M2_HOME/bin export PATH=$M2:$PATH Windows Installing Maven on Windows ( details ) Troubleshoot: Confirm that Maven is correctly installed on your machine. mvn -version If you get mvn command not found error, mostly likely, you need to add the path to $M2_HOME/bin in your PATH . Great ! You are all set to check your P program with PSym !","title":"[Step 6] Install Maven"},{"location":"advanced/psym/usingPSym/","text":"Before moving forward, we assume that you have successfully installed PSym . In this section, we provide an overview of the steps involved in compiling and checking a P program with PSym using the client server example in Tutorials. Get the Client Server Example Locally We will use the ClientServer example from Tutorial folder in P repository to describe the process of compiling and checking a P program with PSym. Please clone the P repo and navigate to the ClientServer example in Tutorial. Clone P Repo locally: git clone https://github.com/p-org/P.git Navigate to the ClientServer examples folder: cd <P cloned folder>/Tutorial/1_ClientServer Compiling a P program for PSym Simply pass the commandline argument -generate:PSym when running the P compiler pc . Alternative way: Set <Target> as PSym in *.pproj Set the <Target> field as PSym in the P project file ( *.pproj ) Example: <!-- P Project file for the Client Server example --> <Project> <ProjectName> ClientServer </ProjectName> <InputFiles> <PFile> ./PSrc/ </PFile> <PFile> ./PSpec/ </PFile> <PFile> ./PTst/ </PFile> </InputFiles> <OutputDir> ./PGenerated/ </OutputDir> <Target> PSym </Target> </Project> Recommendation We recommend using the P project file *.pproj along with passing -generate:PSym as commandline argument to the compiler to compile a P program for PSym. Commandline argument -generate:XXX takes priority over <Target>YYY</Target> in *.pproj file. Compiling the ClientServer project for PSym pc -proj:ClientServer.pproj -generate:PSym Expected Output $ pc -proj:ClientServer.pproj -generate:PSym ---------------------------------------- ==== Loading project file: ClientServer.pproj ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Server.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Client.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/AbstractBankServer.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/ClientServerModules.p ....... includes p file: P/Tutorial/1_ClientServer/PSpec/BankBalanceCorrect.p ....... includes p file: P/Tutorial/1_ClientServer/PTst/TestDriver.p ....... includes p file: P/Tutorial/1_ClientServer/PTst/Testscript.p ---------------------------------------- ---------------------------------------- Parsing ... Type checking ... Code generation ... Generated clientserver.java. ---------------------------------------- Compiling ClientServer... ClientServer -> target/ClientServer-jar-with-dependencies.jar Build succeeded. ---------------------------------------- Checking a P program with PSym Compiling the ClientServer program generates a ClientServer-jar-with-dependencies.jar . This .jar is the symbolically-instrumented intermediate representation of the P program in Java, along with a packaged PSym runtime. Running this .jar file executes PSym to systematically explore behaviors of the program for the specified test case. The .jar is present in the target/ folder, also printed in the compiler output: ClientServer -> target/ClientServer-jar-with-dependencies.jar You can get the list of test cases defined in the P program by running the generated .jar : java -jar target/ClientServer-jar-with-dependencies.jar Expected Output java -jar target/ClientServer-jar-with-dependencies.jar Picked up JAVA_TOOL_OPTIONS: -Dlog4j2.formatMsgNoLookups=true WARNING: sun.reflect.Reflection.getCallerClass is not supported. This will impact performance. Reflections took 100 ms to scan 1 urls, producing 38 keys and 168 values Loading:: /Volumes/workplace/psym/src/PSymTest/exp/Examples/Tutorial/1_ClientServer/target/ClientServer-jar-with-dependencies.jar Setting solver engine to BDD + Bdd Reflections took 63 ms to scan 1 urls, producing 38 keys and 168 values Provide /method or -m flag to qualify the test method name you wish to use. Possible options are:: tcSingleClient tcMultipleClients There are three test cases defined in the ClientServer P project, and you can specify which test case to run by using the -m or --method parameter along with, say, a --time-limit <seconds> parameter to specify a time limit for the run in seconds. By default, PSym explores as many schedules as it can within a time limit of 60 seconds. So to run the tcSingleClient test case for 10 seconds, we can use the following command: java -jar target/ClientServer-jar-with-dependencies.jar \\ -m tcSingleClient \\ --time-limit 10 Expected Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Picked up JAVA_TOOL_OPTIONS: -Dlog4j2.formatMsgNoLookups=true WARNING: sun.reflect.Reflection.getCallerClass is not supported. This will impact performance. Reflections took 93 ms to scan 1 urls, producing 38 keys and 172 values . Checking /Users/goelaman/work/ws/version/github/P/Tutorial/1_ClientServer/target/ClientServer-jar-with-dependencies.jar Reflections took 45 ms to scan 1 urls, producing 38 keys and 172 values ... Method tcSingleClient ... Project clientserver is using 'default' strategy (seed:0) -------------------- Time Memory Coverage Iteration Remaining Depth States 00:00:10 0.2 GB 1.4246418994 % 140 1820 (100 % data) 1 8043 -------------------- Estimated Coverage:: 1.4246418994 % Distinct States Explored:: 8043 -------------------- Explored 140 single executions Took 10 seconds and 0.2 GB Result: partially safe with 1820 backtracks remaining -------------------- java.lang.Exception: TIMEOUT at psym.commandline.EntryPoint.process(EntryPoint.java:97) at psym.commandline.EntryPoint.run(EntryPoint.java:138) at psym.commandline.PSym.main(PSym.java:73) Here, PSym explores 140 schedules/iterations, checking 8043 distinct states, and achieving an estimated coverage of ~ 1.4 %. Check file output/coverage-clientserver.log for a detailed Coverage Report. Check file output/stats-clientserver.log for a detailed Statistics Report. Coverage At the end of a run, PSym reports a coverage metric as an estimated percentage of the execution tree that is explored during the run. Assuming a uniform probability for each scheduling/data choice, this metric reports the probability of a randomly-sampled schedule to be bug free. Continuous Feedback During the run, PSym prints useful metrics that summarizes the current status of the run. For example, for the ClientServer run above, PSym prints: Time Memory Coverage Iteration Remaining Depth States 00:00:10 0.2 GB 1.4246418994 % 140 1820 (100 % data) 1 8043 that summarizes: Label Description Time Elapsed runtime in hh:mm:ss format Memory Memory usage in gigabytes Coverage Estimated Coverage Iteration Iteration/schedule number Remaining Number of unexplored backtracks/choices remaining (as well as % of data choices) Depth Current depth of the exploration States Number of distinct states explored [Important] Is the coverage reported exactly measures the % of state-space covered? Sadly, No ! PSym's coverage metric is not a perfect state-space coverage metric. This metric gives more weightage to shorter schedules, or more precisely, schedules with fewer schedule/data choices at shallower search depths. Therefore, a PSym run can quickly reach a high estimated coverage (> 99 %) due to exploring shorter schedules first, after which gaining the remaining left-over percentage can become increasingly (and exponentially) difficult. Our recommendation is to target achieving coverage up to 11 nines, i.e., 99.999999999 % to be sufficiently confident of the absence of bug. Additionally, check PSym's Coverage Report ( output/coverage-*.log ) to understand the state-space covered during the run, as well as the number of distinct states explored. At the end of a run, PSym also prints a coverage report in output/coverage-*.log that tabulates, for each exploration step/depth, the number of schedule/data choices explored during the run, along with the number of choices remaining as unexplored backtracks. For example, coverage report corresponding to the previous ClientServer run can be found in output/coverage-clientserver.log Example Here is a snippet of the ClientServer coverage report: output/coverage-clientserver.log ----------------- Coverage Report:: ----------------- Covered choices: 8239 scheduling, 1962 data Remaining choices: 0 scheduling, 30292 data ------------------------------------- Depth Covered Remaining sch data sch data ------------------------------------- 0 100 1 100 2 100 134 5806 3 135 4 134 5 134 6 134 7 134 50 1162 8 134 77 2659 9 127 10 127 11 127 36 559 12 127 48 1045 13 124 36 1149 14 120 15 120 23 296 16 120 36 621 17 114 34 766 18 111 18 468 19 111 19 203 20 112 24 374 21 109 31 582 22 106 25 494 23 106 20 250 24 104 19 256 25 102 22 326 26 98 26 365 27 97 23 319 28 96 19 222 29 95 20 268 30 95 23 298 31 93 23 279 32 91 19 233 33 91 20 243 34 89 18 232 35 88 22 263 36 85 17 181 37 83 15 176 38 79 16 198 39 76 19 221 40 73 20 199 41 73 15 176 42 71 10 123 43 70 20 225 44 68 20 208 45 68 16 187 46 66 10 123 47 66 17 190 48 66 18 187 49 64 16 186 50 62 10 114 . . . Improving Coverage for ClientServer Looks like the ClientServer example is quite data heavy, since there are lots of unexplored data choices at different steps (check the rightmost column of output/coverage-clientserver.log ). A good idea is to reduce the amount of data non-determinism by reducing the number of choices in the choose(*) expressions, such as the number of data choices in setting the initial bank balances in expression choose(100) here . Remaining choices in Coverage Report Note that the coverage report can be incomplete, since it tabulates the remaining choices as of by the end of a run. Each remaining choice, say at a step N, when explored by PSym can discover many more choices at steps >= N+1. CLI Options Here is a list of frequently-used commandline options that can be passed to the .jar : CLI Option Description Default --method <string> Name of the test method to execute auto --time-limit <sec> Time limit in seconds (use 0 for no limit) 60 --memory-limit <MB> Memory limit in megabytes (use 0 for no limit) auto --iterations <int> Number of schedules/executions to explore (use 0 for no limit) 0 --max-steps <int> Max scheduling steps to be explored per schedule 1000 --seed <int> Random seed to use for the exploration 0 --verbose <int> Level of verbosity in the log output 0 --mode <string> Preconfigured exploration mode to use ( default , bmc , fuzz ) default For a complete list of options, pass the argument --help . Exploration Techniques PSym implements a collection of configurable techniques summarized as follows: Technique Description Search Strategy Configure the order in which search is performed: astar , random , dfs , learn Choice Selection Configure how a scheduling or data choice is selected: random , learn Never Repeat States Track distinct states to avoid state revisits Stateful Backtracking Backtrack directly without replay BMC Run PSym as a bounded model checker Preconfigured Modes For ease of usage, PSym provides a set of preconfigured exploration modes as follows: Mode Description default Explore single execution at a time Search Strategy = astar Choice Selection = random Never Repeat States = ON Stateful Backtracking = ON BMC = OFF bmc Explore all executions together symbolically as a bounded model checker Search Strategy = N/A Choice Selection = N/A Never Repeat States = OFF Stateful Backtracking = N/A BMC = ON fuzz Explore like a random fuzzer (but never repeat an execution!) Search Strategy = random Choice Selection = random Never Repeat States = OFF Stateful Backtracking = OFF BMC = OFF dfs Explore single executions at a time in depth-first manner Search Strategy = dfs Choice Selection = random Never Repeat States = ON Stateful Backtracking = ON BMC = OFF learn Explore single execution at a time with learning Search Strategy = learn Choice Selection = learn Never Repeat States = ON Stateful Backtracking = ON BMC = OFF Pass the CLI argument --mode <option> to set the exploration mode. You are now a pro ! Give PSym a try on your P model and shared your feedback with us.","title":"usingPSym"},{"location":"advanced/psym/usingPSym/#compiling-a-p-program-for-psym","text":"Simply pass the commandline argument -generate:PSym when running the P compiler pc . Alternative way: Set <Target> as PSym in *.pproj Set the <Target> field as PSym in the P project file ( *.pproj ) Example: <!-- P Project file for the Client Server example --> <Project> <ProjectName> ClientServer </ProjectName> <InputFiles> <PFile> ./PSrc/ </PFile> <PFile> ./PSpec/ </PFile> <PFile> ./PTst/ </PFile> </InputFiles> <OutputDir> ./PGenerated/ </OutputDir> <Target> PSym </Target> </Project> Recommendation We recommend using the P project file *.pproj along with passing -generate:PSym as commandline argument to the compiler to compile a P program for PSym. Commandline argument -generate:XXX takes priority over <Target>YYY</Target> in *.pproj file. Compiling the ClientServer project for PSym pc -proj:ClientServer.pproj -generate:PSym Expected Output $ pc -proj:ClientServer.pproj -generate:PSym ---------------------------------------- ==== Loading project file: ClientServer.pproj ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Server.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Client.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/AbstractBankServer.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/ClientServerModules.p ....... includes p file: P/Tutorial/1_ClientServer/PSpec/BankBalanceCorrect.p ....... includes p file: P/Tutorial/1_ClientServer/PTst/TestDriver.p ....... includes p file: P/Tutorial/1_ClientServer/PTst/Testscript.p ---------------------------------------- ---------------------------------------- Parsing ... Type checking ... Code generation ... Generated clientserver.java. ---------------------------------------- Compiling ClientServer... ClientServer -> target/ClientServer-jar-with-dependencies.jar Build succeeded. ----------------------------------------","title":"Compiling a P program for PSym"},{"location":"advanced/psym/usingPSym/#checking-a-p-program-with-psym","text":"Compiling the ClientServer program generates a ClientServer-jar-with-dependencies.jar . This .jar is the symbolically-instrumented intermediate representation of the P program in Java, along with a packaged PSym runtime. Running this .jar file executes PSym to systematically explore behaviors of the program for the specified test case. The .jar is present in the target/ folder, also printed in the compiler output: ClientServer -> target/ClientServer-jar-with-dependencies.jar You can get the list of test cases defined in the P program by running the generated .jar : java -jar target/ClientServer-jar-with-dependencies.jar Expected Output java -jar target/ClientServer-jar-with-dependencies.jar Picked up JAVA_TOOL_OPTIONS: -Dlog4j2.formatMsgNoLookups=true WARNING: sun.reflect.Reflection.getCallerClass is not supported. This will impact performance. Reflections took 100 ms to scan 1 urls, producing 38 keys and 168 values Loading:: /Volumes/workplace/psym/src/PSymTest/exp/Examples/Tutorial/1_ClientServer/target/ClientServer-jar-with-dependencies.jar Setting solver engine to BDD + Bdd Reflections took 63 ms to scan 1 urls, producing 38 keys and 168 values Provide /method or -m flag to qualify the test method name you wish to use. Possible options are:: tcSingleClient tcMultipleClients There are three test cases defined in the ClientServer P project, and you can specify which test case to run by using the -m or --method parameter along with, say, a --time-limit <seconds> parameter to specify a time limit for the run in seconds. By default, PSym explores as many schedules as it can within a time limit of 60 seconds. So to run the tcSingleClient test case for 10 seconds, we can use the following command: java -jar target/ClientServer-jar-with-dependencies.jar \\ -m tcSingleClient \\ --time-limit 10 Expected Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Picked up JAVA_TOOL_OPTIONS: -Dlog4j2.formatMsgNoLookups=true WARNING: sun.reflect.Reflection.getCallerClass is not supported. This will impact performance. Reflections took 93 ms to scan 1 urls, producing 38 keys and 172 values . Checking /Users/goelaman/work/ws/version/github/P/Tutorial/1_ClientServer/target/ClientServer-jar-with-dependencies.jar Reflections took 45 ms to scan 1 urls, producing 38 keys and 172 values ... Method tcSingleClient ... Project clientserver is using 'default' strategy (seed:0) -------------------- Time Memory Coverage Iteration Remaining Depth States 00:00:10 0.2 GB 1.4246418994 % 140 1820 (100 % data) 1 8043 -------------------- Estimated Coverage:: 1.4246418994 % Distinct States Explored:: 8043 -------------------- Explored 140 single executions Took 10 seconds and 0.2 GB Result: partially safe with 1820 backtracks remaining -------------------- java.lang.Exception: TIMEOUT at psym.commandline.EntryPoint.process(EntryPoint.java:97) at psym.commandline.EntryPoint.run(EntryPoint.java:138) at psym.commandline.PSym.main(PSym.java:73) Here, PSym explores 140 schedules/iterations, checking 8043 distinct states, and achieving an estimated coverage of ~ 1.4 %. Check file output/coverage-clientserver.log for a detailed Coverage Report. Check file output/stats-clientserver.log for a detailed Statistics Report.","title":"Checking a P program with PSym"},{"location":"advanced/psym/usingPSym/#coverage","text":"At the end of a run, PSym reports a coverage metric as an estimated percentage of the execution tree that is explored during the run. Assuming a uniform probability for each scheduling/data choice, this metric reports the probability of a randomly-sampled schedule to be bug free. Continuous Feedback During the run, PSym prints useful metrics that summarizes the current status of the run. For example, for the ClientServer run above, PSym prints: Time Memory Coverage Iteration Remaining Depth States 00:00:10 0.2 GB 1.4246418994 % 140 1820 (100 % data) 1 8043 that summarizes: Label Description Time Elapsed runtime in hh:mm:ss format Memory Memory usage in gigabytes Coverage Estimated Coverage Iteration Iteration/schedule number Remaining Number of unexplored backtracks/choices remaining (as well as % of data choices) Depth Current depth of the exploration States Number of distinct states explored [Important] Is the coverage reported exactly measures the % of state-space covered? Sadly, No ! PSym's coverage metric is not a perfect state-space coverage metric. This metric gives more weightage to shorter schedules, or more precisely, schedules with fewer schedule/data choices at shallower search depths. Therefore, a PSym run can quickly reach a high estimated coverage (> 99 %) due to exploring shorter schedules first, after which gaining the remaining left-over percentage can become increasingly (and exponentially) difficult. Our recommendation is to target achieving coverage up to 11 nines, i.e., 99.999999999 % to be sufficiently confident of the absence of bug. Additionally, check PSym's Coverage Report ( output/coverage-*.log ) to understand the state-space covered during the run, as well as the number of distinct states explored. At the end of a run, PSym also prints a coverage report in output/coverage-*.log that tabulates, for each exploration step/depth, the number of schedule/data choices explored during the run, along with the number of choices remaining as unexplored backtracks. For example, coverage report corresponding to the previous ClientServer run can be found in output/coverage-clientserver.log Example Here is a snippet of the ClientServer coverage report: output/coverage-clientserver.log ----------------- Coverage Report:: ----------------- Covered choices: 8239 scheduling, 1962 data Remaining choices: 0 scheduling, 30292 data ------------------------------------- Depth Covered Remaining sch data sch data ------------------------------------- 0 100 1 100 2 100 134 5806 3 135 4 134 5 134 6 134 7 134 50 1162 8 134 77 2659 9 127 10 127 11 127 36 559 12 127 48 1045 13 124 36 1149 14 120 15 120 23 296 16 120 36 621 17 114 34 766 18 111 18 468 19 111 19 203 20 112 24 374 21 109 31 582 22 106 25 494 23 106 20 250 24 104 19 256 25 102 22 326 26 98 26 365 27 97 23 319 28 96 19 222 29 95 20 268 30 95 23 298 31 93 23 279 32 91 19 233 33 91 20 243 34 89 18 232 35 88 22 263 36 85 17 181 37 83 15 176 38 79 16 198 39 76 19 221 40 73 20 199 41 73 15 176 42 71 10 123 43 70 20 225 44 68 20 208 45 68 16 187 46 66 10 123 47 66 17 190 48 66 18 187 49 64 16 186 50 62 10 114 . . . Improving Coverage for ClientServer Looks like the ClientServer example is quite data heavy, since there are lots of unexplored data choices at different steps (check the rightmost column of output/coverage-clientserver.log ). A good idea is to reduce the amount of data non-determinism by reducing the number of choices in the choose(*) expressions, such as the number of data choices in setting the initial bank balances in expression choose(100) here . Remaining choices in Coverage Report Note that the coverage report can be incomplete, since it tabulates the remaining choices as of by the end of a run. Each remaining choice, say at a step N, when explored by PSym can discover many more choices at steps >= N+1.","title":"Coverage"},{"location":"advanced/psym/usingPSym/#cli-options","text":"Here is a list of frequently-used commandline options that can be passed to the .jar : CLI Option Description Default --method <string> Name of the test method to execute auto --time-limit <sec> Time limit in seconds (use 0 for no limit) 60 --memory-limit <MB> Memory limit in megabytes (use 0 for no limit) auto --iterations <int> Number of schedules/executions to explore (use 0 for no limit) 0 --max-steps <int> Max scheduling steps to be explored per schedule 1000 --seed <int> Random seed to use for the exploration 0 --verbose <int> Level of verbosity in the log output 0 --mode <string> Preconfigured exploration mode to use ( default , bmc , fuzz ) default For a complete list of options, pass the argument --help . Exploration Techniques PSym implements a collection of configurable techniques summarized as follows: Technique Description Search Strategy Configure the order in which search is performed: astar , random , dfs , learn Choice Selection Configure how a scheduling or data choice is selected: random , learn Never Repeat States Track distinct states to avoid state revisits Stateful Backtracking Backtrack directly without replay BMC Run PSym as a bounded model checker Preconfigured Modes For ease of usage, PSym provides a set of preconfigured exploration modes as follows: Mode Description default Explore single execution at a time Search Strategy = astar Choice Selection = random Never Repeat States = ON Stateful Backtracking = ON BMC = OFF bmc Explore all executions together symbolically as a bounded model checker Search Strategy = N/A Choice Selection = N/A Never Repeat States = OFF Stateful Backtracking = N/A BMC = ON fuzz Explore like a random fuzzer (but never repeat an execution!) Search Strategy = random Choice Selection = random Never Repeat States = OFF Stateful Backtracking = OFF BMC = OFF dfs Explore single executions at a time in depth-first manner Search Strategy = dfs Choice Selection = random Never Repeat States = ON Stateful Backtracking = ON BMC = OFF learn Explore single execution at a time with learning Search Strategy = learn Choice Selection = learn Never Repeat States = ON Stateful Backtracking = ON BMC = OFF Pass the CLI argument --mode <option> to set the exploration mode. You are now a pro ! Give PSym a try on your P model and shared your feedback with us.","title":"CLI Options"},{"location":"advanced/psym/whatisPSym/","text":"PSym is a new checker for P models developed to complement the default P checker with the primary objective to avoid repetition during state-space exploration. PSym guarantees to never repeat an already-explored execution, and hence, can exhaustively explore all possible executions. PSym also has an inbuilt coverage tracker that reports estimated coverage to give measurable and continuous feedback (even when no bug is found during exploration). Recommendation Exhaustively exploring all possible executions is generally not possible for large models due to time/memory constraints. We recommend always trying PSym with easier tests first, such as ones with only a small number of replica machines and choose(*) expressions with fewer choices. P compiler has a dedicated backend for PSym, which compiles the P model into a symbolically-instrumented intermediate representation in Java, packed as a single .jar file. Executing the .jar file runs PSym runtime. Commandline arguments can be passed when running the .jar file to configure the exploration strategy. At the end of a run, PSym reports the result (safe / buggy / partially-safe), an error trace (if found a bug), along with a coverage and statistics report. graph LR Pmodel(P Model <br/> *.p) --> Pcompiler[P Compiler]--> IR(Symbolic IR in Java <br/> *.jar) --> Psym[PSym Runtime]; Psym[PSym Runtime] --> Result[Result <br/> Coverage <br/> Statistics]; style Pcompiler fill:#FFEFD5,stroke:#FFEFD5,stroke-width:2px style Psym fill:#FFEFD5,stroke:#FFEFD5,stroke-width:2px style Result fill:#CCFF66,stroke:#CCFF66,stroke-width:2px","title":"whatisPSym"},{"location":"getstarted/build/","text":"If you plan to contribute a Pull Request to P then you need to build the source code and run the tests. Please make sure that you have followed the steps in the installation guide to install P dependencies. Building the P project Clone the P repo and run the following build script. on MacOS or Linux cd Bld ./build.sh On Windows cd Bld ./build.ps1 Running the tests You can run the following command to build and run the test regressions for P Compiler. Make sure you are in the root directory of the clone repo that has the P.sln . dotnet build --configuration Release dotnet test --configuration Release","title":"Building from Source"},{"location":"getstarted/build/#building-the-p-project","text":"Clone the P repo and run the following build script. on MacOS or Linux cd Bld ./build.sh On Windows cd Bld ./build.ps1","title":"Building the P project"},{"location":"getstarted/build/#running-the-tests","text":"You can run the following command to build and run the test regressions for P Compiler. Make sure you are in the root directory of the clone repo that has the P.sln . dotnet build --configuration Release dotnet test --configuration Release","title":"Running the tests"},{"location":"getstarted/install/","text":"If you want to use older P version 1.x.x, please use the installation steps here P is built to be cross-platform and can be used on MacOS, Linux, and Windows. We provide a step-by-step guide for installing P along with the required dependencies. After each step, please use the troubleshooting check to ensure that each installation step succeeded. [Step 1] Install .Net Core SDK The P compiler is implemented in C# and hence the tool chain requires dotnet . P currently uses the specific version of .Net SDK 6.0 . MacOS Installing .Net SDK on MacOS using Homebrew ( details ) brew tap isen-ng/dotnet-sdk-versions brew install --cask dotnet-sdk6-0-400 Dont have Homebrew? Install manually using the installer for x64 or Arm64 . Ubuntu Installing .Net SDK on Ubuntu ( details ) wget https://packages.microsoft.com/config/ubuntu/22.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb rm packages-microsoft-prod.deb sudo apt update && sudo apt install -y dotnet-sdk-6.0 Amazon Linux Installing .Net SDK on Amazon Linux ( details ) sudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm sudo yum install -y dotnet-sdk-6.0 Windows Installing .Net SDK on Windows using the installer for x64 or Arm64 Troubleshoot: Confirm that dotnet is correctly installed on your machine. dotnet --list-sdks You must see an SDK with 6.0.* dotnet version installed. If you get dotnet command not found error, mostly likely, you need to add the path to dotnet in your PATH . Useful resources: For Ubuntu: fxr does not exist [Step 2] Install Java Runtime The P compiler also requires Java ( java version 11 or higher). MacOS Installing Java on MacOS using Homebrew ( details ) brew install java Dont have Homebrew? Directly use installer . Ubuntu Installing Java on Ubuntu ( details ) sudo apt install -y default-jre Amazon Linux Installing Java 11 on Amazon Linux (you can use any version of java >= 11) sudo yum install -y java-11-amazon-corretto Windows Installing Java on Windows ( details ) Troubleshoot: Confirm that java is correctly installed on your machine. java -version If you get java command not found error, mostly likely, you need to add the path to java in your PATH . [Step 3] Install P tool Finally, let's install the P tool as a dotnet tool using the following command: dotnet tool install --global P Troubleshoot: Confirm that p is correctly installed on your machine After installation, run which p and it should show: which p /Users/<user>/.dotnet/tools/p If not, add $HOME/.dotnet/tools to $PATH in your .bash_profile (or equivalent) and try again after restarting the shell. If you are getting the error that the p command is not found, it is most likely that $HOME/.dotnet/tools is not in your PATH . Updating P Compiler You can update the version of P compiler by running the following command: dotnet tool update --global P [Step 4] Recommended IDE (Optional) For developing P programs, we recommend using IntelliJ IDEA as we support basic P syntax highlighting for IntelliJ. There is also a plugin for the Vim editor , which IntelliJ will automatically use when Vim emulation is enabled. For debugging generated C# code, we recommend using Rider for Mac/Linux or Visual Studio 2019 for Windows. For debugging generated Java code, we recommend using IntelliJ IDEA Using P Great ! You are all set to compile and check your first P program !","title":"Installing P"},{"location":"getstarted/install/#step-1-install-net-core-sdk","text":"The P compiler is implemented in C# and hence the tool chain requires dotnet . P currently uses the specific version of .Net SDK 6.0 . MacOS Installing .Net SDK on MacOS using Homebrew ( details ) brew tap isen-ng/dotnet-sdk-versions brew install --cask dotnet-sdk6-0-400 Dont have Homebrew? Install manually using the installer for x64 or Arm64 . Ubuntu Installing .Net SDK on Ubuntu ( details ) wget https://packages.microsoft.com/config/ubuntu/22.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb rm packages-microsoft-prod.deb sudo apt update && sudo apt install -y dotnet-sdk-6.0 Amazon Linux Installing .Net SDK on Amazon Linux ( details ) sudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm sudo yum install -y dotnet-sdk-6.0 Windows Installing .Net SDK on Windows using the installer for x64 or Arm64 Troubleshoot: Confirm that dotnet is correctly installed on your machine. dotnet --list-sdks You must see an SDK with 6.0.* dotnet version installed. If you get dotnet command not found error, mostly likely, you need to add the path to dotnet in your PATH . Useful resources: For Ubuntu: fxr does not exist","title":"[Step 1] Install .Net Core SDK"},{"location":"getstarted/install/#step-2-install-java-runtime","text":"The P compiler also requires Java ( java version 11 or higher). MacOS Installing Java on MacOS using Homebrew ( details ) brew install java Dont have Homebrew? Directly use installer . Ubuntu Installing Java on Ubuntu ( details ) sudo apt install -y default-jre Amazon Linux Installing Java 11 on Amazon Linux (you can use any version of java >= 11) sudo yum install -y java-11-amazon-corretto Windows Installing Java on Windows ( details ) Troubleshoot: Confirm that java is correctly installed on your machine. java -version If you get java command not found error, mostly likely, you need to add the path to java in your PATH .","title":"[Step 2] Install Java Runtime"},{"location":"getstarted/install/#step-3-install-p-tool","text":"Finally, let's install the P tool as a dotnet tool using the following command: dotnet tool install --global P Troubleshoot: Confirm that p is correctly installed on your machine After installation, run which p and it should show: which p /Users/<user>/.dotnet/tools/p If not, add $HOME/.dotnet/tools to $PATH in your .bash_profile (or equivalent) and try again after restarting the shell. If you are getting the error that the p command is not found, it is most likely that $HOME/.dotnet/tools is not in your PATH . Updating P Compiler You can update the version of P compiler by running the following command: dotnet tool update --global P","title":"[Step 3] Install P tool"},{"location":"getstarted/install/#step-4-recommended-ide-optional","text":"For developing P programs, we recommend using IntelliJ IDEA as we support basic P syntax highlighting for IntelliJ. There is also a plugin for the Vim editor , which IntelliJ will automatically use when Vim emulation is enabled. For debugging generated C# code, we recommend using Rider for Mac/Linux or Visual Studio 2019 for Windows. For debugging generated Java code, we recommend using IntelliJ IDEA","title":"[Step 4] Recommended IDE (Optional)"},{"location":"getstarted/install/#using-p","text":"Great ! You are all set to compile and check your first P program !","title":"Using P"},{"location":"getstarted/syntaxhighlight/","text":"Syntax Highlighting for P in IntelliJ To enable basic syntax highlighting for P ( *.p files) in IntelliJ, download the zip file here and import it as settings into IntelliJ. Tip Details about how to import settings into IntelliJ from a zip archive ( check here ) Syntax Highlighting for P in Sublime We used to support syntax highlighting for Sublime editor but is no longer maintained and hence may not support latest P language features. ( Sublime Plugin for P (.p) files ). Troubleshooting If you face any issues getting the syntax highlighting to work, please create an issue on the P Github repository.","title":"Syntax Highlighting for P"},{"location":"getstarted/syntaxhighlight/#syntax-highlighting-for-p-in-intellij","text":"To enable basic syntax highlighting for P ( *.p files) in IntelliJ, download the zip file here and import it as settings into IntelliJ. Tip Details about how to import settings into IntelliJ from a zip archive ( check here )","title":"Syntax Highlighting for P in IntelliJ"},{"location":"getstarted/syntaxhighlight/#syntax-highlighting-for-p-in-sublime","text":"We used to support syntax highlighting for Sublime editor but is no longer maintained and hence may not support latest P language features. ( Sublime Plugin for P (.p) files ).","title":"Syntax Highlighting for P in Sublime"},{"location":"getstarted/syntaxhighlight/#troubleshooting","text":"If you face any issues getting the syntax highlighting to work, please create an issue on the P Github repository.","title":"Troubleshooting"},{"location":"getstarted/usingP/","text":"If you are using an older P version 1.x.x, please find the usage guide here Before moving forward, we assume that you have successfully installed P and the Syntax highlighting plugin . We introduce the P language syntax and semantics in details in the Tutorials and Language Manual . In this section, we provide an overview of the steps involved in compiling and checking a P program using the client server example in Tutorials. Get the Client Server Example Locally We will use the ClientServer example from Tutorial folder in P repository to describe the process of compiling and checking a P program. Please clone the P repo and navigate to the ClientServer example in Tutorial. Clone P Repo locally: git clone https://github.com/p-org/P.git Navigate to the ClientServer examples folder: cd <P cloned folder>/Tutorial/1_ClientServer Compiling a P program There are two ways of compiling a P program: Using a P project file ( *.pproj ) to provide all the required inputs to the compiler or Passing all the P files ( *.p ) along with other options as commandline arguments to the compiler. Recommendation We recommend using the P project files to compile a P program. P Compiler commandline options The P compiler provides the following commandline options: ----------------------------------------------- usage: p compile [--help] [--pproj string] [--pfiles string] [--projname string] [--outdir string] The P compiler compiles all the P files in the project together and generates the executable that can be checked for correctness by the P checker. Compiling using `.pproj` file: ------------------------------ -pp, --pproj string : P project file to compile (*.pproj). If this option is not passed, the compiler searches for a *.pproj in the current folder Compiling P files directly through commandline: ----------------------------------------------- -pf, --pfiles string : List of P files to compile -pn, --projname string : Project name for the compiled output -o, --outdir string : Dump output to directory (absolute or relative path) Optional Arguments: ------------------- -h, --help Show this help menu ----------------------------------------------- Compile using the P Project Compiling the ClientServer project using the P Project file: p compile Expected Output $ p compile .. Searching for a P project file *.pproj locally in the current folder .. Found P project file: P/Tutorial/1_ClientServer/ClientServer.pproj ---------------------------------------- ==== Loading project file: P/Tutorial/1_ClientServer/ClientServer.pproj ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Server.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Client.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/AbstractBankServer.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/ClientServerModules.p ....... includes p file: P/Tutorial/1_ClientServer/PSpec/BankBalanceCorrect.p ....... includes p file: P/Tutorial/1_ClientServer/PTst/TestDriver.p ....... includes p file: P/Tutorial/1_ClientServer/PTst/Testscript.p ---------------------------------------- ---------------------------------------- Parsing ... Type checking ... Code generation ... Generated ClientServer.cs. ---------------------------------------- Compiling ClientServer... MSBuild version 17.3.1+2badb37d1 for .NET Determining projects to restore... Restored P/Tutorial/1_ClientServer/PGenerated/CSharp/ClientServer.csproj (in 365 ms). ClientServer -> P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll Build succeeded. 0 Warning(s) 0 Error(s) Time Elapsed 00:00:02.34 ---------------------------------------- [PTool]: Thanks for using P! p compile command searches for the *.pproj file in the current directory. If you are running p compile from outside the P project directory, use the -pp <path to *.pproj> option instead. P Project File Details The P compiler does not support advanced project management features like separate compilation and dependency analysis ( coming soon ). The current project file interface is a simple mechanism to provide all the required inputs to the compiler in an XML format ( ClientServer.pproj ). <!-- P Project file for the Client Server example --> <Project> <ProjectName> ClientServer </ProjectName> <InputFiles> <PFile> ./PSrc/ </PFile> <PFile> ./PSpec/ </PFile> <PFile> ./PTst/ </PFile> </InputFiles> <OutputDir> ./PGenerated/ </OutputDir> </Project> The <InputFiles> block provides all the P files that must be compiled together for this project. In <PFile> one can either specify the path to a P file or to a folder and the P compiler includes all the *.p files in the folder during compilation. The <ProjectName> block provides the name for the project which is used as the output file name for the generated code. The <OutputDir> block provides the output directory for the generated code. Finally, the <IncludeProject> block provides a path to other P projects that must be included as dependencies during compilation. The P compiler simply recursively copies all the P files in the dependency projects (transitively including all P files in dependent projects) and compiles them together. This feature provides a way to split the P models for a large system into sub projects that can share models. Compile P files directly Compiling the ClientServer program by passing all the required inputs as commandline arguments: p compile -pf PSpec/*.p PSrc/*.p PTst/*.p -pn ClientServer -o PGenerated Expected Output $ p compile -pf PSpec/*.p PSrc/*.p PTst/*.p -pn ClientServer -o PGenerated ---------------------------------------- Parsing ... Type checking ... Code generation ... Generated ClientServer.cs. ---------------------------------------- Compiling ClientServer... MSBuild version 17.3.1+2badb37d1 for .NET Determining projects to restore... All projects are up-to-date for restore. ClientServer -> P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll Build succeeded. 0 Warning(s) 0 Error(s) Time Elapsed 00:00:01.87 ---------------------------------------- [PTool]: Thanks for using P! Checking a P program Compiling the ClientServer program generates a ClientServer.dll , this dll is the C# representation of the P program. The P Checker takes as input this dll and systematically explores behaviors of the program for the specified test case. The path to the dll is present in the generated compilation output, check for line: ClientServer -> <Path>/ClientServer.dll You can get the list of test cases defined in the P program by running the P Checker: p check Expected Output $ p check .. Searching for a P compiled file locally in the current folder .. Found a P compiled file: P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll .. Checking P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll Error: We found '3' test cases. Please provide a more precise name of the test case you wish to check using (--testcase | -tc). Possible options are: tcSingleClient tcMultipleClients tcSingleClientAbstractServer [PTool]: Thanks for using P! p check command searches for the *.dll file in the current directory. If you are running p check from outside the directory where *.dll is compiled to, run p check <path to *.dll> instead. There are three test cases defined in the ClientServer P project, and you can specify which test case to run by using the -tc or --testcase parameter along with the -i parameter to specify how many different schedules to explore when running this test case (by default the checker explores a single schedule). For complex systems, running for 100,000 schedules typically finds most of the easy to find bugs before running the checker on a distributed cluster to explore billions of schedules and rule out deep bugs in the system. So to run the tcSingleClient test case for 100 schedules, we can use the following command: p check -tc tcSingleClient -i 100 Expected Output $ p check -tc tcSingleClient -i 100 .. Searching for a P compiled file locally in the current folder .. Found a P compiled file: P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll .. Checking P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll .. Test case :: tcSingleClient ... Checker is using 'random' strategy (seed:2766677439). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ..... Iteration #9 ..... Iteration #10 ..... Iteration #20 ..... Iteration #30 ..... Iteration #40 ..... Iteration #50 ..... Iteration #60 ..... Iteration #70 ..... Iteration #80 ..... Iteration #90 ..... Iteration #100 ... Emitting coverage reports: ..... Writing PCheckerOutput/BugFinding/ClientServer.dgml ..... Writing PCheckerOutput/BugFinding/ClientServer.coverage.txt ..... Writing PCheckerOutput/BugFinding/ClientServer.sci ... Checking statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 100 schedules: 100 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 11 (min), 167 (avg), 691 (max). ... Elapsed 1.2432111 sec. . Done [PTool]: Thanks for using P! There is a known bug in the ClientServer example (explained in the Tutorials) which is caught by the tcSingleClientAbstractServer test case. Run command: p check -tc tcSingleClientAbstractServer -i 100 Expected Output $ p check -tc tcSingleClientAbstractServer -i 100 .. Searching for a P compiled file locally in the current folder .. Found a P compiled file: P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll .. Checking P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll .. Test case :: tcSingleClientAbstractServer ... Checker is using 'random' strategy (seed:1823819121). ..... Iteration #1 Checker found a bug. ... Emitting traces: ..... Writing PCheckerOutput/BugFinding/ClientServer_0_0.txt ..... Writing PCheckerOutput/BugFinding/ClientServer_0_0.dgml ..... Writing PCheckerOutput/BugFinding/ClientServer_0_0.schedule ... Elapsed 0.2219742 sec. ... Emitting coverage reports: ..... Writing PCheckerOutput/BugFinding/ClientServer.dgml ..... Writing PCheckerOutput/BugFinding/ClientServer.coverage.txt ..... Writing PCheckerOutput/BugFinding/ClientServer.sci ... Checking statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 1 schedule: 1 fair and 0 unfair. ..... Found 100.00% buggy schedules. ..... Number of scheduling points in fair terminating schedules: 117 (min), 117 (avg), 117 (max). ... Elapsed 0.3952627 sec. . Done [PTool]: Thanks for using P! The P checker on finding a bug generates two artifacts (highlighted in the expected output above): A textual trace file (e.g., ClientServer_0_0.txt ) that has the readable error trace representing the sequence of steps from the initial state to the error state; A schedule file (e.g., ClientServer_0_0.schedule ) that can be used to replay the error trace and single step through the P program with the generated error trace for debugging (more details about debugging P error traces: here ).","title":"Using P Compiler and Checker"},{"location":"getstarted/usingP/#compiling-a-p-program","text":"There are two ways of compiling a P program: Using a P project file ( *.pproj ) to provide all the required inputs to the compiler or Passing all the P files ( *.p ) along with other options as commandline arguments to the compiler. Recommendation We recommend using the P project files to compile a P program. P Compiler commandline options The P compiler provides the following commandline options: ----------------------------------------------- usage: p compile [--help] [--pproj string] [--pfiles string] [--projname string] [--outdir string] The P compiler compiles all the P files in the project together and generates the executable that can be checked for correctness by the P checker. Compiling using `.pproj` file: ------------------------------ -pp, --pproj string : P project file to compile (*.pproj). If this option is not passed, the compiler searches for a *.pproj in the current folder Compiling P files directly through commandline: ----------------------------------------------- -pf, --pfiles string : List of P files to compile -pn, --projname string : Project name for the compiled output -o, --outdir string : Dump output to directory (absolute or relative path) Optional Arguments: ------------------- -h, --help Show this help menu ----------------------------------------------- Compile using the P Project Compiling the ClientServer project using the P Project file: p compile Expected Output $ p compile .. Searching for a P project file *.pproj locally in the current folder .. Found P project file: P/Tutorial/1_ClientServer/ClientServer.pproj ---------------------------------------- ==== Loading project file: P/Tutorial/1_ClientServer/ClientServer.pproj ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Server.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Client.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/AbstractBankServer.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/ClientServerModules.p ....... includes p file: P/Tutorial/1_ClientServer/PSpec/BankBalanceCorrect.p ....... includes p file: P/Tutorial/1_ClientServer/PTst/TestDriver.p ....... includes p file: P/Tutorial/1_ClientServer/PTst/Testscript.p ---------------------------------------- ---------------------------------------- Parsing ... Type checking ... Code generation ... Generated ClientServer.cs. ---------------------------------------- Compiling ClientServer... MSBuild version 17.3.1+2badb37d1 for .NET Determining projects to restore... Restored P/Tutorial/1_ClientServer/PGenerated/CSharp/ClientServer.csproj (in 365 ms). ClientServer -> P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll Build succeeded. 0 Warning(s) 0 Error(s) Time Elapsed 00:00:02.34 ---------------------------------------- [PTool]: Thanks for using P! p compile command searches for the *.pproj file in the current directory. If you are running p compile from outside the P project directory, use the -pp <path to *.pproj> option instead. P Project File Details The P compiler does not support advanced project management features like separate compilation and dependency analysis ( coming soon ). The current project file interface is a simple mechanism to provide all the required inputs to the compiler in an XML format ( ClientServer.pproj ). <!-- P Project file for the Client Server example --> <Project> <ProjectName> ClientServer </ProjectName> <InputFiles> <PFile> ./PSrc/ </PFile> <PFile> ./PSpec/ </PFile> <PFile> ./PTst/ </PFile> </InputFiles> <OutputDir> ./PGenerated/ </OutputDir> </Project> The <InputFiles> block provides all the P files that must be compiled together for this project. In <PFile> one can either specify the path to a P file or to a folder and the P compiler includes all the *.p files in the folder during compilation. The <ProjectName> block provides the name for the project which is used as the output file name for the generated code. The <OutputDir> block provides the output directory for the generated code. Finally, the <IncludeProject> block provides a path to other P projects that must be included as dependencies during compilation. The P compiler simply recursively copies all the P files in the dependency projects (transitively including all P files in dependent projects) and compiles them together. This feature provides a way to split the P models for a large system into sub projects that can share models. Compile P files directly Compiling the ClientServer program by passing all the required inputs as commandline arguments: p compile -pf PSpec/*.p PSrc/*.p PTst/*.p -pn ClientServer -o PGenerated Expected Output $ p compile -pf PSpec/*.p PSrc/*.p PTst/*.p -pn ClientServer -o PGenerated ---------------------------------------- Parsing ... Type checking ... Code generation ... Generated ClientServer.cs. ---------------------------------------- Compiling ClientServer... MSBuild version 17.3.1+2badb37d1 for .NET Determining projects to restore... All projects are up-to-date for restore. ClientServer -> P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll Build succeeded. 0 Warning(s) 0 Error(s) Time Elapsed 00:00:01.87 ---------------------------------------- [PTool]: Thanks for using P!","title":"Compiling a P program"},{"location":"getstarted/usingP/#checking-a-p-program","text":"Compiling the ClientServer program generates a ClientServer.dll , this dll is the C# representation of the P program. The P Checker takes as input this dll and systematically explores behaviors of the program for the specified test case. The path to the dll is present in the generated compilation output, check for line: ClientServer -> <Path>/ClientServer.dll You can get the list of test cases defined in the P program by running the P Checker: p check Expected Output $ p check .. Searching for a P compiled file locally in the current folder .. Found a P compiled file: P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll .. Checking P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll Error: We found '3' test cases. Please provide a more precise name of the test case you wish to check using (--testcase | -tc). Possible options are: tcSingleClient tcMultipleClients tcSingleClientAbstractServer [PTool]: Thanks for using P! p check command searches for the *.dll file in the current directory. If you are running p check from outside the directory where *.dll is compiled to, run p check <path to *.dll> instead. There are three test cases defined in the ClientServer P project, and you can specify which test case to run by using the -tc or --testcase parameter along with the -i parameter to specify how many different schedules to explore when running this test case (by default the checker explores a single schedule). For complex systems, running for 100,000 schedules typically finds most of the easy to find bugs before running the checker on a distributed cluster to explore billions of schedules and rule out deep bugs in the system. So to run the tcSingleClient test case for 100 schedules, we can use the following command: p check -tc tcSingleClient -i 100 Expected Output $ p check -tc tcSingleClient -i 100 .. Searching for a P compiled file locally in the current folder .. Found a P compiled file: P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll .. Checking P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll .. Test case :: tcSingleClient ... Checker is using 'random' strategy (seed:2766677439). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ..... Iteration #9 ..... Iteration #10 ..... Iteration #20 ..... Iteration #30 ..... Iteration #40 ..... Iteration #50 ..... Iteration #60 ..... Iteration #70 ..... Iteration #80 ..... Iteration #90 ..... Iteration #100 ... Emitting coverage reports: ..... Writing PCheckerOutput/BugFinding/ClientServer.dgml ..... Writing PCheckerOutput/BugFinding/ClientServer.coverage.txt ..... Writing PCheckerOutput/BugFinding/ClientServer.sci ... Checking statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 100 schedules: 100 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 11 (min), 167 (avg), 691 (max). ... Elapsed 1.2432111 sec. . Done [PTool]: Thanks for using P! There is a known bug in the ClientServer example (explained in the Tutorials) which is caught by the tcSingleClientAbstractServer test case. Run command: p check -tc tcSingleClientAbstractServer -i 100 Expected Output $ p check -tc tcSingleClientAbstractServer -i 100 .. Searching for a P compiled file locally in the current folder .. Found a P compiled file: P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll .. Checking P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll .. Test case :: tcSingleClientAbstractServer ... Checker is using 'random' strategy (seed:1823819121). ..... Iteration #1 Checker found a bug. ... Emitting traces: ..... Writing PCheckerOutput/BugFinding/ClientServer_0_0.txt ..... Writing PCheckerOutput/BugFinding/ClientServer_0_0.dgml ..... Writing PCheckerOutput/BugFinding/ClientServer_0_0.schedule ... Elapsed 0.2219742 sec. ... Emitting coverage reports: ..... Writing PCheckerOutput/BugFinding/ClientServer.dgml ..... Writing PCheckerOutput/BugFinding/ClientServer.coverage.txt ..... Writing PCheckerOutput/BugFinding/ClientServer.sci ... Checking statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 1 schedule: 1 fair and 0 unfair. ..... Found 100.00% buggy schedules. ..... Number of scheduling points in fair terminating schedules: 117 (min), 117 (avg), 117 (max). ... Elapsed 0.3952627 sec. . Done [PTool]: Thanks for using P! The P checker on finding a bug generates two artifacts (highlighted in the expected output above): A textual trace file (e.g., ClientServer_0_0.txt ) that has the readable error trace representing the sequence of steps from the initial state to the error state; A schedule file (e.g., ClientServer_0_0.schedule ) that can be used to replay the error trace and single step through the P program with the generated error trace for debugging (more details about debugging P error traces: here ).","title":"Checking a P program"},{"location":"manual/datatypes/","text":"P Supports the following data types: P Types Description Primitive int , bool , float , string , enum , machine , and event . Record tuple and named tuple Collection map , seq , and set Foreign These are types that are not defined in P but in an external language (e.g., C# or Java) and can be used in the P program. User Defined These are user defined types that are constructed using any of the P types listed above Universal Supertypes any and data P Types Grammar Data types in P: type : | bool # PrimitiveType | int # PrimitiveType | float # PrimitiveType | string # PrimitiveType | event # PrimitiveType | machine # PrimitiveType | (type (, type)*) # TupleType | (iden: type (, iden: type)*) # NamedTupleType | seq[type] # SeqType | set[type] # SetType | map[type, type] # MapType | data # UniversalType | any # UniversalType | iden # UserDefinedType ; Declaring user defined types and foreign types: typeDecl : | type iden ; # ForeignTypeDeclaration | type iden = type ; # UserDefinedTypeDeclaration ; Declaring enum types: enumTypeDecl : | enum iden { enumElemList } | enum iden { numberedEnumElemList } ; enumElemList : enumElem (, enumElem)* ; enumElem : iden ; numberedEnumElemList : numberedEnumElem (, numberedEnumElem)* ; numberedEnumElem : iden = IntLiteral ; Operations on P data types Details for the operations that can be performed on P datatypes are described in the expressions and statements . Primitive P supports the common primitive datatypes like int , bool , float , and string . Two additional primitive data types that are specific to the P language are event and machine . event type represents the set of all P events. Similarly, machine type represents the set of all machine references. Primitive Data types ... event eRequest : bool ; ... // some function body in the P program { var i : int ; var j : float ; var k : string ; var l : bool ; var ev : event ; var client : machine ; ev = eRequest ; client = new Client (); i = 10 ; j = 10.0 ; k = \"Failure!!\" ; l = ( i == ( j to int )); assert l , k ; send client , ev , l ; } Enum P supports enums, enum values in P are considered as global constants and must have unique name. Enums by default are given integer values starting from 0 (if no values are assigned to the elements). Enums in P can be coerced to int . Please refer to the grammar above for the syntax for declaring enums. Enum Declaration enum tResponseStatus { ERROR, SUCCESS, TIMEOUT } // usage of enums var status: tResponseStatus; status = ERROR; // you can coerce an enum to int assert (ERROR to int) == 0; Enum Declaration with Values enum tResponseStatus { ERROR = 500, SUCCESS = 200, TIMEOUT = 400; } // usage of enums var status: tResponseStatus; status = ERROR; // you can coerce an enum to int assert (ERROR to int) == 500; Record P supports two types of records: tuples and named tuples. The fields of a tuple can be accessed by using the . operation followed by the field index. // tuple with three fields var tupleEx: (int, bool, int); // constructing a value of tuple type. tupleEx = (20, false, 21); // accessing the first and third element of the tupleEx tupleEx.0 = tupleEx.0 + tupleEx.2; Named tuples are similar to tuples with each field having an associated name. The fields of a named tuple can be accessed by using the . operation followed by the field name. // named tuple with three fields var namedTupleEx: (x1: int, x2: bool, x3: int); // constructing a value of named tuple type. namedTupleEx = (x1 = 20, x2 = false, x3 = 21); // accessing the first and third element of the namedTupleEx namedTupleEx.x1 = namedTupleEx.x1 + namedTupleEx.x3; Note Tuple and Named tuple types are disjoint, i.e., a tuple of type (int, bool, int) cannot be assigned to a variable of tuple (x1: int, x2: bool, x3: int) though the elements of the tuple have same types (and vice versa). And similarly, a named tuple of type (x1: int, x2: bool, x3: int) cannot be assigned to a variable of tuple (y1: int, y2: bool, y3: int) they are two distinct types. Collection P supports three collection types: map, sequence (lists), and set. The operations to mutate the collection types like insert, update, and remove elements are described in the statements section. One can use the while loop to iterate over these collection types. Other operations like sizeof , in (to check containment), choose (pick a value nondeterministically), keys , and values on these collection types are defined in the expressions section. Syntax : map[K, V] represents a map type with keys of type K and values of type V . seq[T] represents a sequence type with elements of type T . set[T] represents a set type with elements of type T . Foreign P allows programmers to define (or implement) types in the external languages. We refer to these types as foreign types, they are declared in P but are implemented in an external language. They can be used inside P programs just like any other types. Syntax: : type tName; tName is the name of the foreign type. Note that foreign types are disjoint from all other types in P. They are subtype of the any type. Details about how to define/implement foreign types in P is described here . User Defined P supports assigning names to type i.e., creating typedef . Note that these typedefs are simply assigning names to P types and does not effect the sub-typing relation. Syntax: : type iden = type ; User Defined Type Declaration // defining a type tLookUpRequest type tLookUpRequest = ( client : machine , requestId : int , key : string ); // defining a type tLookUpRequestX type tLookUpRequestX = ( client : machine , requestId : int , key : string ); The programmers can use type tLookUpRequest as a short hand for referring to the type (client: machine, requestId: int, key: string) Note that the types tLookUpRequest and tLookUpRequestX are same, the compiler does not distinguish between the two types. Universal Supertypes P supports two universal supertypes ( any and data ), type that are supertypes of all types in the language. any type in P is the supertype of all types. Also, note that in P, seq[any] is a super type of seq[int] and similarly for other collection types. data type in P is the supertype of all types in P that do not have a machine type embedded in it. This type is mainly used to represent values in P that do not have a machine reference embedded in them i.e., the value is purely \"data\" and has no machine \"references\" in it. For example, data is a supertype of (key: string, value: int) but not (key: string, client: machine) . Default values for P data types The default feature in P (checkout details in expressions ) can be used to obtain the default value of any P type. P variables on declaration are automatically initialized to their default values. default values of P types P variables on declaration are automatically initialized to their default values. For example: var s : set[int]; // by default a set type is initialized to an empty set assert sizeof(s) == 0; s += (100); assert sizeof(s) == 1; // reset the variable to an empty set s = default(set[int]); Similarly, type tRequest = (client: machine, requestId: int); type tResponse = (values: map[int, int]); ... // initializes x to (client = null, requestId = 0); x = default(tRequest); // initializes y to (values = {}), empty map. y = default(tResponse); assert x.client == default(machine); assert sizeof(y.values) == 0; P Types Default Value int 0 float 0.0 bool false string \"\" event null machine null enum Element of the enum with lowest (int) value Record (tuple or named tuple) Each field in the record type is initialized to its default value. Collection (set, seq, and map) Empty collection Foreign null any and data null","title":"P DataTypes"},{"location":"manual/datatypes/#primitive","text":"P supports the common primitive datatypes like int , bool , float , and string . Two additional primitive data types that are specific to the P language are event and machine . event type represents the set of all P events. Similarly, machine type represents the set of all machine references. Primitive Data types ... event eRequest : bool ; ... // some function body in the P program { var i : int ; var j : float ; var k : string ; var l : bool ; var ev : event ; var client : machine ; ev = eRequest ; client = new Client (); i = 10 ; j = 10.0 ; k = \"Failure!!\" ; l = ( i == ( j to int )); assert l , k ; send client , ev , l ; }","title":"Primitive"},{"location":"manual/datatypes/#enum","text":"P supports enums, enum values in P are considered as global constants and must have unique name. Enums by default are given integer values starting from 0 (if no values are assigned to the elements). Enums in P can be coerced to int . Please refer to the grammar above for the syntax for declaring enums. Enum Declaration enum tResponseStatus { ERROR, SUCCESS, TIMEOUT } // usage of enums var status: tResponseStatus; status = ERROR; // you can coerce an enum to int assert (ERROR to int) == 0; Enum Declaration with Values enum tResponseStatus { ERROR = 500, SUCCESS = 200, TIMEOUT = 400; } // usage of enums var status: tResponseStatus; status = ERROR; // you can coerce an enum to int assert (ERROR to int) == 500;","title":"Enum"},{"location":"manual/datatypes/#record","text":"P supports two types of records: tuples and named tuples. The fields of a tuple can be accessed by using the . operation followed by the field index. // tuple with three fields var tupleEx: (int, bool, int); // constructing a value of tuple type. tupleEx = (20, false, 21); // accessing the first and third element of the tupleEx tupleEx.0 = tupleEx.0 + tupleEx.2; Named tuples are similar to tuples with each field having an associated name. The fields of a named tuple can be accessed by using the . operation followed by the field name. // named tuple with three fields var namedTupleEx: (x1: int, x2: bool, x3: int); // constructing a value of named tuple type. namedTupleEx = (x1 = 20, x2 = false, x3 = 21); // accessing the first and third element of the namedTupleEx namedTupleEx.x1 = namedTupleEx.x1 + namedTupleEx.x3; Note Tuple and Named tuple types are disjoint, i.e., a tuple of type (int, bool, int) cannot be assigned to a variable of tuple (x1: int, x2: bool, x3: int) though the elements of the tuple have same types (and vice versa). And similarly, a named tuple of type (x1: int, x2: bool, x3: int) cannot be assigned to a variable of tuple (y1: int, y2: bool, y3: int) they are two distinct types.","title":"Record"},{"location":"manual/datatypes/#collection","text":"P supports three collection types: map, sequence (lists), and set. The operations to mutate the collection types like insert, update, and remove elements are described in the statements section. One can use the while loop to iterate over these collection types. Other operations like sizeof , in (to check containment), choose (pick a value nondeterministically), keys , and values on these collection types are defined in the expressions section. Syntax : map[K, V] represents a map type with keys of type K and values of type V . seq[T] represents a sequence type with elements of type T . set[T] represents a set type with elements of type T .","title":"Collection"},{"location":"manual/datatypes/#foreign","text":"P allows programmers to define (or implement) types in the external languages. We refer to these types as foreign types, they are declared in P but are implemented in an external language. They can be used inside P programs just like any other types. Syntax: : type tName; tName is the name of the foreign type. Note that foreign types are disjoint from all other types in P. They are subtype of the any type. Details about how to define/implement foreign types in P is described here .","title":"Foreign"},{"location":"manual/datatypes/#user-defined","text":"P supports assigning names to type i.e., creating typedef . Note that these typedefs are simply assigning names to P types and does not effect the sub-typing relation. Syntax: : type iden = type ; User Defined Type Declaration // defining a type tLookUpRequest type tLookUpRequest = ( client : machine , requestId : int , key : string ); // defining a type tLookUpRequestX type tLookUpRequestX = ( client : machine , requestId : int , key : string ); The programmers can use type tLookUpRequest as a short hand for referring to the type (client: machine, requestId: int, key: string) Note that the types tLookUpRequest and tLookUpRequestX are same, the compiler does not distinguish between the two types.","title":"User Defined"},{"location":"manual/datatypes/#universal-supertypes","text":"P supports two universal supertypes ( any and data ), type that are supertypes of all types in the language. any type in P is the supertype of all types. Also, note that in P, seq[any] is a super type of seq[int] and similarly for other collection types. data type in P is the supertype of all types in P that do not have a machine type embedded in it. This type is mainly used to represent values in P that do not have a machine reference embedded in them i.e., the value is purely \"data\" and has no machine \"references\" in it. For example, data is a supertype of (key: string, value: int) but not (key: string, client: machine) .","title":"Universal Supertypes"},{"location":"manual/datatypes/#default-values-for-p-data-types","text":"The default feature in P (checkout details in expressions ) can be used to obtain the default value of any P type. P variables on declaration are automatically initialized to their default values. default values of P types P variables on declaration are automatically initialized to their default values. For example: var s : set[int]; // by default a set type is initialized to an empty set assert sizeof(s) == 0; s += (100); assert sizeof(s) == 1; // reset the variable to an empty set s = default(set[int]); Similarly, type tRequest = (client: machine, requestId: int); type tResponse = (values: map[int, int]); ... // initializes x to (client = null, requestId = 0); x = default(tRequest); // initializes y to (values = {}), empty map. y = default(tResponse); assert x.client == default(machine); assert sizeof(y.values) == 0; P Types Default Value int 0 float 0.0 bool false string \"\" event null machine null enum Element of the enum with lowest (int) value Record (tuple or named tuple) Each field in the record type is initialized to its default value. Collection (set, seq, and map) Empty collection Foreign null any and data null","title":"Default values for P data types"},{"location":"manual/events/","text":"A P program is a collection of state machines communicating with each other by exchanging events . An event in P has two parts: an event name and a payload value (optional) that can be sent along with the event. P Event Declaration Grammar eventDecl : | event iden (: type)?; # P Event Declaration iden is the name of the event and type is any P data type ( described here ). Syntax: event eName; or event eName : payloadType; eName is the name of the P event and payloadType is the type of payload values that can be sent along with this event. Event Declarations // declarations of events with no payloads event ePing ; event ePong ; // declaration of events that have payloads type tRequest = ( client : Client , key : string , value : int , requestId : int ); // eRequest event with payload of type tRequest event eRequest : tRequest ; // eResponse event that can have a payload of type (requestId: int, status: bool) event eResponse : ( requestId : int , status : bool );","title":"P Events"},{"location":"manual/expressions/","text":"A Function in P can be arbitrary piece of imperative code which enables programmers to capture complex protocol logic in their state machines. P supports the common imperative programming language expressions (just like in Java ). P Expressions Grammar expr : | (expr) # ParenExpr | primitiveExpr # PrimitiveExpr | formatedString # FormatStringExpr | (tupleBody) # TupleExpr | (namedTupleBody) # NamedTupleExpr | expr.int # TupleAccessExpr | expr.iden # NamedTupleAccessExpr | expr[expr] # AccessExpr | keys(expr) # KeysExpr | values(expr) # ValuesExpr | sizeof(expr) # SizeofExpr | expr in expr # ContainsExpr | default(type) # DefaultExpr | new iden ( rvalueList? ) # NewExpr | iden ( rvalueList? ) # FunCallExpr | (- | !) expr # UnaryExpr | expr (* | / | + | -) expr # ArithBinExpr | expr (== | !=) expr # EqualityBinExpr | expr (&& | ||) expr # LogicalBinExpr | expr (< | > | >= | <= ) expr # CompBinExpr | expr as type # CastExpr | expr to type # CoerceExpr | choose ( expr? ) # ChooseExpr ; # Formated strings for creating strings formatedString | format ( StringLiteral (, rvalueList)? ) ; primitiveExpr : iden # Identifier | FloatLiteral # FloatConstant | BoolLiteral # BooleanConstant | IntLiteral # IntConstant | NullLiteral # Null | StringLiteral # StringConstant | $ # BooleanNonDeterministicChoice | halt # HaltEvent | this # SelfMachineReference ; # Body of a tuple tupleBody : | rvalue , | rvalue (, rvalue)+ ; # Body of a named tuple namedTupleBody: | iden = rvalue , | iden = rvalue (, iden = rvalue)+ ; # r-value is an expression that can\u2019t have a value assigned to it which # means r-value can appear on right but not on left hand side of an assignment operator(=) rvalue : expr ; # rvalueList is a comma separated list of rvalue. Primitives P allows the common primitive expressions like literal-constants for integers, floats, strings, booleans, and the null value. There are three unique primitive expressions in P: $ $ represents a nondeterministic boolean choice. It is a short hand for choose() which randomly returns a boolean value and the P Checker explores the behavior of the system for both the possibilities i.e., both when $ evaluates to true or false . Halt halt is a special event in P used for destroying an instance of a P machine. The semantics of an halt event is that whenever a P machine throws an unhandled event exception because of a halt event then the machine is automatically destroyed or halted and all events sent to that machine instance there after are equivalent to being dropped to ether. There are two ways of using the halt event: (1) self-halt by doing raise halt; raising a halt event which is not handled in the state machine will lead to that machine being halted or (2) by sending the halt event to a machine, and that machine on dequeueing halt , would halt itself. Please checkout the FailureDetector example in tutorials to know more about halt event This this represents the self machine reference of the current machine. It can be used to send self reference to other machines in the program so that they can send messages to this machine. Formatted String P allows creating formatted strings. Syntax: : format ( formatString (, rvalueList)? ) formatString is the format string and rvalueList is a comma separated list of arguments for the formatted string. Formatted String var hw , h , w : string ; var tup : ( string , int ); h = \"Hello\" ; w = \"World\" ; tup = ( \"tup value\" , 100 ); hw = format ( \"{0} {1}, and {2} is {3}!\" , h , w , tup .0 , tup .1 ); // hw value is \"Hello World, and tup value is 100!\" Print Formatted String Formatted strings are most useful for printing logs. Checkout print statement . var hw , h , w : string ; var tup : ( string , int ); h = \"Hello\" ; w = \"World\" ; tup = ( \"tup value\" , 100 ); print format ( \"{0} {1}, and {2} is {3}!\" , h , w , tup .0 , tup .1 ); // prints \"Hello World, and tup value is 100!\" Tuple and Named Tuple Values A tuple or named tuple value can be created using the following expressions: Syntax (tuple value): : (rvalue ,) for a single field tuple value or (rvalue (, rvalue)+) for tuple with multiple fields. // tuple value of type (int,) ( 10 ,) // tuple value of type (string, (string, string)) ( \"Hello\" , ( \"World\" , \"!\" )) // assume x: int and y: string // tuple value of type (int, string) ( x , y ) Syntax (named tuple value): : (iden = rvalue ,) for a single field named tuple value or (iden = rvalue (, iden = rvalue)+) for named tuple with multiple fields. // named tuple value of type (reqId: int,) ( reqId = 10 ,) // named tuple value of type (h: string, (w: string, a: string)) ( h = \"Hello\" , ( w = \"World\" , a = \"!\" )) // assume x: int and y: string // named tuple value of type (a:int, b:string) ( a = x , b = y ) Access Field of Tuple and Named Tuple The fields of a tuple can be accessed by using the . operation followed by the field index. Syntax (tuple value): expr.int where expr is the tuple value and int is the field index. // tuple with three fields var tupleEx : ( int , bool , int ); tupleEx = ( 20 , false , 21 ); // accessing the first and third element of the tupleEx tupleEx .0 = tupleEx .0 + tupleEx .2 ; Named tuples are similar to tuples with each field having an associated name. The fields of a named tuple can be accessed by using the . operation followed by the field name. Syntax (named tuple value) : expr.iden where expr is the named tuple value and iden is the field name. // named tuple with three fields var namedTupleEx : ( x1 : int , x2 : bool , x3 : int ); namedTupleEx = ( x1 = 20 , x2 = false , x3 = 21 ); // accessing the first and third element of the namedTupleEx namedTupleEx . x1 = namedTupleEx . x1 + namedTupleEx . x3 ; Indexing into a Collection P supports three collection types: map , seq , and set . We can index into these collection types to access its elements. Syntax: expr_c[expr_i] If expr_c is a value of sequence type then expr_i must be an integer expression and expr_c[expr_i] represents the element at index expr_i . Similarly, If expr_c is a value of set type then expr_i must be an integer expression and expr_c[expr_i] represents the element at index expr_i but note that for a set there is no guarantee for the order in which elements are stored in the set. Finally, if expr_c is a value of map type then expr_i represents the key to look up and expr_c[expr_i] represents the value for the key expr_i . Operations on Collections P supports four other operations on collection types: sizeof Syntax: : sizeof(expr) , where expr is a value of type set , seq or map , returns an integer value representing the size or length of the collection. var sq : seq [ int ] ; while ( i < sizeof ( sq ) > ) { ... i = i + 1 ; } keys and values Programmers can use keys and values functions to get access to a sequence of all the keys or values in map respectively. Syntax: : keys(expr) or values(expr) expr must be a map value, if expr : map[K, V] then keys(expr) returns a sequence of all keys in the map (of type seq[K] ) and similarly, values(expr) returns a sequence of all values in the map (of type seq[V] ). Primarily, keys and values are used to get contents of the map and then operate over it. contains (or in ) To check if an element (or key in the case of a map) belongs to a collection, P provides the in operation. Syntax: expr_e in expr_c expr_e is the element (or key in the case of map) and expr_c is the collection value. The in expression evaluates to true if the element belongs to the collection and false otherwise. var sq : seq [ tRequest ] ; var mp : map [ int , tRequest ] ; var rr : tRequest ; var i : int ; ... if ( rr in sq && rr in values ( mp ) && i in mp ) { ... } Default value for a type The default primitive in P can be used to obtain the default value for any type. Syntax: default(type) type is any P type and default(type) represents the default value for the type . The default values for all P types is provided here . New New expression is used to create an instance of a machine, new returns a machine reference to the newly created instance of the machine. Syntax : new iden (rvalue?) ; iden is the name of the machine to be created and rvalue is the optional constructor parameter that becomes the input parameter of the entry function of the start state of the machine. Create a machine new Client (( id = 1 , server = this )); Creates a dynamic instance of a Client machine and passes the constructor parameter (id = 1, server = this) which is delivered as a payload to the entry function of the start state of the created Client machine. Function Call Function calls in P are similar to any other imperative programming languages. Note that the parameters passed to the functions and the return values are pass-by-value! Syntax : iden ( rvalueList? ) ; iden is the name of the function and rvalueList is the comma separated list of function arguments. Function call x = Foo (); y = Bar ( 10 , \"haha\" ); Negation and Not P supports two unary operations: - on integers and floats values (i.e., negation) and ! on boolean values (i.e., logical not). Arithmetic P supports the following arithmetic binary operations on integers or floats: + (i.e., addition), - (i.e., subtraction), * (i.e., multiplication), % (i.e., modulo), and / (i.e., division). Comparison P supports the following comparison binary operations on integers or floats: < (i.e., less-than), <= (i.e., less-than-equal), > (i.e., greater-than), and >= (i.e., greater-than-equal). Cast P supports two super types any and data ( more details ). To cast values from these supertypes to the actual types, P supports the as cast expression. Syntax: expr as T expr expression is cast to type T and if the cast is not valid then it leads to dynamic type-cast error. type tRecord = ( key : int , val : any ); ... var st : set [ tRecord ] ; var x : any ; var x_i : string ; var st_i : set [ ( key : int , val : string ) ] ; x_i = x as string ; st += (( key = 1 , val = \"hello\" )); st_i = st as set [ ( key : int , val : string ) ] ; ... Coerce P supports coercing of any value of type float to int and also any enum element to int . Syntax: expr to T expr expression is coerced to type T . We currently support only coercing of type float to int and also any enum element to int . enum Status { ERROR = 101 , SUCCESS = 102 } ... var x_f : float ; var x_i : int ; x_f = 101.0 ; x_i = x_f to int ; assert x_i == ERROR to int ; Choose P provides the choose primitive to model data nondeterminism in P programs. The P checker then explores the behavior of the program for all possible values that can be returned by the choose operation. Syntax: choose() or choose(expr) expr can either be a int value or a collection. For choose(x) , when x is an integer, choose(x) returns a random value between 0 to x (excluding x), when x is a collection then choose(x) returns a random element from the collection. choose () // returns true or false, is equivalent to $ choose ( 10 ) // returns an integer x, 0 <= x < 10 choose ( x ) // if x is set or seq then returns a value from that collection The choose operation can be used to model nondeterministic environment machines that generate random inputs for the system. Another use case could be to model nondeterministic behavior within the system itself where the system can randomly choose to timeout or fail or drop messages . Performing a choose over an empty collection leads to an error. Also, choose from a map value returns a random key from the map.","title":"P Expressions"},{"location":"manual/expressions/#primitives","text":"P allows the common primitive expressions like literal-constants for integers, floats, strings, booleans, and the null value. There are three unique primitive expressions in P:","title":"Primitives"},{"location":"manual/expressions/#_1","text":"$ represents a nondeterministic boolean choice. It is a short hand for choose() which randomly returns a boolean value and the P Checker explores the behavior of the system for both the possibilities i.e., both when $ evaluates to true or false .","title":"$"},{"location":"manual/expressions/#halt","text":"halt is a special event in P used for destroying an instance of a P machine. The semantics of an halt event is that whenever a P machine throws an unhandled event exception because of a halt event then the machine is automatically destroyed or halted and all events sent to that machine instance there after are equivalent to being dropped to ether. There are two ways of using the halt event: (1) self-halt by doing raise halt; raising a halt event which is not handled in the state machine will lead to that machine being halted or (2) by sending the halt event to a machine, and that machine on dequeueing halt , would halt itself. Please checkout the FailureDetector example in tutorials to know more about halt event","title":"Halt"},{"location":"manual/expressions/#this","text":"this represents the self machine reference of the current machine. It can be used to send self reference to other machines in the program so that they can send messages to this machine.","title":"This"},{"location":"manual/expressions/#formatted-string","text":"P allows creating formatted strings. Syntax: : format ( formatString (, rvalueList)? ) formatString is the format string and rvalueList is a comma separated list of arguments for the formatted string. Formatted String var hw , h , w : string ; var tup : ( string , int ); h = \"Hello\" ; w = \"World\" ; tup = ( \"tup value\" , 100 ); hw = format ( \"{0} {1}, and {2} is {3}!\" , h , w , tup .0 , tup .1 ); // hw value is \"Hello World, and tup value is 100!\" Print Formatted String Formatted strings are most useful for printing logs. Checkout print statement . var hw , h , w : string ; var tup : ( string , int ); h = \"Hello\" ; w = \"World\" ; tup = ( \"tup value\" , 100 ); print format ( \"{0} {1}, and {2} is {3}!\" , h , w , tup .0 , tup .1 ); // prints \"Hello World, and tup value is 100!\"","title":"Formatted String"},{"location":"manual/expressions/#tuple-and-named-tuple-values","text":"A tuple or named tuple value can be created using the following expressions: Syntax (tuple value): : (rvalue ,) for a single field tuple value or (rvalue (, rvalue)+) for tuple with multiple fields. // tuple value of type (int,) ( 10 ,) // tuple value of type (string, (string, string)) ( \"Hello\" , ( \"World\" , \"!\" )) // assume x: int and y: string // tuple value of type (int, string) ( x , y ) Syntax (named tuple value): : (iden = rvalue ,) for a single field named tuple value or (iden = rvalue (, iden = rvalue)+) for named tuple with multiple fields. // named tuple value of type (reqId: int,) ( reqId = 10 ,) // named tuple value of type (h: string, (w: string, a: string)) ( h = \"Hello\" , ( w = \"World\" , a = \"!\" )) // assume x: int and y: string // named tuple value of type (a:int, b:string) ( a = x , b = y )","title":"Tuple and Named Tuple Values"},{"location":"manual/expressions/#access-field-of-tuple-and-named-tuple","text":"The fields of a tuple can be accessed by using the . operation followed by the field index. Syntax (tuple value): expr.int where expr is the tuple value and int is the field index. // tuple with three fields var tupleEx : ( int , bool , int ); tupleEx = ( 20 , false , 21 ); // accessing the first and third element of the tupleEx tupleEx .0 = tupleEx .0 + tupleEx .2 ; Named tuples are similar to tuples with each field having an associated name. The fields of a named tuple can be accessed by using the . operation followed by the field name. Syntax (named tuple value) : expr.iden where expr is the named tuple value and iden is the field name. // named tuple with three fields var namedTupleEx : ( x1 : int , x2 : bool , x3 : int ); namedTupleEx = ( x1 = 20 , x2 = false , x3 = 21 ); // accessing the first and third element of the namedTupleEx namedTupleEx . x1 = namedTupleEx . x1 + namedTupleEx . x3 ;","title":"Access Field of Tuple and Named Tuple"},{"location":"manual/expressions/#indexing-into-a-collection","text":"P supports three collection types: map , seq , and set . We can index into these collection types to access its elements. Syntax: expr_c[expr_i] If expr_c is a value of sequence type then expr_i must be an integer expression and expr_c[expr_i] represents the element at index expr_i . Similarly, If expr_c is a value of set type then expr_i must be an integer expression and expr_c[expr_i] represents the element at index expr_i but note that for a set there is no guarantee for the order in which elements are stored in the set. Finally, if expr_c is a value of map type then expr_i represents the key to look up and expr_c[expr_i] represents the value for the key expr_i .","title":"Indexing into a Collection"},{"location":"manual/expressions/#operations-on-collections","text":"P supports four other operations on collection types:","title":"Operations on Collections"},{"location":"manual/expressions/#sizeof","text":"Syntax: : sizeof(expr) , where expr is a value of type set , seq or map , returns an integer value representing the size or length of the collection. var sq : seq [ int ] ; while ( i < sizeof ( sq ) > ) { ... i = i + 1 ; }","title":"sizeof"},{"location":"manual/expressions/#keys-and-values","text":"Programmers can use keys and values functions to get access to a sequence of all the keys or values in map respectively. Syntax: : keys(expr) or values(expr) expr must be a map value, if expr : map[K, V] then keys(expr) returns a sequence of all keys in the map (of type seq[K] ) and similarly, values(expr) returns a sequence of all values in the map (of type seq[V] ). Primarily, keys and values are used to get contents of the map and then operate over it.","title":"keys and values"},{"location":"manual/expressions/#contains-or-in","text":"To check if an element (or key in the case of a map) belongs to a collection, P provides the in operation. Syntax: expr_e in expr_c expr_e is the element (or key in the case of map) and expr_c is the collection value. The in expression evaluates to true if the element belongs to the collection and false otherwise. var sq : seq [ tRequest ] ; var mp : map [ int , tRequest ] ; var rr : tRequest ; var i : int ; ... if ( rr in sq && rr in values ( mp ) && i in mp ) { ... }","title":"contains (or in)"},{"location":"manual/expressions/#default-value-for-a-type","text":"The default primitive in P can be used to obtain the default value for any type. Syntax: default(type) type is any P type and default(type) represents the default value for the type . The default values for all P types is provided here .","title":"Default value for a type"},{"location":"manual/expressions/#new","text":"New expression is used to create an instance of a machine, new returns a machine reference to the newly created instance of the machine. Syntax : new iden (rvalue?) ; iden is the name of the machine to be created and rvalue is the optional constructor parameter that becomes the input parameter of the entry function of the start state of the machine. Create a machine new Client (( id = 1 , server = this )); Creates a dynamic instance of a Client machine and passes the constructor parameter (id = 1, server = this) which is delivered as a payload to the entry function of the start state of the created Client machine.","title":"New"},{"location":"manual/expressions/#function-call","text":"Function calls in P are similar to any other imperative programming languages. Note that the parameters passed to the functions and the return values are pass-by-value! Syntax : iden ( rvalueList? ) ; iden is the name of the function and rvalueList is the comma separated list of function arguments. Function call x = Foo (); y = Bar ( 10 , \"haha\" );","title":"Function Call"},{"location":"manual/expressions/#negation-and-not","text":"P supports two unary operations: - on integers and floats values (i.e., negation) and ! on boolean values (i.e., logical not).","title":"Negation and Not"},{"location":"manual/expressions/#arithmetic","text":"P supports the following arithmetic binary operations on integers or floats: + (i.e., addition), - (i.e., subtraction), * (i.e., multiplication), % (i.e., modulo), and / (i.e., division).","title":"Arithmetic"},{"location":"manual/expressions/#comparison","text":"P supports the following comparison binary operations on integers or floats: < (i.e., less-than), <= (i.e., less-than-equal), > (i.e., greater-than), and >= (i.e., greater-than-equal).","title":"Comparison"},{"location":"manual/expressions/#cast","text":"P supports two super types any and data ( more details ). To cast values from these supertypes to the actual types, P supports the as cast expression. Syntax: expr as T expr expression is cast to type T and if the cast is not valid then it leads to dynamic type-cast error. type tRecord = ( key : int , val : any ); ... var st : set [ tRecord ] ; var x : any ; var x_i : string ; var st_i : set [ ( key : int , val : string ) ] ; x_i = x as string ; st += (( key = 1 , val = \"hello\" )); st_i = st as set [ ( key : int , val : string ) ] ; ...","title":"Cast"},{"location":"manual/expressions/#coerce","text":"P supports coercing of any value of type float to int and also any enum element to int . Syntax: expr to T expr expression is coerced to type T . We currently support only coercing of type float to int and also any enum element to int . enum Status { ERROR = 101 , SUCCESS = 102 } ... var x_f : float ; var x_i : int ; x_f = 101.0 ; x_i = x_f to int ; assert x_i == ERROR to int ;","title":"Coerce"},{"location":"manual/expressions/#choose","text":"P provides the choose primitive to model data nondeterminism in P programs. The P checker then explores the behavior of the program for all possible values that can be returned by the choose operation. Syntax: choose() or choose(expr) expr can either be a int value or a collection. For choose(x) , when x is an integer, choose(x) returns a random value between 0 to x (excluding x), when x is a collection then choose(x) returns a random element from the collection. choose () // returns true or false, is equivalent to $ choose ( 10 ) // returns an integer x, 0 <= x < 10 choose ( x ) // if x is set or seq then returns a value from that collection The choose operation can be used to model nondeterministic environment machines that generate random inputs for the system. Another use case could be to model nondeterministic behavior within the system itself where the system can randomly choose to timeout or fail or drop messages . Performing a choose over an empty collection leads to an error. Also, choose from a map value returns a random key from the map.","title":"Choose"},{"location":"manual/foriegntypesfunctions/","text":"Foreign Types Foreign types in P are types that are declared in P but defined or implemented in the foreign language ( foreign type ). Foreign Functions Foreign functions in P are local or global functions that are declared in P but defined or implemented in the foreign language ( foreign functions ). Recommendation: Using Foreign Types and Functions Programmers can consider implementing a particular type as Foreign type in P if it's a complicated data structure and implementing them using P types is either not possible or too cumbersome. For example, P does not support declaring recursive data types, and hence, implementing a linked-list or a tree like data-structure in P is hard. Hence, we recommend programmers to implement such types as foreign types. When modeling complex systems, many times programmers need to implement complicated logic/functions that manipulate or iterate over data-structures. Such functions can be easily implemented in foreign languages like Java and C# as compared to P. For example, sorting a list is easier in Java and C# through standard library functions and verbose in P. Also, functions that manipulate foreign types are implemented as foreign functions. The Two Phase Commit example had introduced the foreign function feature. We will now use a simple PriorityQueue example to go into the details of foreign interface in P. PriorityQueue The PriorityQueue project presents an example where a Client uses a priority queue implemented as foreign types and functions. P Source The PriorityQueue.p file declares (1) a foreign type tPriorityQueue and uses (2) global foreign functions to operate or interact with the priority queue. P has Value Semantics (no Pass by Reference!!) Note that P does not support pass by references, everything in P is always pass by value. Hence, the functions above must return a priority queue after adding the element into the queue (mutated queue). P Test The Client.p file presents a Client state machine that uses the priority queue and performs operations on it by calling the foreign function. The Client machine also declares a local foreign function to add an element into the queue. P Foreign Code The implementation of the tPriorityQueue is available in PriorityQueue.cs If you want to pretty print the foreign type value, you can also override the ToString() function in their implementation. The implementation of the global functions in PriorityQueue.p is available in PriorityQueueFunctions.cs . Finally, the implementation of the local function in the Client machine is available in ClientFunctions.cs . Compiling PriorityQueue Navigate to the PriorityQueue folder and run the following command to compile the PriorityQueue project: p compile Expected Output $ p compile .. Searching for a P project file *.pproj locally in the current folder .. Found P project file: P/Tutorial/PriorityQueue/PriorityQueue.pproj ---------------------------------------- ==== Loading project file: P/Tutorial/PriorityQueue/PriorityQueue.pproj ....... includes p file: P/Tutorial/PriorityQueue/PSrc/PriorityQueue.p ....... includes p file: P/Tutorial/PriorityQueue/PTst/Client.p ....... includes p file: P/Tutorial/PriorityQueue/PTst/TestScripts.p ....... includes foreign file: P/Tutorial/PriorityQueue/PForeign/PriorityQueue.cs ....... includes foreign file: P/Tutorial/PriorityQueue/PForeign/PriorityQueueFunctions.cs ....... includes foreign file: P/Tutorial/PriorityQueue/PForeign/ClientFunctions.cs ---------------------------------------- ---------------------------------------- Parsing ... Type checking ... Code generation ... Generated PriorityQueue.cs. ---------------------------------------- Compiling PriorityQueue... MSBuild version 17.3.1+2badb37d1 for .NET Determining projects to restore... Restored P/Tutorial/PriorityQueue/PGenerated/CSharp/PriorityQueue.csproj (in 392 ms). PriorityQueue -> P/Tutorial/PriorityQueue/PGenerated/CSharp/net6.0/PriorityQueue.dll Build succeeded. 0 Warning(s) 0 Error(s) Time Elapsed 00:00:04.08 ---------------------------------------- [PTool]: Thanks for using P! Checking PriorityQueue Run the following command to run the test case tcCheckPriorityQueue in verbose mode: p check -v Expected Output $ p check -v .. Searching for a P compiled file locally in the current folder .. Found a P compiled file: P/Tutorial/PriorityQueue/PGenerated/CSharp/net6.0/PriorityQueue.dll .. Checking P/Tutorial/PriorityQueue/PGenerated/CSharp/net6.0/PriorityQueue.dll .. Test case :: tcCheckPriorityQueue ... Checker is using 'random' strategy (seed:1636311106). ..... Iteration #1 <TestLog> Running test 'tcCheckPriorityQueue'. <CreateLog> Plang.CSharpRuntime._GodMachine(1) was created by task '2'. <CreateLog> PImplementation.Client(2) was created by Plang.CSharpRuntime._GodMachine(1). <StateLog> PImplementation.Client(2) enters state 'Init'. <PrintLog> Creating Priority Queue! <PrintLog> Adding Element in the Priority Queue! <PrintLog> Adding Element in the Priority Queue! <PrintLog> Adding Element in the Priority Queue! <PrintLog> Choosing element at location: 1 <PrintLog> -------------- <PrintLog> Hello <PrintLog> World <PrintLog> !! <PrintLog> 123 <PrintLog> -------------- ... ### Process 0 is terminating ... Emitting coverage reports: ..... Writing PCheckerOutput/BugFinding/PriorityQueue.dgml ..... Writing PCheckerOutput/BugFinding/PriorityQueue.coverage.txt ..... Writing PCheckerOutput/BugFinding/PriorityQueue.sci ... Checking statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 1 schedule: 1 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 5 (min), 5 (avg), 5 (max). ... Elapsed 0.3070145 sec. . Done [PTool]: Thanks for using P! Hope you exploit the P Foreign interface to implement and check complex systems. If you have any questions, please feel free to post them in the discussions or issues.","title":"P Foreign Interface"},{"location":"manual/foriegntypesfunctions/#priorityqueue","text":"The PriorityQueue project presents an example where a Client uses a priority queue implemented as foreign types and functions.","title":"PriorityQueue"},{"location":"manual/foriegntypesfunctions/#p-source","text":"The PriorityQueue.p file declares (1) a foreign type tPriorityQueue and uses (2) global foreign functions to operate or interact with the priority queue. P has Value Semantics (no Pass by Reference!!) Note that P does not support pass by references, everything in P is always pass by value. Hence, the functions above must return a priority queue after adding the element into the queue (mutated queue).","title":"P Source"},{"location":"manual/foriegntypesfunctions/#p-test","text":"The Client.p file presents a Client state machine that uses the priority queue and performs operations on it by calling the foreign function. The Client machine also declares a local foreign function to add an element into the queue.","title":"P Test"},{"location":"manual/foriegntypesfunctions/#p-foreign-code","text":"The implementation of the tPriorityQueue is available in PriorityQueue.cs If you want to pretty print the foreign type value, you can also override the ToString() function in their implementation. The implementation of the global functions in PriorityQueue.p is available in PriorityQueueFunctions.cs . Finally, the implementation of the local function in the Client machine is available in ClientFunctions.cs .","title":"P Foreign Code"},{"location":"manual/foriegntypesfunctions/#compiling-priorityqueue","text":"Navigate to the PriorityQueue folder and run the following command to compile the PriorityQueue project: p compile Expected Output $ p compile .. Searching for a P project file *.pproj locally in the current folder .. Found P project file: P/Tutorial/PriorityQueue/PriorityQueue.pproj ---------------------------------------- ==== Loading project file: P/Tutorial/PriorityQueue/PriorityQueue.pproj ....... includes p file: P/Tutorial/PriorityQueue/PSrc/PriorityQueue.p ....... includes p file: P/Tutorial/PriorityQueue/PTst/Client.p ....... includes p file: P/Tutorial/PriorityQueue/PTst/TestScripts.p ....... includes foreign file: P/Tutorial/PriorityQueue/PForeign/PriorityQueue.cs ....... includes foreign file: P/Tutorial/PriorityQueue/PForeign/PriorityQueueFunctions.cs ....... includes foreign file: P/Tutorial/PriorityQueue/PForeign/ClientFunctions.cs ---------------------------------------- ---------------------------------------- Parsing ... Type checking ... Code generation ... Generated PriorityQueue.cs. ---------------------------------------- Compiling PriorityQueue... MSBuild version 17.3.1+2badb37d1 for .NET Determining projects to restore... Restored P/Tutorial/PriorityQueue/PGenerated/CSharp/PriorityQueue.csproj (in 392 ms). PriorityQueue -> P/Tutorial/PriorityQueue/PGenerated/CSharp/net6.0/PriorityQueue.dll Build succeeded. 0 Warning(s) 0 Error(s) Time Elapsed 00:00:04.08 ---------------------------------------- [PTool]: Thanks for using P!","title":"Compiling PriorityQueue"},{"location":"manual/foriegntypesfunctions/#checking-priorityqueue","text":"Run the following command to run the test case tcCheckPriorityQueue in verbose mode: p check -v Expected Output $ p check -v .. Searching for a P compiled file locally in the current folder .. Found a P compiled file: P/Tutorial/PriorityQueue/PGenerated/CSharp/net6.0/PriorityQueue.dll .. Checking P/Tutorial/PriorityQueue/PGenerated/CSharp/net6.0/PriorityQueue.dll .. Test case :: tcCheckPriorityQueue ... Checker is using 'random' strategy (seed:1636311106). ..... Iteration #1 <TestLog> Running test 'tcCheckPriorityQueue'. <CreateLog> Plang.CSharpRuntime._GodMachine(1) was created by task '2'. <CreateLog> PImplementation.Client(2) was created by Plang.CSharpRuntime._GodMachine(1). <StateLog> PImplementation.Client(2) enters state 'Init'. <PrintLog> Creating Priority Queue! <PrintLog> Adding Element in the Priority Queue! <PrintLog> Adding Element in the Priority Queue! <PrintLog> Adding Element in the Priority Queue! <PrintLog> Choosing element at location: 1 <PrintLog> -------------- <PrintLog> Hello <PrintLog> World <PrintLog> !! <PrintLog> 123 <PrintLog> -------------- ... ### Process 0 is terminating ... Emitting coverage reports: ..... Writing PCheckerOutput/BugFinding/PriorityQueue.dgml ..... Writing PCheckerOutput/BugFinding/PriorityQueue.coverage.txt ..... Writing PCheckerOutput/BugFinding/PriorityQueue.sci ... Checking statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 1 schedule: 1 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 5 (min), 5 (avg), 5 (max). ... Elapsed 0.3070145 sec. . Done [PTool]: Thanks for using P! Hope you exploit the P Foreign interface to implement and check complex systems. If you have any questions, please feel free to post them in the discussions or issues.","title":"Checking PriorityQueue"},{"location":"manual/functions/","text":"There are two types of functions in P: (1) anonymous functions, and (2) named functions. Anonymous functions are unnamed functions that can appear as an entry functions or exit functions or as event-handlers. Named functions can either be declared inside a state machine or globally as a top-level declaration. The named functions declared within a state machine are local to that machine and hence can access the local-variables of the machine. Global named functions are shared across state machines. Note that the purpose of having named functions is to enable code reuse. Named functions can be also be used as entry/exit functions and also as event handlers. Please look at P state machine for more details about the declaration of these functions. P Functions Grammar anonFunction : (funParam?) functionBody # AnonymousFunDecl funDecl : | fun name (funParamList?) (: returnType)? ; # ForeignFunDecl | fun name (funParamList?) (: returnType)? functionBody # FunDecl ; functionBody : { varDecl* statement* } # FunctionBody varDecl : var iden : type; ; # VariableDecl funParamList : funParam (, funParam)* ; # FunParameterList funParam : iden : type # FunParameter Anonymous Functions Anonymous functions are unnamed functions that appear as entry or exit or event-handler functions. Syntax : (funParam?) functionBody funParam is the optional single parameter allowed with the annonymous functions. To know more about the places annonymous functions can be used, please checkout the grammar of p state machines and receive statements . Named Functions Named functions in P can be declared within P state machines as local functions that can access the local variables of the state machine. Named functions that are declared as top-level declarations are global functions that can be used across state machines. Check out the grammar of P state machines for local functions declarations and top-level declarations grammar for the global function declarations. Example of a local functions: here and an example of a global function that is shared across all machines: here Syntax : fun name (funParamList?) (: returnType)? functionBody name is the name of the named function, funParamList is the optional function parameters, and returnType is the optional return type of the function. Foreign Functions P named function declarations without any function body are referred to as foreign functions. Foreign functions are functions that are declared in P and can be used in the P program just like any other function but the implementation of these functions is provided in the foreign language. Syntax : fun name (funParamList?) (: returnType)? ; name is the name of the named function, funParamList is the optional function parameters, and returnType is the optional return type of the function. To know more about the foreign interface and functions, please look at the PriorityQueue example . Function Body Function body in P is similar to other programming languages with a restriction that P function-local variables uses C style local variable declarations. Declaration of local variables in a function must come before any other statement in the function body. So, the body of a function in P is a sequence of variable declarations followed by a sequence of statements . functionBody : { varDecl* statement* }","title":"P Functions"},{"location":"manual/functions/#anonymous-functions","text":"Anonymous functions are unnamed functions that appear as entry or exit or event-handler functions. Syntax : (funParam?) functionBody funParam is the optional single parameter allowed with the annonymous functions. To know more about the places annonymous functions can be used, please checkout the grammar of p state machines and receive statements .","title":"Anonymous Functions"},{"location":"manual/functions/#named-functions","text":"Named functions in P can be declared within P state machines as local functions that can access the local variables of the state machine. Named functions that are declared as top-level declarations are global functions that can be used across state machines. Check out the grammar of P state machines for local functions declarations and top-level declarations grammar for the global function declarations. Example of a local functions: here and an example of a global function that is shared across all machines: here Syntax : fun name (funParamList?) (: returnType)? functionBody name is the name of the named function, funParamList is the optional function parameters, and returnType is the optional return type of the function.","title":"Named Functions"},{"location":"manual/functions/#foreign-functions","text":"P named function declarations without any function body are referred to as foreign functions. Foreign functions are functions that are declared in P and can be used in the P program just like any other function but the implementation of these functions is provided in the foreign language. Syntax : fun name (funParamList?) (: returnType)? ; name is the name of the named function, funParamList is the optional function parameters, and returnType is the optional return type of the function. To know more about the foreign interface and functions, please look at the PriorityQueue example .","title":"Foreign Functions"},{"location":"manual/functions/#function-body","text":"Function body in P is similar to other programming languages with a restriction that P function-local variables uses C style local variable declarations. Declaration of local variables in a function must come before any other statement in the function body. So, the body of a function in P is a sequence of variable declarations followed by a sequence of statements . functionBody : { varDecl* statement* }","title":"Function Body"},{"location":"manual/modulesystem/","text":"The P module system allows programmers to decompose their complex system into modules to implement and test the system compositionally. More details about the underlying theory for the P module system (assume-guarantee style compositional reasoning) is described in the paper In its simplest form, a module in P is a collection of state machines. The P module system allows constructing larger modules by composing or unioning modules together. Hence, a distributed system under test which is a composition of multiple components can be constructed by composing (or unioning) modules corresponding to those components. The P test cases takes as input a module that represents the closed 1 system to be validated which in turn is the union or composition of all the component modules. P Modules Grammar modExpr : | ( modExpr ) # AnnonymousModuleExpr | { bindExpr (, bindExpr)* } # PrimitiveModuleExpr | union modExpr (, modExpr)+ # UnionModuleExpr | assert idenList in modExpr # AssertModuleExpr | iden # NamedModule ; # Bind a machine to an interface bindExpr : (iden | iden -> iden) ; # MachineBindExpr # Create a named module i.e., assign a name to a module namedModuleDecl : module iden = modExpr ; # Named module declaration Named Module A named module declaration simply assigns a name to a module expression. Syntax : module mName = modExpr; mName is the assiged name for the module modExpr where modExpr is any of the modules described below. Named Module module serverModule = { Server, Timer }; The above line assigns the name serverModule to a primitive module consisting of machines Server and Timer . Primitive Module A primitive module is a (annonymous) collection of state machines. Syntax : { bindExpr (, bindExpr)* } where bindExpr is a binding expression which could either be just the name of a machine iden or a mapping mName -> replaceName that maps a machine mName to a machine name replaceName that we want to replace. The binding enforces that whenever a machine replaceName is created in the module (i.e., new replaceName(..) ) it leads to the creation of machine mName . The indirection using this binding is helpful in cases where we would like to replace a machine with another machine (e.g., implementation by its abstraction). This usecase is explained in the ClientServer example. In most cases, a primitive module is simply a list of state machines that together implement that component. Primitive Module // Lets say there are three machines in the P program: Client, Server, and Timer module client = { Client }; module server = { Server, Timer }; client is a primitive module consisting of the Client machine and the server module is a primitive module consistency of machines Server and Timer . Primitive Module with Bindings // Lets say there are four machines in the P program: Client, Server, AbstractServer and Timer module client = { Client }; module server = { Server, Timer }; module serverAbs = {AbstractServer -> Server, Timer}; client is a primitive module consisting of the Client machine and the server module is a primitive module consisting of machines Server and Timer . The module serverAbs represents a primitive module consisting of machines AbstractServer and Timer machines with the difference that wherever the serverAbs module is used the creation of machine Server will in turn lead to creation of the AbstractServer machine. Union Module P supports unioning multiple modules together to create larger, more complex modules. The idea is to implement the distributed system as a collection of components (modules), test and verify these components in isolation using the abstractions of other components, and also potentially union them together to validate the entire system together as well. Syntax: : union modExpr (, modExpr)+ modExpr is any P module. The union of two modules is simply a creation of a new module which is a union of the machines of the component modules. module system = (union client, server); system is a module which is a union of the modules client and server . module systemAbs = (union client, serverAbs); systemAbs is a module which is a union of the module client and the serverAbs where the Client machine interacts with the AbstractServer machine instead of the Server machine in the system module. Assert Monitors Module P allows attaching monitors (or specifications) to modules. When attaching monitors to a module, the events observed by the monitors must be sent by some machine in the module. The way to think about assert monitors module is that: `attaching these monitors to the module asserts (during P checker exploration) that each execution of the module satisfies the global properties specified by the monitors._ Syntax: assert idenList in modExpr idenList is a comma separated list of monitor (spec machine) names that are being asserted on the executions of the module modExpr . assert AtomicitySpec, EventualResponse in TwoPhaseCommit The above module asserts that the executions of the module TwoPhaseCommit satisfy the properties specified by the monitors AtomicitySpec and EventualResponse . More module constructors P supports more complex module constructors like compose , hide , and rename . The description for these will be added later, they are mostly used for more advanced compositional reasoning. A closed system is a system where all the machines or interfaces that are created are defined or implemented in the unioned modules. \u21a9","title":"P Module System"},{"location":"manual/modulesystem/#named-module","text":"A named module declaration simply assigns a name to a module expression. Syntax : module mName = modExpr; mName is the assiged name for the module modExpr where modExpr is any of the modules described below. Named Module module serverModule = { Server, Timer }; The above line assigns the name serverModule to a primitive module consisting of machines Server and Timer .","title":"Named Module"},{"location":"manual/modulesystem/#primitive-module","text":"A primitive module is a (annonymous) collection of state machines. Syntax : { bindExpr (, bindExpr)* } where bindExpr is a binding expression which could either be just the name of a machine iden or a mapping mName -> replaceName that maps a machine mName to a machine name replaceName that we want to replace. The binding enforces that whenever a machine replaceName is created in the module (i.e., new replaceName(..) ) it leads to the creation of machine mName . The indirection using this binding is helpful in cases where we would like to replace a machine with another machine (e.g., implementation by its abstraction). This usecase is explained in the ClientServer example. In most cases, a primitive module is simply a list of state machines that together implement that component. Primitive Module // Lets say there are three machines in the P program: Client, Server, and Timer module client = { Client }; module server = { Server, Timer }; client is a primitive module consisting of the Client machine and the server module is a primitive module consistency of machines Server and Timer . Primitive Module with Bindings // Lets say there are four machines in the P program: Client, Server, AbstractServer and Timer module client = { Client }; module server = { Server, Timer }; module serverAbs = {AbstractServer -> Server, Timer}; client is a primitive module consisting of the Client machine and the server module is a primitive module consisting of machines Server and Timer . The module serverAbs represents a primitive module consisting of machines AbstractServer and Timer machines with the difference that wherever the serverAbs module is used the creation of machine Server will in turn lead to creation of the AbstractServer machine.","title":"Primitive Module"},{"location":"manual/modulesystem/#union-module","text":"P supports unioning multiple modules together to create larger, more complex modules. The idea is to implement the distributed system as a collection of components (modules), test and verify these components in isolation using the abstractions of other components, and also potentially union them together to validate the entire system together as well. Syntax: : union modExpr (, modExpr)+ modExpr is any P module. The union of two modules is simply a creation of a new module which is a union of the machines of the component modules. module system = (union client, server); system is a module which is a union of the modules client and server . module systemAbs = (union client, serverAbs); systemAbs is a module which is a union of the module client and the serverAbs where the Client machine interacts with the AbstractServer machine instead of the Server machine in the system module.","title":"Union Module"},{"location":"manual/modulesystem/#assert-monitors-module","text":"P allows attaching monitors (or specifications) to modules. When attaching monitors to a module, the events observed by the monitors must be sent by some machine in the module. The way to think about assert monitors module is that: `attaching these monitors to the module asserts (during P checker exploration) that each execution of the module satisfies the global properties specified by the monitors._ Syntax: assert idenList in modExpr idenList is a comma separated list of monitor (spec machine) names that are being asserted on the executions of the module modExpr . assert AtomicitySpec, EventualResponse in TwoPhaseCommit The above module asserts that the executions of the module TwoPhaseCommit satisfy the properties specified by the monitors AtomicitySpec and EventualResponse . More module constructors P supports more complex module constructors like compose , hide , and rename . The description for these will be added later, they are mostly used for more advanced compositional reasoning. A closed system is a system where all the machines or interfaces that are created are defined or implemented in the unioned modules. \u21a9","title":"Assert Monitors Module"},{"location":"manual/monitors/","text":"Programmers can write safety and liveness specifications in P as monitors or spec machines. spec machines are monitor state machines or observer state machines that observe a set of events during the execution of the system and assert the desired correctness specifications based on these observations. Machines vs Spec Machine Syntactically, machines and spec machines in P are very similar in terms of the state machine structure . But, they have some key differences: spec machines in P are observer machines (imagine runtime monitors), they observe a set of events in the execution of the system and based on these observed events (may keep track on local state) assert the desired global safety and liveness specifications. Since spec machines are observer machines, they cannot have any side effects on the system behavior and hence, spec machines cannot perform send , receive , new , and annouce . spec machines are global machines , in other words, there is only a single instance of each monitor created at the start of the execution of the system. We currently do not support dynamic creation of monitors. Hence, spec machines cannot use this expression. spec machines are synchronously composed with the system that it is monitored. The way this is achieved is: each time there is a send or announce of an event during the execution of a system, all the monitors or specifications that are observing that event are executed synchronously at that point. Another way to imagine this is: just before send or annouce of an event, we deliver this event to all the monitors that are observing the event and synchronously execute the monitor at that point. Finally, spec machines can have hot and cold annotations on their states to model liveness specifications. P Spec Machine Grammar specMachineDecl : spec iden observes eventsList statemachineBody ; As mentioned above, syntactically, the P spec machines are very similar to the P state machines . The main difference being the observes annotation that specifies the list of events being observed (monitored) and also the hot and cold annotations on the states of a liveness specification. Syntax: spec iden observes eventsList statemachineBody ; iden is the name of the spec machine, eventsList is the comma separated list of events observed by the spec machine and the statemachineBody is the implementation of the specification and its grammar is similar to the P state machine . Safety specification 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /******************************************************************* ReqIdsAreMonotonicallyIncreasing observes the eRequest event and checks that the payload (Id) associated with the requests sent by all concurrent clients in the system is always globally monotonically increasing by 1 *******************************************************************/ spec ReqIdsAreMonotonicallyIncreasing observes eRequest { // keep track of the Id in the previous request var previousId : int ; start state Init { on eRequest do ( req : tRequest ) { assert req . rId > previousId , format ( \"Request Ids not monotonically increasing, got {0}, previously seen Id was { 1 } \", req.rId, previousId); previousId = req . rId ; } } } The above specification checks a very simple global invariant that all eRequest events that are being sent by clients in the system have a globally monotonically increasing rId . Liveness specification 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /************************************************************************** GuaranteedProgress observes the eRequest and eResponse events, it asserts that every request is always responded by a successful response. ***************************************************************************/ spec GuaranteedProgress observes eRequest , eResponse { // keep track of the pending requests var pendingReqs : set [ int ]; start state NopendingRequests { on eRequest goto PendingReqs with ( req : tRequest ){ pendingReqs += ( req . rId ); } } hot state PendingReqs { on eResponse do ( resp : tResponse ) { assert resp . rId in pendingReqs , format ( \"unexpected rId: {0} received, expected one of {1}\" , resp . rId , pendingReqs ); if ( resp . status == SUCCESS ) { pendingReqs -= ( resp . rId ); if ( sizeof ( pendingReqs ) == 0 ) // requests already responded goto NopendingRequests ; } } on eRequest goto PendingReqs with ( req : tRequest ){ pendingReqs += ( req . rId ); } } } The above specification checks the global liveness property that every event eRequest is eventually followed by a corresponding successful eResponse event. The key idea is that the system satisfies a liveness specification if at the end of the execution the monitor is not in a hot state (line 13). The programmers can use hot annotation on states to mark them as intermediate or error states. Hence, properties like eventually something holds or every event X is eventually followed by Y or eventually the system enters a convergence state , all such properties can be specified by marking the intermediate state as hot states and the checker checks that all the executions of the system eventually end in a non-hot state. If there exists an execution that fails to come out of a hot state eventually then it is flagged as a potential liveness violation. Details about the importance of liveness specifications is described here . For several examples of liveness properties, please check the specifications in the tutorial examples.","title":"P Monitors"},{"location":"manual/monitors/#safety-specification","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /******************************************************************* ReqIdsAreMonotonicallyIncreasing observes the eRequest event and checks that the payload (Id) associated with the requests sent by all concurrent clients in the system is always globally monotonically increasing by 1 *******************************************************************/ spec ReqIdsAreMonotonicallyIncreasing observes eRequest { // keep track of the Id in the previous request var previousId : int ; start state Init { on eRequest do ( req : tRequest ) { assert req . rId > previousId , format ( \"Request Ids not monotonically increasing, got {0}, previously seen Id was { 1 } \", req.rId, previousId); previousId = req . rId ; } } } The above specification checks a very simple global invariant that all eRequest events that are being sent by clients in the system have a globally monotonically increasing rId .","title":"Safety specification"},{"location":"manual/monitors/#liveness-specification","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /************************************************************************** GuaranteedProgress observes the eRequest and eResponse events, it asserts that every request is always responded by a successful response. ***************************************************************************/ spec GuaranteedProgress observes eRequest , eResponse { // keep track of the pending requests var pendingReqs : set [ int ]; start state NopendingRequests { on eRequest goto PendingReqs with ( req : tRequest ){ pendingReqs += ( req . rId ); } } hot state PendingReqs { on eResponse do ( resp : tResponse ) { assert resp . rId in pendingReqs , format ( \"unexpected rId: {0} received, expected one of {1}\" , resp . rId , pendingReqs ); if ( resp . status == SUCCESS ) { pendingReqs -= ( resp . rId ); if ( sizeof ( pendingReqs ) == 0 ) // requests already responded goto NopendingRequests ; } } on eRequest goto PendingReqs with ( req : tRequest ){ pendingReqs += ( req . rId ); } } } The above specification checks the global liveness property that every event eRequest is eventually followed by a corresponding successful eResponse event. The key idea is that the system satisfies a liveness specification if at the end of the execution the monitor is not in a hot state (line 13). The programmers can use hot annotation on states to mark them as intermediate or error states. Hence, properties like eventually something holds or every event X is eventually followed by Y or eventually the system enters a convergence state , all such properties can be specified by marking the intermediate state as hot states and the checker checks that all the executions of the system eventually end in a non-hot state. If there exists an execution that fails to come out of a hot state eventually then it is flagged as a potential liveness violation. Details about the importance of liveness specifications is described here . For several examples of liveness properties, please check the specifications in the tutorial examples.","title":"Liveness specification"},{"location":"manual/statemachines/","text":"The underlying model of computation for P state machines is similar to that of Gul Agha's Actor-model-of-computation ( wiki ). A P program is a collection of concurrently executing state machines that communicate with eachother by sending events (or messages) asynchronously. Each P state machine has an unbounded FIFO buffer associated with it. Sends are asynchronous , i.e., executing a send operation send t,e,v; adds event e with payload value v into the FIFO buffer of the target machine t . Each state in the P state machine has an entry and an exit function associated with it, entry function get executed when the state machine enters that state and similarly, the exit function gets executed when the machine exits that sate on an out going transition. After executing the entry function, the machine tries to dequeue an event from the input buffer or blocks if the buffer is empty. Upon dequeuing an event from the input queue of the machine, the attached handler is executed which might transition the machine to a different state. For detailed formal semantics of P state machines, we refer the readers to the original P paper and the more recent paper with updated semantics. P State Machine Grammar # State Machine in P machineDecl : machine name machineBody # State Machine Body machineBody : LBRACE machineEntry* RBRACE; machineEntry | varDecl | funDecl | stateDecl ; # Variable Decl varDecl : var iden : type; ; # State Declaration in P stateDecl : start? (hot | cold)? state name { stateBodyItem* } # State Body stateBody: | entry anonFunction # StateEntryFunAnon | entry funName ; # StateEntryFunNamed | exit noParamAnonFunction # StateExitFunAnon | exit funName; # StateExitFunNamed ## Transition or Event Handlers in each state | defer eventList ; # StateDeferHandler | ignore eventList ; # StateIgnoreHandler | on eventList do funName ; # OnEventDoAnonHandler | on eventList do anonFunction # OnEventDoNamedHandler | on eventList goto stateName ; # OnEventGotoState | on eventList goto stateName with anonFunction # OnEventGotoStateWithAnonHandler | on eventList goto stateName with funName ; # OnEventGotoStateWithNamedHandler ;","title":"P State Machines"},{"location":"manual/statements/","text":"A Function in P can be arbitrary piece of imperative code which enables programmers to capture complex protocol logic in their state machines. P supports common imperative programming language statement constructs like while-loops, function calls, and conditionals. P Statements Grammar statement : { statement* } # CompoundStmt | assert expr (, expr)? ; # AssertStmt | print expr ; # PrintStmt | foreach (iden in expr) statement # ForeachStmt | while ( expr ) statement # WhileStmt | if ( expr ) statement (else statement)? # IfThenElseStmt | break ; # BreakStmt | continue ; # ContinueStmt | return expr? ; # ReturnStmt | lvalue = rvalue ; # AssignStmt | lvalue += ( expr, rvalue ) ; # InsertStmt | lvalue += ( rvalue ) ; # AddStmt | lvalue -= rvalue ; # RemoveStmt | new iden (rvalue?) ; # CtorStmt | iden ( rvalueList? ) ; # FunCallStmt | raise expr (, rvalue)? ; # RaiseStmt | send expr, expr (, rvalue)? ; # SendStmt | annouce expr (, rvalue)? ; # AnnounceStmt | goto iden (, rvalue)? ; # GotoStmt | receive { recvCase+ } # ReceiveStmt ; /** l-value may appear as left hand of an assignment operator(=) **/ lvalue : name=iden # VarLvalue | lvalue . field=iden # NamedTupleFieldAccess | lvalue . int # TupleFieldAccess | lvalue [ expr ] # CollectionLookUp ; /* A r-value is an expression that can\u2019t have a value assigned to it which means r-value can appear on right but not on left hand side of an assignment operator(=)*/ rvalue : expr ; # rvalueList is a comma separated list of rvalue. /* case block inside a receive statement */ recvCase : case eventList : anonFunction The expr is any expression in P defined by the grammar desbribed in P Expressions Assert P allows writing local assertions using the assert statement. If the program violates the assertion then a counter example is generated by the P checker. Syntax : assert expr (, expr)? ; The assert statement must have a boolean expression followed by an optional string message that is printed in the error trace. Assert assert ( requestId > 1 ) && ( requestId in allRequestsSet ); Assert that the requestId is always greater than 1 and is in the set of all requests. Assert with Error Message assert x >= 0 , \"Expected x to be always positive\" ; The assert statement can have a string message which is printed in the error trace. Assert with Formatted Error Message assert ( requestId in allRequestsSet ), format ( \"requestId {0} is not in the requests set = {1}\" , requestId , allRequestsSet ); Assert that the requestId is in the set of all requests. You can also provide a formatted string error message to add details to the error message generated. Print Print statements can be used for writing or printing log messages into the error traces (especially for debugging purposes). Syntax : print expr ; The print statement must have an expression of type string . Print Simple Message print \"Hello World!\" ; Print \"Hello World!\" in the execution trace log. Print Formatted String Message x = \"You\" ; print format ( \"Hello World to {0}!!\" , x ); Print \"Hello World to You!!\" in the execution trace log. While While statement in P is just like while loops in other popular programming languages like C, C# or Java. Syntax : while ( expr ) statement expr is the conditional boolean expression and statement could be any P statement. While Loop i = 0 ; while ( i < 10 ) { ... i = i + 1 ; } While loop iterating over collection i = 0 ; while ( i < sizeof ( s )) { ... print s [ i ]; i = i + 1 ; } Foreach foreach statement can be used to iterate over a collection ( sequence or set ) in P. Syntax : foreach (iden in expr) statement iden is the name of the variable that store the element from the collection during iterations. expr represents the collection over which we want to iterate and must be of type seq or set . Type of iden must be same as the elements type in the collection. Note that variable iden must already be declared, and in each iteration, an element is assigned to this variable at the start of the iteration (no ordering guarantees). Also, one can mutate the collection represented by expr when iterating over it as the foreach statement enumerates over a clone of the collection (more details in the example below). Foreach (set) var iter , sum : int ; var ints : set [ int ]; // iterate over a set of integers foreach ( iter in ints ) { sum = sum + iter ; } Foreach (mutating collection) var iter , sum : int ; var ints : set [ int ]; // iterate over a set of integers foreach ( iter in ints ) { ints -= ( iter ); } assert sizeof ( ints ) == 0 ; One can mutate the collection represented by expr when iterating over it as the foreach statement enumerates over a clone of the collection (more details in the example below). Foreach (Iterating over map) var key : int ; var intsM : map [ int , int ]; // iterate over a set of integers foreach ( key in keys ( intsM )) { intsM [ key ] = intsM [ key ] + delta ; } One can iterate over the map using keys and values functions . You can find more examples for the foreach statement in the file If Then Else IfThenElse statement in P is just like conditional if statements in other popular programming languages like C, C# or Java. Syntax : if ( expr ) statement (else statement)? expr is the conditional boolean expression and statement could be any P statement. The else block is optional. If Statement if ( x > 10 ) { ... x = x + 20 ; } If Else Statement if ( x > 10 ) { x = 0 ; } else { x = x + 1 ; } Break and Continue break and continue statements in P are just like in other popular programming languages like C, C# or Java to break out of the while loop or to continue to the next iteration of the loop respectively. Break while ( true ) { ... if ( x == 10 ) break ; ... x = x + 1 ; } Continue while ( true ) { ... if ( x == 10 ) // skip the loop when x is 10 continue ; ... } Return return statement in P can be used to return (or return a value) from any function. Return fun IncrementX () { if ( x > MAX_INT ) return ; x = x + 1 ; } Return Value fun Max ( x : int , y : int ) : int { if ( x > y ) return x ; else return y ; } Assignment Value Semantics Recollect that P has value semantics or copy-by-value semantics and does not support any notion of references. Syntax : lvalue = rvalue ; Note that because of value semantics assignment in P copies the value of the rvalue into lvalue . lvalue could be any variable, a tuple field access, or an element in a collection as described in the Grammar above. rvalue could be any expression that evaluates to the same type as lvalue . Assignment is copying! var a : seq [ string ]; var b : seq [ string ]; b += ( 0 , \"b\" ); a = b ; // copy value a += ( 1 , \"a\" ); print a ; // will print [\"b\", \"a\"] print b ; // will print [\"b\"] Assignments .. a = 10 ; s [ i ] = 20 ; tup1 . a = \"x\" ; tup2 . 0 = 10 ; t = foo (); Insert Insert statement is used to insert or add an element into a collection. Syntax : lvalue += ( expr, rvalue ) ; or lvalue += ( rvalue ) ; lvalue is a value of any collection type in P. Insert into a Sequence var sq : seq [ T ]; var x : T , i : int ; // add x into the sequence sq at index i sq += ( i , x ); Index for a sequence The value of index i above should be between 0 <= i <= sizeof(sq) . i = 0 insserts x at the start of sq and i = sizeof(sq) appends x at the end of sq Insert into a map or update map var mp : map [ K , V ]; var x : K , y : V ; // adds (x, y) into the map mp += ( x , y ); // adds (x, y) into the map, if key x already exists then updates its value to y. mp [ x ] = y ; Insert or add into a set var st : set [ T ]; var x : T ; // adds x into the set st st += ( x ); Remove Remove statement is used to remove an element from a collection. Syntax : lvalue -= rvalue ; Remove from a Sequence var sq : seq [ T ]; var i : int ; // remove element at index i in the sequence sq sq -= ( i ); Index for a sequence The value of index i above should be between 0 <= i <= sizeof(sq) - 1 . Remove from a map var mp : map [ K , V ]; var x : K ; // Removes the element (x, _) from the map i.e., removes the element with key x from mp mp -= ( x ); Remove from a set var st : set [ T ]; var x : T ; // removes x from the set st st -= ( x ); New New statement is used to create an instance of a machine in P. Syntax : new iden (rvalue?) ; Create a machine new Client (( id = 1 , server = this )); Creates a dynamic instance of a Client machine and passes the constructor parameter (id = 1, server = this) which is delivered as a payload to the entry function of the start state of the created Client machine. Function Call Function calls in P are similar to any other imperative programming languages. Note that the parameters passed to the functions and the return values are pass-by-value! Syntax : iden ( rvalue? ) ; Function call Foo (); Bar ( 10 , \"haha\" ); Raise The statement raise e, v; terminates the evaluation of the function raising an event e with payload v . The control of the state machine jumps to end of the entry function (popping the function stack if raise is trigger inside a nested function), and the state machine immediately handles the raised event. One can think of raise of an event as throwing an exception which terminates the execution of the function stack and must be immediately handled by the event-handlers defined in that state. Syntax : raise expr (, rvalue)? Raise Event state HandleRequest { entry ( req : tRequest ) { // ohh, this is a Add request and I have a event handler for it if ( req . type == \"Add\" ) raise eAddOperation , req . Transaction ; // terminates function ..... ..... assert req . type != \"Add\" ; // valid } on eAddOperation do ( trans : tTransaction ) { ... } } Non deterministically triggering event handlers internally state DoAddOrRemove { entry { /* I am uncertain, at this point I may want to trigger a Add or Substract event-handler without sending an event to self which will be enqueued and then dequeued in FIFO order I want to immediately execute this handlers before anything else */ if ( $ ) raise eAddOperation , transaction ; // terminates function else raise eRemoveOperation , transaction ; // terminates function assert false ; // valid, as this is unreachable } on eAddOperation do ( trans : tTransaction ) { ... } on eRemoveOperation do ( trans : tTransaction ) { ... } } Send Send statement is one of the most important statements in P as it is used to send messages to other state machines . Send takes as argument a triple send t, e, v , where t is a reference to the target state machine, e is the event sent and v is the associated payload. Syntax : send expr, expr (, rvalue)? ; Sends in P are asynchronous and non-blocking. Statement send t, e, v enqueues the event e with payload v into the target machine t 's message buffer. Send event with payload send server , eRequest , ( source = this , reqId = 0 ); Send event send server , ePing ; Announce Announce is used to publish messages to specification monitors in P. When writing specifications there are instances when we would like to send additional information to monitors that is not captured in the events exchanged between state machines. Recollect that spec monitors in P follow a publish-subscribe model of communication. Each monitor observes a set of events and whenever a machine sends an event that is in the observes set of a monitor then it is synchronously delivered to the monitor. Announce can be used to publish an event to all the monitors that are observing that event. The Two phase commit example provides an use case for announce. Syntax : annouce expr (, rvalue)? ; Announce event spec CheckConvergedState observes eStateUpdate , eSystemConverged { ... } Consider a specification monitor that continuously observes eStateUpdate event to keep track of the system state and then asserts the required property when the system converges. We can use an announce statement to inform the monitor when the system has converged and we should to assert the global specification. announce eSystemConverged, payload; Note Announce only delivers events to specification monitors (not state machines) and hence has no side effect on the system behavior. Announce is used for passing information to the monitors during system execution which the monitors can use to assert global specifications about the system. Goto Goto statement can be used to jump to a particular state. On executing a goto, the state machine exits the current state (terminating the execution of the current function) and enters the target state. The optional payload accompanying the goto statement becomes the input parameter to the entry function of the target state. Syntax : goto iden (, rvalue)? ; Goto state ServicePendingRequests { entry { if ( sizeof ( pendingRequests ) == 0 ) goto Done ; // process requests .... } } state Done { ... } Goto with payload state ServiceRequests { entry ( req : tRequest ) { // process request with some complicated logic ... lastReqId = req . Id ; goto WaitForRequests , lastReqId ; } } state WaitForRequests { entry ( lastReqId : int ) { ... } } Receive Receive statements in P are used to perform blocking await/receive for a set of events inside a function. Syntax : receive { recvCase+ } /* case block inside a receive statement */ recvCase : case eventList : anonFunction Each receive statement can block or wait on a set of events, all other events are automatically deferred by the state machine. On receiving an event that the receive is blocking on (case blocks), the state machine unblocks, executes the corresponding case-handler and resumes executing the next statement after receive. Receive: await single event fun AcquireLock ( lock : machine ) { send lock , eAcquireLock ; receive { case eLockGranted : ( result : tResponse ) { /* case handler */ } } print \"Lock Acquired!\" } Note that when executing the AcquireLock function the state machine blocks at the receive statement, it automatically defers all the events except the eLockGranted event. On receiving the eLockGranted , the case-handler is executed and then the print statement. Receive: await multiple events fun WaitForTime ( timer : Timer , time : int ) { var success : bool ; send timer , eStartTimer , time ; receive { case eTimeOut : { success = true ; } case eStartTimerFailed : { success = false ; } } if ( success ) print \"Successfully waited!\" } Note that when executing the WaitForTime function the state machine blocks at the receive statement, it automatically defers all the events except the eTimeOut and eStartTimerFailed events.","title":"P Statements"},{"location":"manual/statements/#assert","text":"P allows writing local assertions using the assert statement. If the program violates the assertion then a counter example is generated by the P checker. Syntax : assert expr (, expr)? ; The assert statement must have a boolean expression followed by an optional string message that is printed in the error trace. Assert assert ( requestId > 1 ) && ( requestId in allRequestsSet ); Assert that the requestId is always greater than 1 and is in the set of all requests. Assert with Error Message assert x >= 0 , \"Expected x to be always positive\" ; The assert statement can have a string message which is printed in the error trace. Assert with Formatted Error Message assert ( requestId in allRequestsSet ), format ( \"requestId {0} is not in the requests set = {1}\" , requestId , allRequestsSet ); Assert that the requestId is in the set of all requests. You can also provide a formatted string error message to add details to the error message generated.","title":"Assert"},{"location":"manual/statements/#print","text":"Print statements can be used for writing or printing log messages into the error traces (especially for debugging purposes). Syntax : print expr ; The print statement must have an expression of type string . Print Simple Message print \"Hello World!\" ; Print \"Hello World!\" in the execution trace log. Print Formatted String Message x = \"You\" ; print format ( \"Hello World to {0}!!\" , x ); Print \"Hello World to You!!\" in the execution trace log.","title":"Print"},{"location":"manual/statements/#while","text":"While statement in P is just like while loops in other popular programming languages like C, C# or Java. Syntax : while ( expr ) statement expr is the conditional boolean expression and statement could be any P statement. While Loop i = 0 ; while ( i < 10 ) { ... i = i + 1 ; } While loop iterating over collection i = 0 ; while ( i < sizeof ( s )) { ... print s [ i ]; i = i + 1 ; }","title":"While"},{"location":"manual/statements/#foreach","text":"foreach statement can be used to iterate over a collection ( sequence or set ) in P. Syntax : foreach (iden in expr) statement iden is the name of the variable that store the element from the collection during iterations. expr represents the collection over which we want to iterate and must be of type seq or set . Type of iden must be same as the elements type in the collection. Note that variable iden must already be declared, and in each iteration, an element is assigned to this variable at the start of the iteration (no ordering guarantees). Also, one can mutate the collection represented by expr when iterating over it as the foreach statement enumerates over a clone of the collection (more details in the example below). Foreach (set) var iter , sum : int ; var ints : set [ int ]; // iterate over a set of integers foreach ( iter in ints ) { sum = sum + iter ; } Foreach (mutating collection) var iter , sum : int ; var ints : set [ int ]; // iterate over a set of integers foreach ( iter in ints ) { ints -= ( iter ); } assert sizeof ( ints ) == 0 ; One can mutate the collection represented by expr when iterating over it as the foreach statement enumerates over a clone of the collection (more details in the example below). Foreach (Iterating over map) var key : int ; var intsM : map [ int , int ]; // iterate over a set of integers foreach ( key in keys ( intsM )) { intsM [ key ] = intsM [ key ] + delta ; } One can iterate over the map using keys and values functions . You can find more examples for the foreach statement in the file","title":"Foreach"},{"location":"manual/statements/#if-then-else","text":"IfThenElse statement in P is just like conditional if statements in other popular programming languages like C, C# or Java. Syntax : if ( expr ) statement (else statement)? expr is the conditional boolean expression and statement could be any P statement. The else block is optional. If Statement if ( x > 10 ) { ... x = x + 20 ; } If Else Statement if ( x > 10 ) { x = 0 ; } else { x = x + 1 ; }","title":"If Then Else"},{"location":"manual/statements/#break-and-continue","text":"break and continue statements in P are just like in other popular programming languages like C, C# or Java to break out of the while loop or to continue to the next iteration of the loop respectively. Break while ( true ) { ... if ( x == 10 ) break ; ... x = x + 1 ; } Continue while ( true ) { ... if ( x == 10 ) // skip the loop when x is 10 continue ; ... }","title":"Break and Continue"},{"location":"manual/statements/#return","text":"return statement in P can be used to return (or return a value) from any function. Return fun IncrementX () { if ( x > MAX_INT ) return ; x = x + 1 ; } Return Value fun Max ( x : int , y : int ) : int { if ( x > y ) return x ; else return y ; }","title":"Return"},{"location":"manual/statements/#assignment","text":"Value Semantics Recollect that P has value semantics or copy-by-value semantics and does not support any notion of references. Syntax : lvalue = rvalue ; Note that because of value semantics assignment in P copies the value of the rvalue into lvalue . lvalue could be any variable, a tuple field access, or an element in a collection as described in the Grammar above. rvalue could be any expression that evaluates to the same type as lvalue . Assignment is copying! var a : seq [ string ]; var b : seq [ string ]; b += ( 0 , \"b\" ); a = b ; // copy value a += ( 1 , \"a\" ); print a ; // will print [\"b\", \"a\"] print b ; // will print [\"b\"] Assignments .. a = 10 ; s [ i ] = 20 ; tup1 . a = \"x\" ; tup2 . 0 = 10 ; t = foo ();","title":"Assignment"},{"location":"manual/statements/#insert","text":"Insert statement is used to insert or add an element into a collection. Syntax : lvalue += ( expr, rvalue ) ; or lvalue += ( rvalue ) ; lvalue is a value of any collection type in P. Insert into a Sequence var sq : seq [ T ]; var x : T , i : int ; // add x into the sequence sq at index i sq += ( i , x ); Index for a sequence The value of index i above should be between 0 <= i <= sizeof(sq) . i = 0 insserts x at the start of sq and i = sizeof(sq) appends x at the end of sq Insert into a map or update map var mp : map [ K , V ]; var x : K , y : V ; // adds (x, y) into the map mp += ( x , y ); // adds (x, y) into the map, if key x already exists then updates its value to y. mp [ x ] = y ; Insert or add into a set var st : set [ T ]; var x : T ; // adds x into the set st st += ( x );","title":"Insert"},{"location":"manual/statements/#remove","text":"Remove statement is used to remove an element from a collection. Syntax : lvalue -= rvalue ; Remove from a Sequence var sq : seq [ T ]; var i : int ; // remove element at index i in the sequence sq sq -= ( i ); Index for a sequence The value of index i above should be between 0 <= i <= sizeof(sq) - 1 . Remove from a map var mp : map [ K , V ]; var x : K ; // Removes the element (x, _) from the map i.e., removes the element with key x from mp mp -= ( x ); Remove from a set var st : set [ T ]; var x : T ; // removes x from the set st st -= ( x );","title":"Remove"},{"location":"manual/statements/#new","text":"New statement is used to create an instance of a machine in P. Syntax : new iden (rvalue?) ; Create a machine new Client (( id = 1 , server = this )); Creates a dynamic instance of a Client machine and passes the constructor parameter (id = 1, server = this) which is delivered as a payload to the entry function of the start state of the created Client machine.","title":"New"},{"location":"manual/statements/#function-call","text":"Function calls in P are similar to any other imperative programming languages. Note that the parameters passed to the functions and the return values are pass-by-value! Syntax : iden ( rvalue? ) ; Function call Foo (); Bar ( 10 , \"haha\" );","title":"Function Call"},{"location":"manual/statements/#raise","text":"The statement raise e, v; terminates the evaluation of the function raising an event e with payload v . The control of the state machine jumps to end of the entry function (popping the function stack if raise is trigger inside a nested function), and the state machine immediately handles the raised event. One can think of raise of an event as throwing an exception which terminates the execution of the function stack and must be immediately handled by the event-handlers defined in that state. Syntax : raise expr (, rvalue)? Raise Event state HandleRequest { entry ( req : tRequest ) { // ohh, this is a Add request and I have a event handler for it if ( req . type == \"Add\" ) raise eAddOperation , req . Transaction ; // terminates function ..... ..... assert req . type != \"Add\" ; // valid } on eAddOperation do ( trans : tTransaction ) { ... } } Non deterministically triggering event handlers internally state DoAddOrRemove { entry { /* I am uncertain, at this point I may want to trigger a Add or Substract event-handler without sending an event to self which will be enqueued and then dequeued in FIFO order I want to immediately execute this handlers before anything else */ if ( $ ) raise eAddOperation , transaction ; // terminates function else raise eRemoveOperation , transaction ; // terminates function assert false ; // valid, as this is unreachable } on eAddOperation do ( trans : tTransaction ) { ... } on eRemoveOperation do ( trans : tTransaction ) { ... } }","title":"Raise"},{"location":"manual/statements/#send","text":"Send statement is one of the most important statements in P as it is used to send messages to other state machines . Send takes as argument a triple send t, e, v , where t is a reference to the target state machine, e is the event sent and v is the associated payload. Syntax : send expr, expr (, rvalue)? ; Sends in P are asynchronous and non-blocking. Statement send t, e, v enqueues the event e with payload v into the target machine t 's message buffer. Send event with payload send server , eRequest , ( source = this , reqId = 0 ); Send event send server , ePing ;","title":"Send"},{"location":"manual/statements/#announce","text":"Announce is used to publish messages to specification monitors in P. When writing specifications there are instances when we would like to send additional information to monitors that is not captured in the events exchanged between state machines. Recollect that spec monitors in P follow a publish-subscribe model of communication. Each monitor observes a set of events and whenever a machine sends an event that is in the observes set of a monitor then it is synchronously delivered to the monitor. Announce can be used to publish an event to all the monitors that are observing that event. The Two phase commit example provides an use case for announce. Syntax : annouce expr (, rvalue)? ; Announce event spec CheckConvergedState observes eStateUpdate , eSystemConverged { ... } Consider a specification monitor that continuously observes eStateUpdate event to keep track of the system state and then asserts the required property when the system converges. We can use an announce statement to inform the monitor when the system has converged and we should to assert the global specification. announce eSystemConverged, payload; Note Announce only delivers events to specification monitors (not state machines) and hence has no side effect on the system behavior. Announce is used for passing information to the monitors during system execution which the monitors can use to assert global specifications about the system.","title":"Announce"},{"location":"manual/statements/#goto","text":"Goto statement can be used to jump to a particular state. On executing a goto, the state machine exits the current state (terminating the execution of the current function) and enters the target state. The optional payload accompanying the goto statement becomes the input parameter to the entry function of the target state. Syntax : goto iden (, rvalue)? ; Goto state ServicePendingRequests { entry { if ( sizeof ( pendingRequests ) == 0 ) goto Done ; // process requests .... } } state Done { ... } Goto with payload state ServiceRequests { entry ( req : tRequest ) { // process request with some complicated logic ... lastReqId = req . Id ; goto WaitForRequests , lastReqId ; } } state WaitForRequests { entry ( lastReqId : int ) { ... } }","title":"Goto"},{"location":"manual/statements/#receive","text":"Receive statements in P are used to perform blocking await/receive for a set of events inside a function. Syntax : receive { recvCase+ } /* case block inside a receive statement */ recvCase : case eventList : anonFunction Each receive statement can block or wait on a set of events, all other events are automatically deferred by the state machine. On receiving an event that the receive is blocking on (case blocks), the state machine unblocks, executes the corresponding case-handler and resumes executing the next statement after receive. Receive: await single event fun AcquireLock ( lock : machine ) { send lock , eAcquireLock ; receive { case eLockGranted : ( result : tResponse ) { /* case handler */ } } print \"Lock Acquired!\" } Note that when executing the AcquireLock function the state machine blocks at the receive statement, it automatically defers all the events except the eLockGranted event. On receiving the eLockGranted , the case-handler is executed and then the print statement. Receive: await multiple events fun WaitForTime ( timer : Timer , time : int ) { var success : bool ; send timer , eStartTimer , time ; receive { case eTimeOut : { success = true ; } case eStartTimerFailed : { success = false ; } } if ( success ) print \"Successfully waited!\" } Note that when executing the WaitForTime function the state machine blocks at the receive statement, it automatically defers all the events except the eTimeOut and eStartTimerFailed events.","title":"Receive"},{"location":"manual/testcases/","text":"P Test cases are used to define different finite scenarios under which we would like to check the correctness of our system. P Test Cases Grammar testcase | test iden [main=iden] : modExpr ; # TestDecl ; modExpr represent the P module defined using the module expressions described in P Module System Test Case Declaration P allows programmers to write different scenarios under which we would like to check the correctness of the module (or system) under test. More concretely, the system module to be tested is unioned with different environment modules (or test harnesses/drivers) to check its correctness for different inputs scenarios generated by the environment modules. Each test case is automatically discharged by the P Checker. Syntax: : test tName [main=mName] : module_under_test ; tName is the name of the test case, mName is the name of the main machine where the execution of the system starts, and module_under_test is the module to be tested (manual: modules in P ). Properties checked for a Test Case For each testcase, the P checker by default asserts that for each execution of the system (i.e., module_under_test ): (1) there are no unhandled event exceptions; (2) all local assertions in the program hold; (3) there are no deadlocks; and finally (4) based on the specification monitors that are attached to the module, these safety and liveness properties asserted by the monitors always hold.","title":"P Test cases"},{"location":"manual/testcases/#test-case-declaration","text":"P allows programmers to write different scenarios under which we would like to check the correctness of the module (or system) under test. More concretely, the system module to be tested is unioned with different environment modules (or test harnesses/drivers) to check its correctness for different inputs scenarios generated by the environment modules. Each test case is automatically discharged by the P Checker. Syntax: : test tName [main=mName] : module_under_test ; tName is the name of the test case, mName is the name of the main machine where the execution of the system starts, and module_under_test is the module to be tested (manual: modules in P ). Properties checked for a Test Case For each testcase, the P checker by default asserts that for each execution of the system (i.e., module_under_test ): (1) there are no unhandled event exceptions; (2) all local assertions in the program hold; (3) there are no deadlocks; and finally (4) based on the specification monitors that are attached to the module, these safety and liveness properties asserted by the monitors always hold.","title":"Test Case Declaration"},{"location":"old/advanced/debuggingerror/","text":"As described in the using P compiler and checker section, running the following command for the ClientServer example finds an error. pmc <Path>/ClientServer.dll \\ -m PImplementation.tcSingleClientAbstractServer.Execute \\ -i 100 Expected Output pmc <Path>/ClientServer.dll -m PImplementation.tcSingleClientAbstractServer.Execute -i 100 . Testing <Path>/ClientServer.dll ... Method PImplementation.tcSingleClientAbstractServer.Execute Starting TestingProcessScheduler in process 72578 ... Created '1' testing task. ... Task 0 is using 'random' strategy (seed:574049731). ..... Iteration #1 ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing /POutput/netcoreapp3.1/Output/ClientServer.dll/CoyoteOutput/ClientServer_0_0.txt ..... Writing /POutput/netcoreapp3.1/Output/ClientServer.dll/CoyoteOutput/ClientServer_0_0.schedule ... Elapsed 0.1971223 sec. ... Testing statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 1 schedule: 1 fair and 0 unfair. ..... Found 100.00% buggy schedules. ..... Number of scheduling points in fair terminating schedules: 132 (min), 132 (avg), 132 (max). ... Elapsed 0.3081316 sec. . Done The P checker on finding a bug generates two artifacts (highlighted in the expected output above): (1) a textual trace file (e.g., ClientServer_0_0.txt ) that has the readable error trace representing the sequence of steps from the intial state to the error state. (2) a schedule file (e.g., ClientServer_0_0.schedule ) that can be used to replay the error trace and single step through the P program with the generated error trace for debugging. Error Trace The *.txt file contains a textual error trace representing the sequence of steps (i.e, messages sent, messages received, machines created) from the initial state to the final error state. In the end of the error trace is the final error message, for example, in the case of ClientServer example above, you must see the following in the end of the error trace. <ErrorLog> Assertion Failed: Bank must accept the with draw request for 1, bank balance is 11! In most cases, you can ignore the stack trace and information below the ErrorLog . Error Schedule (single stepping through error trace) In certain cases, the trace log is not enough for debugging the issue and we would like to single step through the error state and look at the internal state of the state machines that is not captured in the trace log. We present the step-by-step guide to show how we can use the .schedule file to single step through the C# representation of the P program. [Step 0]: Install Rider (or Visual Studio) Before starting, we recommend that you have Rider installed on your machine, we will use Rider's C# debugger. [Step 1]: Update the Test.cs file On compiling any P project, the compiler generates two files a Test.cs file and a C# project *.csproj file. For debugging the error trace, you must open the generated csproj file (its generally, <ProjectName>.csproj ) using Rider and then edit the Test.cs file as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class _TestRegression { public static void Main ( string [] args ) { Configuration configuration = Configuration . Create (); configuration . WithVerbosityEnabled ( true ); // update the path to the schedule file. string schedule = File . ReadAllText ( \"absolute path to *.schedule file\" ); configuration . WithReplayStrategy ( schedule ); TestingEngine engine = TestingEngine . Create ( configuration , ( Action < IActorRuntime >) PImplementation .< Name of the test case >. Execute ); engine . Run (); string bug = engine . TestReport . BugReports . FirstOrDefault (); if ( bug != null ) { Console . WriteLine ( bug ); } } } Update the path of .schedule file : Edit the Test.cs file and update the line 7 above with the absolute path to the .schedule file that represents the error schedule you want to debug. Update the test case name : Update the test case name on line 9 above. In our case, for the clientserver example it would become PImplementation.tcSingleClientAbstractServer.Execute . [Step 2]: Add breakpoints to start debugging You must next add the necessary break points in the Generated C# code. If you want to stop the execution at a particular P function/handler, locate that function in the generated code and add a break point. Now, you can start debugging using Rider just like you would debug anyother C# or Java program. For example, you can add a breakpoint at line 904 in the generated code ClientServer.cs in PGenerated folder to hit the assertion that failed. String.Format(\"Bank must accept the with draw request for {0}, bank balance is {1}!\",TMP_tmp38,TMP_tmp40); Replaying the Error Schedule One can also replay the error schedule using commandline and enabling verbose feature to dump out the error trace on the commandline. pmc <path to dll>.dll --schedule <buggy>.schedule -m <testcaseName> -v For example, pmc ClientServer.dll --schedule ClientServer_0_0.schedule -m PImplementation.tcSingleClientAbstractServer.Execute -v","title":"Debuggingerror"},{"location":"old/advanced/debuggingerror/#error-trace","text":"The *.txt file contains a textual error trace representing the sequence of steps (i.e, messages sent, messages received, machines created) from the initial state to the final error state. In the end of the error trace is the final error message, for example, in the case of ClientServer example above, you must see the following in the end of the error trace. <ErrorLog> Assertion Failed: Bank must accept the with draw request for 1, bank balance is 11! In most cases, you can ignore the stack trace and information below the ErrorLog .","title":"Error Trace"},{"location":"old/advanced/debuggingerror/#error-schedule-single-stepping-through-error-trace","text":"In certain cases, the trace log is not enough for debugging the issue and we would like to single step through the error state and look at the internal state of the state machines that is not captured in the trace log. We present the step-by-step guide to show how we can use the .schedule file to single step through the C# representation of the P program.","title":"Error Schedule (single stepping through error trace)"},{"location":"old/advanced/debuggingerror/#step-0-install-rider-or-visual-studio","text":"Before starting, we recommend that you have Rider installed on your machine, we will use Rider's C# debugger.","title":"[Step 0]: Install Rider (or Visual Studio)"},{"location":"old/advanced/debuggingerror/#step-1-update-the-testcs-file","text":"On compiling any P project, the compiler generates two files a Test.cs file and a C# project *.csproj file. For debugging the error trace, you must open the generated csproj file (its generally, <ProjectName>.csproj ) using Rider and then edit the Test.cs file as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class _TestRegression { public static void Main ( string [] args ) { Configuration configuration = Configuration . Create (); configuration . WithVerbosityEnabled ( true ); // update the path to the schedule file. string schedule = File . ReadAllText ( \"absolute path to *.schedule file\" ); configuration . WithReplayStrategy ( schedule ); TestingEngine engine = TestingEngine . Create ( configuration , ( Action < IActorRuntime >) PImplementation .< Name of the test case >. Execute ); engine . Run (); string bug = engine . TestReport . BugReports . FirstOrDefault (); if ( bug != null ) { Console . WriteLine ( bug ); } } } Update the path of .schedule file : Edit the Test.cs file and update the line 7 above with the absolute path to the .schedule file that represents the error schedule you want to debug. Update the test case name : Update the test case name on line 9 above. In our case, for the clientserver example it would become PImplementation.tcSingleClientAbstractServer.Execute .","title":"[Step 1]: Update the Test.cs file"},{"location":"old/advanced/debuggingerror/#step-2-add-breakpoints-to-start-debugging","text":"You must next add the necessary break points in the Generated C# code. If you want to stop the execution at a particular P function/handler, locate that function in the generated code and add a break point. Now, you can start debugging using Rider just like you would debug anyother C# or Java program. For example, you can add a breakpoint at line 904 in the generated code ClientServer.cs in PGenerated folder to hit the assertion that failed. String.Format(\"Bank must accept the with draw request for {0}, bank balance is {1}!\",TMP_tmp38,TMP_tmp40);","title":"[Step 2]: Add breakpoints to start debugging"},{"location":"old/advanced/debuggingerror/#replaying-the-error-schedule","text":"One can also replay the error schedule using commandline and enabling verbose feature to dump out the error trace on the commandline. pmc <path to dll>.dll --schedule <buggy>.schedule -m <testcaseName> -v For example, pmc ClientServer.dll --schedule ClientServer_0_0.schedule -m PImplementation.tcSingleClientAbstractServer.Execute -v","title":"Replaying the Error Schedule"},{"location":"old/getstarted/install/","text":"Installing P P is built to be cross-platform and can be used on MacOS, Linux, and Windows. We provide a step-by-step guide for installing P along with its required dependencies. After each step, please use the troubleshooting check to ensure that each installation step succeeded. [Step 1] Install .Net Core SDK The P compiler and checker are implemented in C# and hence the tool chain requires dotnet . P currently uses the specific version of .Net SDK 3.1 . To install .Net Core 3.1 SDK use: MacOS Installing .Net SDK on MacOS using Homebrew ( details ) brew tap isen-ng/dotnet-sdk-versions brew install --cask dotnet-sdk3-1-400 Dont have Homebrew? Install directly using the installer . Ubuntu Installing .Net SDK on Ubuntu ( details ) wget https://packages.microsoft.com/config/ubuntu/21.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb rm packages-microsoft-prod.deb sudo apt-get update; \\ sudo apt-get install -y apt-transport-https && \\ sudo apt-get update && \\ sudo apt-get install -y dotnet-sdk-3.1 Amazon Linux Installing .Net SDK on Amazon Linux ( details ) sudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm sudo yum install dotnet-sdk-3.1 Windows Installing .Net SDK on Windows using the installer ( details ) Troubleshoot: Confirm that dotnet is correctly installed on your machine. dotnet --list-sdks You must see an SDK with 3.1.* dotnet version installed. If you get dotnet command not found error, mostly likely, you need to add the path to dotnet in your PATH . [Step 2] Install Java Runtime P compiler uses ANTLR parser and hence requires java . If you already have Java installed , ignore this step. To install Java use: MacOS Installing Java on MacOS using Homebrew ( details ) brew install java Dont have Homebrew? Directly use installer . Ubuntu Installing Java on Ubuntu ( details ) sudo apt install default-jre Amazon Linux Installing Java 11 on Amazon Linux (you can use any version of java >= 9) sudo yum install java-11-amazon-corretto-devel Windows Installing Java on Windows ( details ) Troubleshoot: Confirm that java is correctly installed on your machine. java -version If you get java command not found error, mostly likely, you need to add the path to java in your PATH . [Step 3] Install P Compiler Install the P compiler as a dotnet tool using the following command: dotnet tool install --global P Troubleshoot: Confirm that pc is correctly installed on your machine After installation, run which pc and it should show: which pc /Users/<user>/.dotnet/tools/pc If not, add $HOME/.dotnet/tools to $PATH in your .bash_profile (or equivalent) and try again after restarting the shell. If you are getting the error that the pc command is not found, it is most likely that $HOME/.dotnet/tools is not in your PATH . Updating P Compiler You can update the version of P compiler by running the following command: dotnet tool update --global P [Step 4] Install P Checker The current P checker depends on Coyote (previously P# ) Install the Coyote version 1.0.5 using the following command: dotnet tool install --global Microsoft.Coyote.CLI --version 1.0.5 Troubleshoot: Confirm that coyote is correctly installed on your machine After installation, run which coyote and it should show: which coyote coyote is /Users/<user>/.dotnet/tools/coyote If not, add $HOME/.dotnet/tools to $PATH in your .bash_profile (or equivalent) and try again after restarting the shell. If you are getting an error that coyote command not found, its most likely that $HOME/.dotnet/tools is not in your PATH . We highly recommend that you create the following alias as we use it in the rest of tutorials and getting started guide: On MacOS or Linux Add following alias to the bash profile ( ~/.bash_profile or the equivalent on your system) so that you can invoke the P checker ( pmc ) directly. alias pmc = 'coyote test' On Windows We recommend that you add the following to the Microsoft.PowerShell_profile normally found in D:\\Users\\<username>\\Documents\\WindowsPowerShell function pmc { coyote test $args } [Step 5] Recommended IDE (Optional) For developing P programs, we recommend using IntelliJ IDEA as we support basic P syntax highlighting for IntelliJ. There is also a plugin for the Vim editor , which IntelliJ will automatically use when Vim emulation is enabled. For debugging generated C# code, we recommend using Rider for Mac/Linux or Visual Studio 2019 for Windows. For debugging generated Java code, we recommend using IntelliJ IDEA Using P Great ! You are all set to compile and test your first P program !","title":"Installing P"},{"location":"old/getstarted/install/#installing-p","text":"P is built to be cross-platform and can be used on MacOS, Linux, and Windows. We provide a step-by-step guide for installing P along with its required dependencies. After each step, please use the troubleshooting check to ensure that each installation step succeeded.","title":"Installing P"},{"location":"old/getstarted/install/#step-1-install-net-core-sdk","text":"The P compiler and checker are implemented in C# and hence the tool chain requires dotnet . P currently uses the specific version of .Net SDK 3.1 . To install .Net Core 3.1 SDK use: MacOS Installing .Net SDK on MacOS using Homebrew ( details ) brew tap isen-ng/dotnet-sdk-versions brew install --cask dotnet-sdk3-1-400 Dont have Homebrew? Install directly using the installer . Ubuntu Installing .Net SDK on Ubuntu ( details ) wget https://packages.microsoft.com/config/ubuntu/21.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb rm packages-microsoft-prod.deb sudo apt-get update; \\ sudo apt-get install -y apt-transport-https && \\ sudo apt-get update && \\ sudo apt-get install -y dotnet-sdk-3.1 Amazon Linux Installing .Net SDK on Amazon Linux ( details ) sudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm sudo yum install dotnet-sdk-3.1 Windows Installing .Net SDK on Windows using the installer ( details ) Troubleshoot: Confirm that dotnet is correctly installed on your machine. dotnet --list-sdks You must see an SDK with 3.1.* dotnet version installed. If you get dotnet command not found error, mostly likely, you need to add the path to dotnet in your PATH .","title":"[Step 1] Install .Net Core SDK"},{"location":"old/getstarted/install/#step-2-install-java-runtime","text":"P compiler uses ANTLR parser and hence requires java . If you already have Java installed , ignore this step. To install Java use: MacOS Installing Java on MacOS using Homebrew ( details ) brew install java Dont have Homebrew? Directly use installer . Ubuntu Installing Java on Ubuntu ( details ) sudo apt install default-jre Amazon Linux Installing Java 11 on Amazon Linux (you can use any version of java >= 9) sudo yum install java-11-amazon-corretto-devel Windows Installing Java on Windows ( details ) Troubleshoot: Confirm that java is correctly installed on your machine. java -version If you get java command not found error, mostly likely, you need to add the path to java in your PATH .","title":"[Step 2] Install Java Runtime"},{"location":"old/getstarted/install/#step-3-install-p-compiler","text":"Install the P compiler as a dotnet tool using the following command: dotnet tool install --global P Troubleshoot: Confirm that pc is correctly installed on your machine After installation, run which pc and it should show: which pc /Users/<user>/.dotnet/tools/pc If not, add $HOME/.dotnet/tools to $PATH in your .bash_profile (or equivalent) and try again after restarting the shell. If you are getting the error that the pc command is not found, it is most likely that $HOME/.dotnet/tools is not in your PATH . Updating P Compiler You can update the version of P compiler by running the following command: dotnet tool update --global P","title":"[Step 3] Install P Compiler"},{"location":"old/getstarted/install/#step-4-install-p-checker","text":"The current P checker depends on Coyote (previously P# ) Install the Coyote version 1.0.5 using the following command: dotnet tool install --global Microsoft.Coyote.CLI --version 1.0.5 Troubleshoot: Confirm that coyote is correctly installed on your machine After installation, run which coyote and it should show: which coyote coyote is /Users/<user>/.dotnet/tools/coyote If not, add $HOME/.dotnet/tools to $PATH in your .bash_profile (or equivalent) and try again after restarting the shell. If you are getting an error that coyote command not found, its most likely that $HOME/.dotnet/tools is not in your PATH . We highly recommend that you create the following alias as we use it in the rest of tutorials and getting started guide: On MacOS or Linux Add following alias to the bash profile ( ~/.bash_profile or the equivalent on your system) so that you can invoke the P checker ( pmc ) directly. alias pmc = 'coyote test' On Windows We recommend that you add the following to the Microsoft.PowerShell_profile normally found in D:\\Users\\<username>\\Documents\\WindowsPowerShell function pmc { coyote test $args }","title":"[Step 4] Install P Checker"},{"location":"old/getstarted/install/#step-5-recommended-ide-optional","text":"For developing P programs, we recommend using IntelliJ IDEA as we support basic P syntax highlighting for IntelliJ. There is also a plugin for the Vim editor , which IntelliJ will automatically use when Vim emulation is enabled. For debugging generated C# code, we recommend using Rider for Mac/Linux or Visual Studio 2019 for Windows. For debugging generated Java code, we recommend using IntelliJ IDEA","title":"[Step 5] Recommended IDE (Optional)"},{"location":"old/getstarted/install/#using-p","text":"Great ! You are all set to compile and test your first P program !","title":"Using P"},{"location":"old/getstarted/usingP/","text":"Using P Compiler and Checker Before moving forward, we assume that you have successfully installed the P Compiler and Checker and the Syntax highlighting plugin . We introduce the P language syntax and semantics in details in the Tutorials and Language Manual . In this section, we provide an overview of the steps involved in compiling and testing a P program using the client server example in Tutorials. Get the Client Server Example Locally We will use the ClientServer example from Tutorial folder in P repository to describe the process of compiling and testing a P program. Please clone the P repo and navigate to the ClientServer example in Tutorial. Clone P Repo locally: git clone https://github.com/p-org/P.git Navigate to the ClientServer examples folder: cd <P cloned folder>/Tutorial/1_ClientServer Compiling a P program There are two ways of compiling a P program: Using a P project file ( *.pproj ) to provides all the required inputs to the compiler or Passing all the P files ( *.p ) along with other options (e.g., -generate ) as commandline arguments to the compiler. Recommendation We recommend using the P project files to compile a P program. P Compiler commandline options: The P compiler provides the following commandline options: ------------------------------------------ Recommended usage: >> pc -proj:<.pproj file> ------------------------------------------ Optional usage: >> pc file1.p [ file2.p ... ][ options ] options: -t: [ target project name ] -- project name ( as well as the generated file ) if not supplied, use file1 -outputDir: [ path ] -- where to write the generated files -aspectOutputDir: [ path ] -- where to write the generated aspectj files if not supplied, use outputDir -generate: [ C,CSharp,RVM ] -- select a target language to generate C : generate C code CSharp : generate C# code RVM : generate Monitor code -h, -help, --help -- display this help message ------------------------------------------ Compile using the P Project Compiling the ClientServer project using the P Project file: pc -proj:ClientServer.pproj Expected Output $ pc -proj:ClientServer.pproj ---------------------------------------- ==== Loading project file: ClientServer.pproj ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Server.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Client.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/AbstractBankServer.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/ClientServerModules.p ....... includes p file: P/Tutorial/1_ClientServer/PSpec/BankBalanceCorrect.p ....... includes p file: P/Tutorial/1_ClientServer/PTst/TestDriver.p ....... includes p file: /Tutorial/1_ClientServer/PTst/Testscript.p ---------------------------------------- ---------------------------------------- Parsing .. Type checking ... Code generation .... Generated ClientServer.cs ---------------------------------------- Compiling ClientServer.csproj .. Microsoft (R) Build Engine version 16.10.2+857e5a733 for .NET Copyright (C) Microsoft Corporation. All rights reserved. Determining projects to restore... All projects are up-to-date for restore. ClientServer -> P/Tutorial/1_ClientServer/POutput/netcoreapp3.1/ClientServer.dll Build succeeded. 0 Warning(s) 0 Error(s) ---------------------------------------- P Project File Details The P compiler does not support advanced project management features like separate compilation and dependency analysis ( coming soon ). The current project file interface is a simple mechanism to provide all the required inputs to the compiler in an XML format ( ClientServer.pproj ). <!-- P Project file for the Client Server example --> <Project> <ProjectName> ClientServer </ProjectName> <InputFiles> <PFile> ./PSrc/ </PFile> <PFile> ./PSpec/ </PFile> <PFile> ./PTst/ </PFile> </InputFiles> <OutputDir> ./PGenerated/ </OutputDir> </Project> The <InputFiles> block provides all the P files that must be compiled together for this project. In <PFile> one can either specify the path to a P file or to a folder and the P compiler includes all the *.p files in the folder during compilation. The <ProjectName> block provides the name for the project which is used as the output file name for the generated code. The <OutputDir> block provides the output directory for the generated code. Finally, the <IncludeProject> block provides a path to other P projects that must be included as dependencies during compilation. The P compiler simply recursively copies all the P files in the dependency projects (transitively including all P files in dependent projects) and compiles them together. This feature provides a way to split the P models for a large system into sub projects that can share models. Compile P files directly Compiling the ClientServer program by passing all the required inputs as commandline arguments: pc PSpec/*.p PSrc/*.p PTst/*.p \\ -generate:csharp -outputDir:PGenerated -target:ClientServer Expected Output ---------------------------------------- ....... includes p file: P/Tutorial/1_ClientServer/PSpec/BankBalanceCorrect.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/AbstractBankServer.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Client.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/ClientServerModules.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Server.p ....... includes p file: P/Tutorial/1_ClientServer/PTst/TestDriver.p ....... includes p file: P/Tutorial/1_ClientServer/PTst/Testscript.p ---------------------------------------- ---------------------------------------- Parsing .. Type checking ... Code generation .... Generated ClientServer.cs ---------------------------------------- Compiling ClientServer.csproj .. Microsoft (R) Build Engine version 16.10.2+857e5a733 for .NET Copyright (C) Microsoft Corporation. All rights reserved. Determining projects to restore... Restored P/Tutorial/1_ClientServer/PGenerated/ClientServer.csproj (in 602 ms). ClientServer -> P/Tutorial/1_ClientServer/PGenerated/POutput/netcoreapp3.1/ClientServer.dll Build succeeded. 0 Warning(s) 0 Error(s) Testing a P program Compiling the ClientServer program generates a ClientServer.dll , this dll is the C# representation of the P program. The P Checker takes as input this dll and systematically explores behaviors of the program for the specified test case. The path to the dll is present in the generated compilation output, check for line: ClientServer -> <Path>/ClientServer.dll You can get the list of test cases defined in the P program by passing the generated dll to the P Checker: pmc <Path>/ClientServer.dll Expected Output: pmc <Path>/ClientServer.dll Provide /method or -m flag to qualify the test method name you wish to use. Possible options are:: PImplementation.tcSingleClient.Execute PImplementation.tcMultipleClients.Execute PImplementation.tcSingleClientAbstractServer.Execute There are three test cases defined in the ClientServer P project and you can specify which test case to run by using the -m or /method parameter along with the -i parameter to specify how many different schedules to explore when running this test case (by default the checker explores a single schedule). For complex systems, running for 100,000 schedules typically finds most of the easy to find bugs before running the checker on a distributed cluster to explore billions of schedules and rule out deep bugs in the system. So to run the tcSingleClient test case for 100 schedules, we can use the following command: pmc <Path>/ClientServer.dll \\ -m PImplementation.tcSingleClient.Execute \\ -i 100 Expected Output . Testing <Path>/ClientServer.dll ... Method PImplementation.tcSingleClient.Execute Starting TestingProcessScheduler in process 72009 ... Created '1' testing task. ... Task 0 is using 'random' strategy (seed:3365663330). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ..... Iteration #9 ..... Iteration #10 ..... Iteration #20 ..... Iteration #30 ..... Iteration #40 ..... Iteration #50 ..... Iteration #60 ..... Iteration #70 ..... Iteration #80 ..... Iteration #90 ..... Iteration #100 ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 100 schedules: 100 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 11 (min), 147 (avg), 680 (max). ... Elapsed 0.8209742 sec. . Done There is a known bug in the ClientServer example (explained in the Tutorials) which is caught by the tcSingleClientAbstractServer test case. Run command: pmc <Path>/ClientServer.dll \\ -m PImplementation.tcSingleClientAbstractServer.Execute \\ -i 100 Expected Output pmc <Path>/ClientServer.dll -m PImplementation.tcSingleClientAbstractServer.Execute -i 100 . Testing <Path>/ClientServer.dll ... Method PImplementation.tcSingleClientAbstractServer.Execute Starting TestingProcessScheduler in process 72578 ... Created '1' testing task. ... Task 0 is using 'random' strategy (seed:574049731). ..... Iteration #1 ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing /POutput/netcoreapp3.1/Output/ClientServer.dll/CoyoteOutput/ClientServer_0_0.txt ..... Writing /POutput/netcoreapp3.1/Output/ClientServer.dll/CoyoteOutput/ClientServer_0_0.schedule ... Elapsed 0.1971223 sec. ... Testing statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 1 schedule: 1 fair and 0 unfair. ..... Found 100.00% buggy schedules. ..... Number of scheduling points in fair terminating schedules: 132 (min), 132 (avg), 132 (max). ... Elapsed 0.3081316 sec. . Done The P checker on finding a bug generates two artifacts (highlighted in the expected output above): (1) a textual trace file (e.g., ClientServer_0_0.txt ) that has the readable error trace representing the sequence of steps from the intial state to the error state; (2) a schedule file (e.g., ClientServer_0_0.schedule ) that can be used to replay the error trace and single step through the P program with the generated error trace for debugging (more details about debugging P error traces: here ).","title":"Using P Compiler and Checker"},{"location":"old/getstarted/usingP/#using-p-compiler-and-checker","text":"Before moving forward, we assume that you have successfully installed the P Compiler and Checker and the Syntax highlighting plugin . We introduce the P language syntax and semantics in details in the Tutorials and Language Manual . In this section, we provide an overview of the steps involved in compiling and testing a P program using the client server example in Tutorials. Get the Client Server Example Locally We will use the ClientServer example from Tutorial folder in P repository to describe the process of compiling and testing a P program. Please clone the P repo and navigate to the ClientServer example in Tutorial. Clone P Repo locally: git clone https://github.com/p-org/P.git Navigate to the ClientServer examples folder: cd <P cloned folder>/Tutorial/1_ClientServer","title":"Using P Compiler and Checker"},{"location":"old/getstarted/usingP/#compiling-a-p-program","text":"There are two ways of compiling a P program: Using a P project file ( *.pproj ) to provides all the required inputs to the compiler or Passing all the P files ( *.p ) along with other options (e.g., -generate ) as commandline arguments to the compiler. Recommendation We recommend using the P project files to compile a P program. P Compiler commandline options: The P compiler provides the following commandline options: ------------------------------------------ Recommended usage: >> pc -proj:<.pproj file> ------------------------------------------ Optional usage: >> pc file1.p [ file2.p ... ][ options ] options: -t: [ target project name ] -- project name ( as well as the generated file ) if not supplied, use file1 -outputDir: [ path ] -- where to write the generated files -aspectOutputDir: [ path ] -- where to write the generated aspectj files if not supplied, use outputDir -generate: [ C,CSharp,RVM ] -- select a target language to generate C : generate C code CSharp : generate C# code RVM : generate Monitor code -h, -help, --help -- display this help message ------------------------------------------ Compile using the P Project Compiling the ClientServer project using the P Project file: pc -proj:ClientServer.pproj Expected Output $ pc -proj:ClientServer.pproj ---------------------------------------- ==== Loading project file: ClientServer.pproj ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Server.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Client.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/AbstractBankServer.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/ClientServerModules.p ....... includes p file: P/Tutorial/1_ClientServer/PSpec/BankBalanceCorrect.p ....... includes p file: P/Tutorial/1_ClientServer/PTst/TestDriver.p ....... includes p file: /Tutorial/1_ClientServer/PTst/Testscript.p ---------------------------------------- ---------------------------------------- Parsing .. Type checking ... Code generation .... Generated ClientServer.cs ---------------------------------------- Compiling ClientServer.csproj .. Microsoft (R) Build Engine version 16.10.2+857e5a733 for .NET Copyright (C) Microsoft Corporation. All rights reserved. Determining projects to restore... All projects are up-to-date for restore. ClientServer -> P/Tutorial/1_ClientServer/POutput/netcoreapp3.1/ClientServer.dll Build succeeded. 0 Warning(s) 0 Error(s) ---------------------------------------- P Project File Details The P compiler does not support advanced project management features like separate compilation and dependency analysis ( coming soon ). The current project file interface is a simple mechanism to provide all the required inputs to the compiler in an XML format ( ClientServer.pproj ). <!-- P Project file for the Client Server example --> <Project> <ProjectName> ClientServer </ProjectName> <InputFiles> <PFile> ./PSrc/ </PFile> <PFile> ./PSpec/ </PFile> <PFile> ./PTst/ </PFile> </InputFiles> <OutputDir> ./PGenerated/ </OutputDir> </Project> The <InputFiles> block provides all the P files that must be compiled together for this project. In <PFile> one can either specify the path to a P file or to a folder and the P compiler includes all the *.p files in the folder during compilation. The <ProjectName> block provides the name for the project which is used as the output file name for the generated code. The <OutputDir> block provides the output directory for the generated code. Finally, the <IncludeProject> block provides a path to other P projects that must be included as dependencies during compilation. The P compiler simply recursively copies all the P files in the dependency projects (transitively including all P files in dependent projects) and compiles them together. This feature provides a way to split the P models for a large system into sub projects that can share models. Compile P files directly Compiling the ClientServer program by passing all the required inputs as commandline arguments: pc PSpec/*.p PSrc/*.p PTst/*.p \\ -generate:csharp -outputDir:PGenerated -target:ClientServer Expected Output ---------------------------------------- ....... includes p file: P/Tutorial/1_ClientServer/PSpec/BankBalanceCorrect.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/AbstractBankServer.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Client.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/ClientServerModules.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Server.p ....... includes p file: P/Tutorial/1_ClientServer/PTst/TestDriver.p ....... includes p file: P/Tutorial/1_ClientServer/PTst/Testscript.p ---------------------------------------- ---------------------------------------- Parsing .. Type checking ... Code generation .... Generated ClientServer.cs ---------------------------------------- Compiling ClientServer.csproj .. Microsoft (R) Build Engine version 16.10.2+857e5a733 for .NET Copyright (C) Microsoft Corporation. All rights reserved. Determining projects to restore... Restored P/Tutorial/1_ClientServer/PGenerated/ClientServer.csproj (in 602 ms). ClientServer -> P/Tutorial/1_ClientServer/PGenerated/POutput/netcoreapp3.1/ClientServer.dll Build succeeded. 0 Warning(s) 0 Error(s)","title":"Compiling a P program"},{"location":"old/getstarted/usingP/#testing-a-p-program","text":"Compiling the ClientServer program generates a ClientServer.dll , this dll is the C# representation of the P program. The P Checker takes as input this dll and systematically explores behaviors of the program for the specified test case. The path to the dll is present in the generated compilation output, check for line: ClientServer -> <Path>/ClientServer.dll You can get the list of test cases defined in the P program by passing the generated dll to the P Checker: pmc <Path>/ClientServer.dll Expected Output: pmc <Path>/ClientServer.dll Provide /method or -m flag to qualify the test method name you wish to use. Possible options are:: PImplementation.tcSingleClient.Execute PImplementation.tcMultipleClients.Execute PImplementation.tcSingleClientAbstractServer.Execute There are three test cases defined in the ClientServer P project and you can specify which test case to run by using the -m or /method parameter along with the -i parameter to specify how many different schedules to explore when running this test case (by default the checker explores a single schedule). For complex systems, running for 100,000 schedules typically finds most of the easy to find bugs before running the checker on a distributed cluster to explore billions of schedules and rule out deep bugs in the system. So to run the tcSingleClient test case for 100 schedules, we can use the following command: pmc <Path>/ClientServer.dll \\ -m PImplementation.tcSingleClient.Execute \\ -i 100 Expected Output . Testing <Path>/ClientServer.dll ... Method PImplementation.tcSingleClient.Execute Starting TestingProcessScheduler in process 72009 ... Created '1' testing task. ... Task 0 is using 'random' strategy (seed:3365663330). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ..... Iteration #9 ..... Iteration #10 ..... Iteration #20 ..... Iteration #30 ..... Iteration #40 ..... Iteration #50 ..... Iteration #60 ..... Iteration #70 ..... Iteration #80 ..... Iteration #90 ..... Iteration #100 ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 100 schedules: 100 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 11 (min), 147 (avg), 680 (max). ... Elapsed 0.8209742 sec. . Done There is a known bug in the ClientServer example (explained in the Tutorials) which is caught by the tcSingleClientAbstractServer test case. Run command: pmc <Path>/ClientServer.dll \\ -m PImplementation.tcSingleClientAbstractServer.Execute \\ -i 100 Expected Output pmc <Path>/ClientServer.dll -m PImplementation.tcSingleClientAbstractServer.Execute -i 100 . Testing <Path>/ClientServer.dll ... Method PImplementation.tcSingleClientAbstractServer.Execute Starting TestingProcessScheduler in process 72578 ... Created '1' testing task. ... Task 0 is using 'random' strategy (seed:574049731). ..... Iteration #1 ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing /POutput/netcoreapp3.1/Output/ClientServer.dll/CoyoteOutput/ClientServer_0_0.txt ..... Writing /POutput/netcoreapp3.1/Output/ClientServer.dll/CoyoteOutput/ClientServer_0_0.schedule ... Elapsed 0.1971223 sec. ... Testing statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 1 schedule: 1 fair and 0 unfair. ..... Found 100.00% buggy schedules. ..... Number of scheduling points in fair terminating schedules: 132 (min), 132 (avg), 132 (max). ... Elapsed 0.3081316 sec. . Done The P checker on finding a bug generates two artifacts (highlighted in the expected output above): (1) a textual trace file (e.g., ClientServer_0_0.txt ) that has the readable error trace representing the sequence of steps from the intial state to the error state; (2) a schedule file (e.g., ClientServer_0_0.schedule ) that can be used to replay the error trace and single step through the P program with the generated error trace for debugging (more details about debugging P error traces: here ).","title":"Testing a P program"},{"location":"tutorial/clientserver/","text":"How to use this example We assume that you have cloned the P repository locally. git clone https://github.com/p-org/P.git The recommended way to work through this example is to open the P/Tutorial folder in IntelliJ side-by-side a browser using which you can simultaneously read the description for each example and browse the P program. To know more about P language primitives used in the example, please look them up in the language manual . System: We consider a client-server application where clients interact with a bank to withdraw money from their accounts. The bank consists of two components: (1) a bank server that services withdraw requests from the client; and (2) a backend database which is used to store the account balance information for each client. Multiple clients can concurrently send withdraw requests to the bank. On receiving a withdraw request, the bank server reads the current bank balance for the client and if the withdraw request is allowed then performs the withdrawal, updates the account balance, and responds back to the client with the new account balance. Correctness Specification: The bank must maintain the invariant that each account must have at least 10 dollars as its balance. If a withdraw request takes the account balance below 10 then the withdraw request must be rejected by the bank. The correctness property that we would like to check is that in the presence of concurrent client withdraw requests the bank always responds with the correct bank balance for each client and a withdraw request always succeeds if there is enough balance in the account (that is, at least 10). P Project The 1_ClientServer folder contains the source code for the ClientServer project. Please feel free to read details about the recommended P program structure and P project file . Models The P models ( PSrc ) for the ClientServer example consist of four files: Client.p : Implements the Client state machine. [Expand]: Let's walk through Client.p ( L19 - L22 ) \u2192 Events eWithDrawReq and eWithDrawResp are used to communicate between the Client and the Server machines (manual: event declaration ). ( L3 - L17 ) \u2192 Declares the payload types for the eWithDrawReq and eWithDrawResp events (manual: user defined type ). ( L25 - L95 ) \u2192 Declares the Client state machine (manual: P state machine ). The Client machine has a set of local variables used to store the local-state of the state machine ( L27 - L31 ). Init state is the start state of the machine where the machine starts executions on being created. The entry function of the Init state initializes the local variables based on the parameters received on creation and jumps to the WithdrawMoney state. In the WithdrawMoney state, the state machine checks if there is enough money in the account. If the balance is greater than 10 then it issues a random withdraw request to the bank by sending the eWithDrawReq event ( L55 ) otherwise it jumps to the NoMoneyToWithDraw state. After sending a withdraw request, the machine waits for the eWithDrawResp event ( L59 ). On receiving the eWithDrawResp event, the machine executes the corresponding event handler that confirms if the bank response is as expected and also if there is still money in the account then jumps back to the WithdrawMoney state. Note that each time we (re-)enter a state (through a transition or goto statement), its entry function is executed. Server.p : Implements the BankServer and the backend Database state machines. [Expand]: Let's walk through Server.p ( L1 - L7 ) \u2192 Declares the events used to communicate between the bank server and the backend database. ( L9 - L48 ) \u2192 Declares the BankServer machine. The BankServer machine uses a database machine as a service to store the bank balance for all its clients. On receiving an eWithDrawReq (withdraw requests) from a client, it reads the current balance for the account, if there is enough money in the account then it updates the new balance in the database after withdrawal and sends a response back to the client. ( L50 - L74 ) \u2192 Declares the Database machine. The Database machine acts as a helper service for the Bank server and stores the bank balance for each account. There are two API's or functions to interact with the Database: ReadBankBalance and UpdateBankBalance. These functions are implemented as global functions in P ( L76 - L92 ). AbstractBankServer.p : Implements the AbstractBankServer state machine that provides a simplified abstraction that unifies the BankServer and Database machines. We will demonstrate how one can replace the complex bank service (consisting of two interacting components, the BankServer and the Database) by its abstraction when checking the client application. [Expand]: Let's walk through AbstractBankServer.p ( L12 - L37 ) \u2192 Declares an abstraction of the BankServer machine. The AbstractBankServer provides an implementation of the Bank where the interaction between the BankServer and Database is abstracted away. We use the AbstractBankServer machine to demonstrate how one can replace a complex component in P with an abstraction that hides a lot of its internal complexity. For the client, it still exposes the same interface or behavior. Hence, when checking the correctness of the client it does not matter whether we pair it with the BankServer or the AbstractBankServer. Key Takeaway To mitigate the state space explosion problem, when modeling and checking complex systems consisting of several components, we would like to check the correctness of each component in isolation. When doing this kind of a compositional reasoning, we replace the environment of the component with its abstraction. The abstraction basically exposes the same interface as the environment but removes its internal complexity, simplifying the overall problem of checking the correctness of the component under test. There is a large body of literature on doing compositional reasoning of distributed systems. You can start with the Modular P paper . How to automatically replace a machine with its abstraction is described below. ClientServerModules.p : Declares the P modules corresponding to each component in the system. [Expand]: Let's walk through ClientServerModules.p ( L1 - L5 ) \u2192 Declares the Client and Bank modules. A module in P is a collection of state machines that together implement that module or component. A system model in P is then a composition or union of modules. The Client module consists of a single machine Client and the Bank module is implemented by machines BankServer and Database together (manual: P module system ). ( L7 - L8 ) \u2192 The AbstractBank module uses the binding feature in P modules to bind the BankServer machine to the AbstractBankServer machine. Basically, what this implies is that whenever AbstractBank module is used the creation of the BankServer machine will result in creation of AbstractBankServer , replacing the implementation with its abstraction (manual: primitive modules ). Specifications The P Specifications ( PSpec ) for the ClientServer example are implemented in the BankBalanceCorrect.p file. We define two specifications: BankBalanceIsAlwaysCorrect (safety property): The BankBalanceIsAlwaysCorrect specification checks the global invariant that the account-balance communicated to the client by the bank is always correct and the bank never removes more money from the account than that withdrawn by the client! Also, if the bank denies a withdraw request then it is only because the withdrawal would reduce the account balance to below 10. GuaranteedWithDrawProgress (liveness property): The GuaranteedWithDrawProgress specification checks the liveness (or progress) property that all withdraw requests submitted by the client are eventually responded. Stating that BankBalanceIsAlwaysCorrect checks that \"if the bank denies a withdraw request then the request would reduce the balance to below 10 (< 10)\" is equivalent to state that \"if there is enough money in the account - at least 10 (>= 10), then the request must not error\". Hence, the two properties BankBalanceIsAlwaysCorrect and GuaranteedWithDrawProgress together ensure that every withdraw request if allowed will eventually succeed and the bank cannot block correct withdrawal requests. [Expand]: Let's walk through BankBalanceCorrect.p ( L20 ) \u2192 Event eSpec_BankBalanceIsAlwaysCorrect_Init is used to inform the monitors about the initial state of the Bank. The event is announced by the TestDrivers when setting up the system ( here ). ( L36 - L86 ) \u2192 Declares the BankBalanceIsAlwaysCorrect safety spec machine that observes the events eWithDrawReq , eWithDrawResp , and eSpec_BankBalanceIsAlwaysCorrect_Init to assert the required global invariant. ( L92 - L115 ) \u2192 Declares the GuaranteedWithDrawProgress liveness spec machine that observes the events eWithDrawReq and eWithDrawResp to assert the required liveness property that every request is eventually responded by the Bank. To understand the semantics of the P spec machines, please read manual: p monitors . Test Scenarios The test scenarios folder in P has two parts: TestDrivers and TestScripts. TestDrivers are collections of state machines that implement the test harnesses (or environment state machines) for different test scenarios. TestScripts are collections of test cases that are automatically run by the P checker. The test scenarios folder for ClientServer ( PTst ) consists of two files TestDriver.p and TestScript.p . [Expand]: Let's walk through TestDriver.p ( L36 - L60 ) \u2192 Function SetupClientServerSystem takes as input the number of clients to be created and configures the ClientServer system by creating the Client and BankServer machines. The CreateRandomInitialAccounts function uses the choose primitive to randomly initialize the accounts map. The function also announce the event eSpec_BankBalanceIsAlwaysCorrect_Init to initialize the monitors with initial balance for all accounts (manual: annouce statement ). ( L3 - L22 ) \u2192 Machines TestWithSingleClient and TestWithMultipleClients are simple test driver machines that configure the system to be checked by the P checker for different scenarios. In this case, test the ClientServer system by first randomly initializing the accounts map and then checking it with either one Client or with multiple Client s (between 2 and 4)). [Expand]: Let's walk through TestScript.p P allows programmers to write different test cases. Each test case is checked separately and can use a different test driver. Using different test drivers triggers different behaviors in the system under test, as it implies different system configurations and input generators. To better understand the P test cases, please look at manual: P test cases . ( L4 - L16 ) \u2192 Declares three test cases each checking a different scenario and system. The system under test is the union of the modules representing each component in the system (manual: P module system ). The assert module constructor is used to attach monitors or specifications to be checked on the modules (manual: assert ). In the tcSingleClientAbstractServer test case, instead of composing with the Bank module, we use the AbstractBank module. Hence, in the composed system, whenever the creation of a BankServer machine is invoked the binding will instead create an AbstractBankServer machine. Compiling ClientServer Navigate to the 1_ClientServer folder and run the following command to compile the ClientServer project: p compile Expected Output $ p compile .. Searching for a P project file *.pproj locally in the current folder .. Found P project file: P/Tutorial/1_ClientServer/ClientServer.pproj ---------------------------------------- ==== Loading project file: P/Tutorial/1_ClientServer/ClientServer.pproj ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Server.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Client.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/AbstractBankServer.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/ClientServerModules.p ....... includes p file: P/Tutorial/1_ClientServer/PSpec/BankBalanceCorrect.p ....... includes p file: P/Tutorial/1_ClientServer/PTst/TestDriver.p ....... includes p file: P/Tutorial/1_ClientServer/PTst/Testscript.p ---------------------------------------- ---------------------------------------- Parsing ... Type checking ... Code generation ... Generated ClientServer.cs. ---------------------------------------- Compiling ClientServer... MSBuild version 17.3.1+2badb37d1 for .NET Determining projects to restore... Restored P/Tutorial/1_ClientServer/PGenerated/CSharp/ClientServer.csproj (in 365 ms). ClientServer -> P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll Build succeeded. 0 Warning(s) 0 Error(s) Time Elapsed 00:00:02.34 ---------------------------------------- [PTool]: Thanks for using P! Checking ClientServer You can get the list of test cases defined in the ClientServer project by running the P Checker: p check Expected Output $ p check .. Searching for a P compiled file locally in the current folder .. Found a P compiled file: P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll .. Checking P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll Error: We found '3' test cases. Please provide a more precise name of the test case you wish to check using (--testcase | -tc). Possible options are: tcSingleClient tcMultipleClients tcSingleClientAbstractServer [PTool]: Thanks for using P! There are three test cases defined in the ClientServer project, and you can specify which test case to run by using the -tc parameter along with the -i parameter for the number of schedules to explore. Check the tcSingleClient test case for 1000 schedules: p check -tc tcSingleClient -i 1000 Check the tcMultipleClients test case for 1000 schedules: p check -tc tcMultipleClients -i 1000 Check the tcSingleClientAbstractServer test case for 1000 schedules: p check -tc tcSingleClientAbstractServer -i 1000 Error tcSingleClientAbstractServer triggers an error in the AbstractBankServer state machine. Please use the guide to explore how to debug an error trace generated by the P Checker. Exercise Problem [Problem 1] Fix the bug in AbstractBankServer state machine and run the P Checker again on the test case to ensure that there are no more bugs in the models. [Problem 2] Extend the ClientServer example with support for depositing money into the bank. This would require implementing events eDepositReq and eDepositResp which are used to interact between the client and server machine. The Client machine should be updated to deposit money into the account when the balance is low and the BankServer machine implementation would have to be updated to support depositing money into the bank account. After implementing the deposit feature, run the test-cases again to check if the system still satisfies the desired specifications. What did we learn through this example? We explored writing P state machines, safety and liveness specifications as P monitors, writing multiple model checking scenarios to check the correctness of a P program, and finally, replacing complex components in P with their abstractions using P's module system.","title":"Client Server"},{"location":"tutorial/clientserver/#p-project","text":"The 1_ClientServer folder contains the source code for the ClientServer project. Please feel free to read details about the recommended P program structure and P project file .","title":"P Project"},{"location":"tutorial/clientserver/#models","text":"The P models ( PSrc ) for the ClientServer example consist of four files: Client.p : Implements the Client state machine. [Expand]: Let's walk through Client.p ( L19 - L22 ) \u2192 Events eWithDrawReq and eWithDrawResp are used to communicate between the Client and the Server machines (manual: event declaration ). ( L3 - L17 ) \u2192 Declares the payload types for the eWithDrawReq and eWithDrawResp events (manual: user defined type ). ( L25 - L95 ) \u2192 Declares the Client state machine (manual: P state machine ). The Client machine has a set of local variables used to store the local-state of the state machine ( L27 - L31 ). Init state is the start state of the machine where the machine starts executions on being created. The entry function of the Init state initializes the local variables based on the parameters received on creation and jumps to the WithdrawMoney state. In the WithdrawMoney state, the state machine checks if there is enough money in the account. If the balance is greater than 10 then it issues a random withdraw request to the bank by sending the eWithDrawReq event ( L55 ) otherwise it jumps to the NoMoneyToWithDraw state. After sending a withdraw request, the machine waits for the eWithDrawResp event ( L59 ). On receiving the eWithDrawResp event, the machine executes the corresponding event handler that confirms if the bank response is as expected and also if there is still money in the account then jumps back to the WithdrawMoney state. Note that each time we (re-)enter a state (through a transition or goto statement), its entry function is executed. Server.p : Implements the BankServer and the backend Database state machines. [Expand]: Let's walk through Server.p ( L1 - L7 ) \u2192 Declares the events used to communicate between the bank server and the backend database. ( L9 - L48 ) \u2192 Declares the BankServer machine. The BankServer machine uses a database machine as a service to store the bank balance for all its clients. On receiving an eWithDrawReq (withdraw requests) from a client, it reads the current balance for the account, if there is enough money in the account then it updates the new balance in the database after withdrawal and sends a response back to the client. ( L50 - L74 ) \u2192 Declares the Database machine. The Database machine acts as a helper service for the Bank server and stores the bank balance for each account. There are two API's or functions to interact with the Database: ReadBankBalance and UpdateBankBalance. These functions are implemented as global functions in P ( L76 - L92 ). AbstractBankServer.p : Implements the AbstractBankServer state machine that provides a simplified abstraction that unifies the BankServer and Database machines. We will demonstrate how one can replace the complex bank service (consisting of two interacting components, the BankServer and the Database) by its abstraction when checking the client application. [Expand]: Let's walk through AbstractBankServer.p ( L12 - L37 ) \u2192 Declares an abstraction of the BankServer machine. The AbstractBankServer provides an implementation of the Bank where the interaction between the BankServer and Database is abstracted away. We use the AbstractBankServer machine to demonstrate how one can replace a complex component in P with an abstraction that hides a lot of its internal complexity. For the client, it still exposes the same interface or behavior. Hence, when checking the correctness of the client it does not matter whether we pair it with the BankServer or the AbstractBankServer. Key Takeaway To mitigate the state space explosion problem, when modeling and checking complex systems consisting of several components, we would like to check the correctness of each component in isolation. When doing this kind of a compositional reasoning, we replace the environment of the component with its abstraction. The abstraction basically exposes the same interface as the environment but removes its internal complexity, simplifying the overall problem of checking the correctness of the component under test. There is a large body of literature on doing compositional reasoning of distributed systems. You can start with the Modular P paper . How to automatically replace a machine with its abstraction is described below. ClientServerModules.p : Declares the P modules corresponding to each component in the system. [Expand]: Let's walk through ClientServerModules.p ( L1 - L5 ) \u2192 Declares the Client and Bank modules. A module in P is a collection of state machines that together implement that module or component. A system model in P is then a composition or union of modules. The Client module consists of a single machine Client and the Bank module is implemented by machines BankServer and Database together (manual: P module system ). ( L7 - L8 ) \u2192 The AbstractBank module uses the binding feature in P modules to bind the BankServer machine to the AbstractBankServer machine. Basically, what this implies is that whenever AbstractBank module is used the creation of the BankServer machine will result in creation of AbstractBankServer , replacing the implementation with its abstraction (manual: primitive modules ).","title":"Models"},{"location":"tutorial/clientserver/#specifications","text":"The P Specifications ( PSpec ) for the ClientServer example are implemented in the BankBalanceCorrect.p file. We define two specifications: BankBalanceIsAlwaysCorrect (safety property): The BankBalanceIsAlwaysCorrect specification checks the global invariant that the account-balance communicated to the client by the bank is always correct and the bank never removes more money from the account than that withdrawn by the client! Also, if the bank denies a withdraw request then it is only because the withdrawal would reduce the account balance to below 10. GuaranteedWithDrawProgress (liveness property): The GuaranteedWithDrawProgress specification checks the liveness (or progress) property that all withdraw requests submitted by the client are eventually responded. Stating that BankBalanceIsAlwaysCorrect checks that \"if the bank denies a withdraw request then the request would reduce the balance to below 10 (< 10)\" is equivalent to state that \"if there is enough money in the account - at least 10 (>= 10), then the request must not error\". Hence, the two properties BankBalanceIsAlwaysCorrect and GuaranteedWithDrawProgress together ensure that every withdraw request if allowed will eventually succeed and the bank cannot block correct withdrawal requests. [Expand]: Let's walk through BankBalanceCorrect.p ( L20 ) \u2192 Event eSpec_BankBalanceIsAlwaysCorrect_Init is used to inform the monitors about the initial state of the Bank. The event is announced by the TestDrivers when setting up the system ( here ). ( L36 - L86 ) \u2192 Declares the BankBalanceIsAlwaysCorrect safety spec machine that observes the events eWithDrawReq , eWithDrawResp , and eSpec_BankBalanceIsAlwaysCorrect_Init to assert the required global invariant. ( L92 - L115 ) \u2192 Declares the GuaranteedWithDrawProgress liveness spec machine that observes the events eWithDrawReq and eWithDrawResp to assert the required liveness property that every request is eventually responded by the Bank. To understand the semantics of the P spec machines, please read manual: p monitors .","title":"Specifications"},{"location":"tutorial/clientserver/#test-scenarios","text":"The test scenarios folder in P has two parts: TestDrivers and TestScripts. TestDrivers are collections of state machines that implement the test harnesses (or environment state machines) for different test scenarios. TestScripts are collections of test cases that are automatically run by the P checker. The test scenarios folder for ClientServer ( PTst ) consists of two files TestDriver.p and TestScript.p . [Expand]: Let's walk through TestDriver.p ( L36 - L60 ) \u2192 Function SetupClientServerSystem takes as input the number of clients to be created and configures the ClientServer system by creating the Client and BankServer machines. The CreateRandomInitialAccounts function uses the choose primitive to randomly initialize the accounts map. The function also announce the event eSpec_BankBalanceIsAlwaysCorrect_Init to initialize the monitors with initial balance for all accounts (manual: annouce statement ). ( L3 - L22 ) \u2192 Machines TestWithSingleClient and TestWithMultipleClients are simple test driver machines that configure the system to be checked by the P checker for different scenarios. In this case, test the ClientServer system by first randomly initializing the accounts map and then checking it with either one Client or with multiple Client s (between 2 and 4)). [Expand]: Let's walk through TestScript.p P allows programmers to write different test cases. Each test case is checked separately and can use a different test driver. Using different test drivers triggers different behaviors in the system under test, as it implies different system configurations and input generators. To better understand the P test cases, please look at manual: P test cases . ( L4 - L16 ) \u2192 Declares three test cases each checking a different scenario and system. The system under test is the union of the modules representing each component in the system (manual: P module system ). The assert module constructor is used to attach monitors or specifications to be checked on the modules (manual: assert ). In the tcSingleClientAbstractServer test case, instead of composing with the Bank module, we use the AbstractBank module. Hence, in the composed system, whenever the creation of a BankServer machine is invoked the binding will instead create an AbstractBankServer machine.","title":"Test Scenarios"},{"location":"tutorial/clientserver/#compiling-clientserver","text":"Navigate to the 1_ClientServer folder and run the following command to compile the ClientServer project: p compile Expected Output $ p compile .. Searching for a P project file *.pproj locally in the current folder .. Found P project file: P/Tutorial/1_ClientServer/ClientServer.pproj ---------------------------------------- ==== Loading project file: P/Tutorial/1_ClientServer/ClientServer.pproj ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Server.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/Client.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/AbstractBankServer.p ....... includes p file: P/Tutorial/1_ClientServer/PSrc/ClientServerModules.p ....... includes p file: P/Tutorial/1_ClientServer/PSpec/BankBalanceCorrect.p ....... includes p file: P/Tutorial/1_ClientServer/PTst/TestDriver.p ....... includes p file: P/Tutorial/1_ClientServer/PTst/Testscript.p ---------------------------------------- ---------------------------------------- Parsing ... Type checking ... Code generation ... Generated ClientServer.cs. ---------------------------------------- Compiling ClientServer... MSBuild version 17.3.1+2badb37d1 for .NET Determining projects to restore... Restored P/Tutorial/1_ClientServer/PGenerated/CSharp/ClientServer.csproj (in 365 ms). ClientServer -> P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll Build succeeded. 0 Warning(s) 0 Error(s) Time Elapsed 00:00:02.34 ---------------------------------------- [PTool]: Thanks for using P!","title":"Compiling ClientServer"},{"location":"tutorial/clientserver/#checking-clientserver","text":"You can get the list of test cases defined in the ClientServer project by running the P Checker: p check Expected Output $ p check .. Searching for a P compiled file locally in the current folder .. Found a P compiled file: P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll .. Checking P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll Error: We found '3' test cases. Please provide a more precise name of the test case you wish to check using (--testcase | -tc). Possible options are: tcSingleClient tcMultipleClients tcSingleClientAbstractServer [PTool]: Thanks for using P! There are three test cases defined in the ClientServer project, and you can specify which test case to run by using the -tc parameter along with the -i parameter for the number of schedules to explore. Check the tcSingleClient test case for 1000 schedules: p check -tc tcSingleClient -i 1000 Check the tcMultipleClients test case for 1000 schedules: p check -tc tcMultipleClients -i 1000 Check the tcSingleClientAbstractServer test case for 1000 schedules: p check -tc tcSingleClientAbstractServer -i 1000 Error tcSingleClientAbstractServer triggers an error in the AbstractBankServer state machine. Please use the guide to explore how to debug an error trace generated by the P Checker.","title":"Checking ClientServer"},{"location":"tutorial/clientserver/#exercise-problem","text":"[Problem 1] Fix the bug in AbstractBankServer state machine and run the P Checker again on the test case to ensure that there are no more bugs in the models. [Problem 2] Extend the ClientServer example with support for depositing money into the bank. This would require implementing events eDepositReq and eDepositResp which are used to interact between the client and server machine. The Client machine should be updated to deposit money into the account when the balance is low and the BankServer machine implementation would have to be updated to support depositing money into the bank account. After implementing the deposit feature, run the test-cases again to check if the system still satisfies the desired specifications. What did we learn through this example? We explored writing P state machines, safety and liveness specifications as P monitors, writing multiple model checking scenarios to check the correctness of a P program, and finally, replacing complex components in P with their abstractions using P's module system.","title":"Exercise Problem"},{"location":"tutorial/common/","text":"We also describe how to model system's interaction with an OS Timer Timer , and how to model injecting node failures in the system Failure Injector . These models are used in the Two Phase Commit, Espresso Machine, and Failure Detector models. P is a purely messaging passing based programming language and hence does not support primitives for modeling shared memory based concurrency. But one can always model shared memory concurrency using message passing. We have used this style of modeling when checking the correctness of single node file systems. Please check out shared memory project on how to model shared memory concurrency using P.","title":"Timer, Failure, and Shared Memory"},{"location":"tutorial/espressomachine/","text":"How to use this example We assume that you have cloned the P repository locally. git clone https://github.com/p-org/P.git The recommended way to work through this example is to open the P/Tutorial folder in IntelliJ side-by-side a browser using which you can simultaneously read the description for each example and browse the P program in IntelliJ. To know more about the P language primitives used in the example, please look them up in the language manual . We have reached the middle of our tutorials , it's time to take a break and have an espresso coffee! P has been used in the past to implement device drivers and robotics systems (see case studies and publications ). One of the many challenges in implementing such systems is that they are reactive and hence, must handle arbitrary sequences of events (inputs) appropriately depending on their current mode of operation. System: We consider a fun example of modeling an espresso coffee machine and see how we can use P state machines to model a reactive system that must respond correctly to various user inputs. The user interacts with the coffee machine through its control panel. So the Espresso machine basically consists of two parts: the front-end control panel and the backend coffee maker that actually makes the coffee. The control panel presents an interface to the user to perform operations like reset machine, turn steamer on and off, request an espresso , and clear the grounds by opening the container. The control panel interprets these inputs from the user and sends appropriate commands to the coffee maker. Correctness Specifications: By default, the P checker tests whether any event that is received in a state has a handler defined for it, otherwise, it would result in an unhandled event exception. If the P checker fails to find a bug then it implies that the system model can handle any sequence of events generated by the given environment which in our example's context implies that the coffee machine control panel can appropriately handle any sequence of inputs (button presses) by the user. We would also like to check that the coffee machine moves through a desired sequence of states, i.e., WarmUp -> Ready -> GrindBeans -> MakeCoffee -> Ready . P Project The 3_EspressoMachine folder contains the source code for the EspressoMachine project. Please feel free to read details about the recommended P program structure and P project file . Models The P models ( PSrc ) for the EspressoMachine example consist of three files: CoffeeMakerControlPanel.p : Implements the CoffeeMakerControlPanel state machine. Basically, the control panel starts in the initial state and kicks off by warming up the coffee maker. After warming is successful, it moves to the ready state where it can either make coffee or start the steamer. When asked to make coffee, it first grinds the beans and then brews coffee. In any of these states, if there is an error due to. e.g, no water or no beans, the control panel informs the user of the error and moves to the error state waiting for the user to reset the machine. [Expand]: Let's walk through CoffeeMakerControlPanel.p ( L2 - L19 ) \u2192 Declare events that are used to communicate between the User and the ControlPanel machines (manual: event declaration ). These are events that represent the operations performed by the user, e.g., resetting the machine, pressing the steamer button on and off, etc. ( L34 - L231 ) \u2192 Declares the CoffeeMakerControlPanel state machine. The interesting points that we would like to highlight are: (1) the state machine transitions from one mode (or state) to another based on the events received from the user and the CoffeeMaker machine; (2) in all the states, the state machine appropriately handles different events that can be received, including ignoring or deferring them if they are stale events. CoffeeMaker.p : Implements the CoffeeMaker state machine. [Expand]: Let's walk through CoffeeMaker.p ( L4 - L29 ) \u2192 Declares the events used to communicate between the control panel and the backend coffee maker. ( L31 - L78 ) \u2192 Declares the EspressoCoffeeMaker machine. EspressoCoffeeMaker receives requests from the control panel of the coffee machine and based on its state e.g., whether heater is working, or it has beans and water, the coffee maker responds nondeterministically back to the controller if the operation succeeded or errored. EspressoMachineModules.p : Declares the P module corresponding to EspressoMachine. Specifications The P Specification ( PSpec ) for the EspressoMachine example is implemented in Safety.p . We define a safety specification EspressoMachineModesOfOperation that observes the internal state of the EspressoMachine through the events that are announced as the system moves through different states and asserts that it always moves through the desired sequence of states. Steady operation: WarmUp -> Ready -> GrindBeans -> MakeCoffee -> Ready . If an error occurs in any of the states above then the EspressoMachine stays in the error state until it is reset and after which it returns to the Warmup state. [Expand]: Let's walk through Safety.p ( L1 - L7 ) \u2192 Events used to inform the monitor about the state of the EspressoMachine system. The events are announced as the system moves from one state to another (manual: announce statement ). The EspressoMachineModesOfOperation spec machine observes these events and ensures that the system moves through the states defined by the monitor. Note that if the system allows (has execution as) a sequence of events that are not accepted by the monitor (i.e., the monitor throws an unhandled event exception) then the system does not satisfy the desired specification. Hence, this monitor can be thought of accepting only those behaviors of the system that follow the sequence of states modelled by the spec machine. For example, if the system moves from Ready to CoffeeMaking state directly without Grinding then the monitor will raise an ALARM! To understand the semantics of the P spec machines, please read manual: p monitors . Test Scenarios The test scenarios folder in P has two parts: TestDrivers and TestScripts. TestDrivers are collections of state machines that implement the test harnesses (or environment state machines) for different test scenarios. TestScripts are collections of test cases that are automatically run by the P checker. The test scenarios folder for EspressoMachine ( PTst ) consists of three files: TestDriver.p and TestScript.p are just like other previous examples. The User.p declares two machines: (1) a SaneUser machine that uses the EspressoMachine with care, pressing the buttons in the right order, and cleaning up the grounds after the coffee is made; and (2) a CrazyUser machine who has never used an espresso machine before, gets too excited, and starts pushing random buttons on the control panel. Compiling EspressoMachine Run the following command to compile the project: p compile Expected Output $ p compile .. Searching for a P project file *.pproj locally in the current folder .. Found P project file: P/Tutorial/3_EspressoMachine/EspressoMachine.pproj ---------------------------------------- ==== Loading project file: P/Tutorial/3_EspressoMachine/EspressoMachine.pproj ....... includes p file: P/Tutorial/3_EspressoMachine/PSrc/CoffeeMaker.p ....... includes p file: P/Tutorial/3_EspressoMachine/PSrc/CoffeeMakerControlPanel.p ....... includes p file: P/Tutorial/3_EspressoMachine/PSrc/EspressoMachineModules.p ....... includes p file: P/Tutorial/3_EspressoMachine/PSpec/Safety.p ....... includes p file: P/Tutorial/3_EspressoMachine/PTst/Users.p ....... includes p file: P/Tutorial/3_EspressoMachine/PTst/TestDrivers.p ....... includes p file: P/Tutorial/3_EspressoMachine/PTst/TestScripts.p ---------------------------------------- ---------------------------------------- Parsing ... Type checking ... Code generation ... Generated EspressoMachine.cs. ---------------------------------------- Compiling EspressoMachine... MSBuild version 17.3.1+2badb37d1 for .NET Determining projects to restore... Restored P/Tutorial/3_EspressoMachine/PGenerated/CSharp/EspressoMachine.csproj (in 389 ms). EspressoMachine -> P/Tutorial/3_EspressoMachine/PGenerated/CSharp/net6.0/EspressoMachine.dll Build succeeded. 0 Warning(s) 0 Error(s) Time Elapsed 00:00:05.04 ---------------------------------------- [PTool]: Thanks for using P! Checking EspressoMachine You can get the list of test cases defined in the EspressoMachine project by running the P Checker: p check Expected Output $ p check .. Searching for a P compiled file locally in the current folder .. Found a P compiled file: P/Tutorial/3_EspressoMachine/PGenerated/CSharp/net6.0/EspressoMachine.dll .. Checking P/Tutorial/3_EspressoMachine/PGenerated/CSharp/net6.0/EspressoMachine.dll Error: We found '2' test cases. Please provide a more precise name of the test case you wish to check using (--testcase | -tc). Possible options are: tcSaneUserUsingCoffeeMachine tcCrazyUserUsingCoffeeMachine [PTool]: Thanks for using P! There are two test cases defined in the EspressoMachine project and you can specify which test case to run by using the -tc parameter along with the -i parameter for the number of schedules to explore. Check the tcSaneUserUsingCoffeeMachine test case for 10000 schedules: p check -tc tcSaneUserUsingCoffeeMachine -i 10000 Check the tcCrazyUserUsingCoffeeMachine test case for 10000 schedules: p check -tc tcCrazyUserUsingCoffeeMachine -i 10000 Exercise Problem [Problem 1] Note that the current safety specification CoffeeMakerModesOfOperation does not capture the case where the CoffeeMaker can move to GroundsOpen and GroundsClosed state. Extend the spec to cover those modes of operations as well. Thinking! ... Can you think of other cases where you would like to check that your system evolves through a certain sequence of states? Or that it allows only those executions which follow a pattern? Can these be specified as P monitors? If not, what are the challenges? A typical example of such cases is when for files in a storage system the sequence of operations that must succeed need to have a pattern of the form: open \u2192 read* \u2192 close; and similarly, for lock services, lockAcquire \u2192 readSuccess \u2192 lockReleased. More interestingly, you can also check things like: AuthenticationSuccess(x) \u2192 ReadSuccess(x), and never see a case of AuthenticationFailure(x) \u2192 ReadSuccess(x) in your executions! What do you think? Post your comments in the github discussions . What did we learn through this example? This was a fun example to demonstrate how to model a reactive system using P state machines. We saw how using P monitors allows us to check that the system moves through the correct modes of operation and that the executions only allow certain patterns.","title":"Espresso Machine"},{"location":"tutorial/espressomachine/#p-project","text":"The 3_EspressoMachine folder contains the source code for the EspressoMachine project. Please feel free to read details about the recommended P program structure and P project file .","title":"P Project"},{"location":"tutorial/espressomachine/#models","text":"The P models ( PSrc ) for the EspressoMachine example consist of three files: CoffeeMakerControlPanel.p : Implements the CoffeeMakerControlPanel state machine. Basically, the control panel starts in the initial state and kicks off by warming up the coffee maker. After warming is successful, it moves to the ready state where it can either make coffee or start the steamer. When asked to make coffee, it first grinds the beans and then brews coffee. In any of these states, if there is an error due to. e.g, no water or no beans, the control panel informs the user of the error and moves to the error state waiting for the user to reset the machine. [Expand]: Let's walk through CoffeeMakerControlPanel.p ( L2 - L19 ) \u2192 Declare events that are used to communicate between the User and the ControlPanel machines (manual: event declaration ). These are events that represent the operations performed by the user, e.g., resetting the machine, pressing the steamer button on and off, etc. ( L34 - L231 ) \u2192 Declares the CoffeeMakerControlPanel state machine. The interesting points that we would like to highlight are: (1) the state machine transitions from one mode (or state) to another based on the events received from the user and the CoffeeMaker machine; (2) in all the states, the state machine appropriately handles different events that can be received, including ignoring or deferring them if they are stale events. CoffeeMaker.p : Implements the CoffeeMaker state machine. [Expand]: Let's walk through CoffeeMaker.p ( L4 - L29 ) \u2192 Declares the events used to communicate between the control panel and the backend coffee maker. ( L31 - L78 ) \u2192 Declares the EspressoCoffeeMaker machine. EspressoCoffeeMaker receives requests from the control panel of the coffee machine and based on its state e.g., whether heater is working, or it has beans and water, the coffee maker responds nondeterministically back to the controller if the operation succeeded or errored. EspressoMachineModules.p : Declares the P module corresponding to EspressoMachine.","title":"Models"},{"location":"tutorial/espressomachine/#specifications","text":"The P Specification ( PSpec ) for the EspressoMachine example is implemented in Safety.p . We define a safety specification EspressoMachineModesOfOperation that observes the internal state of the EspressoMachine through the events that are announced as the system moves through different states and asserts that it always moves through the desired sequence of states. Steady operation: WarmUp -> Ready -> GrindBeans -> MakeCoffee -> Ready . If an error occurs in any of the states above then the EspressoMachine stays in the error state until it is reset and after which it returns to the Warmup state. [Expand]: Let's walk through Safety.p ( L1 - L7 ) \u2192 Events used to inform the monitor about the state of the EspressoMachine system. The events are announced as the system moves from one state to another (manual: announce statement ). The EspressoMachineModesOfOperation spec machine observes these events and ensures that the system moves through the states defined by the monitor. Note that if the system allows (has execution as) a sequence of events that are not accepted by the monitor (i.e., the monitor throws an unhandled event exception) then the system does not satisfy the desired specification. Hence, this monitor can be thought of accepting only those behaviors of the system that follow the sequence of states modelled by the spec machine. For example, if the system moves from Ready to CoffeeMaking state directly without Grinding then the monitor will raise an ALARM! To understand the semantics of the P spec machines, please read manual: p monitors .","title":"Specifications"},{"location":"tutorial/espressomachine/#test-scenarios","text":"The test scenarios folder in P has two parts: TestDrivers and TestScripts. TestDrivers are collections of state machines that implement the test harnesses (or environment state machines) for different test scenarios. TestScripts are collections of test cases that are automatically run by the P checker. The test scenarios folder for EspressoMachine ( PTst ) consists of three files: TestDriver.p and TestScript.p are just like other previous examples. The User.p declares two machines: (1) a SaneUser machine that uses the EspressoMachine with care, pressing the buttons in the right order, and cleaning up the grounds after the coffee is made; and (2) a CrazyUser machine who has never used an espresso machine before, gets too excited, and starts pushing random buttons on the control panel.","title":"Test Scenarios"},{"location":"tutorial/espressomachine/#compiling-espressomachine","text":"Run the following command to compile the project: p compile Expected Output $ p compile .. Searching for a P project file *.pproj locally in the current folder .. Found P project file: P/Tutorial/3_EspressoMachine/EspressoMachine.pproj ---------------------------------------- ==== Loading project file: P/Tutorial/3_EspressoMachine/EspressoMachine.pproj ....... includes p file: P/Tutorial/3_EspressoMachine/PSrc/CoffeeMaker.p ....... includes p file: P/Tutorial/3_EspressoMachine/PSrc/CoffeeMakerControlPanel.p ....... includes p file: P/Tutorial/3_EspressoMachine/PSrc/EspressoMachineModules.p ....... includes p file: P/Tutorial/3_EspressoMachine/PSpec/Safety.p ....... includes p file: P/Tutorial/3_EspressoMachine/PTst/Users.p ....... includes p file: P/Tutorial/3_EspressoMachine/PTst/TestDrivers.p ....... includes p file: P/Tutorial/3_EspressoMachine/PTst/TestScripts.p ---------------------------------------- ---------------------------------------- Parsing ... Type checking ... Code generation ... Generated EspressoMachine.cs. ---------------------------------------- Compiling EspressoMachine... MSBuild version 17.3.1+2badb37d1 for .NET Determining projects to restore... Restored P/Tutorial/3_EspressoMachine/PGenerated/CSharp/EspressoMachine.csproj (in 389 ms). EspressoMachine -> P/Tutorial/3_EspressoMachine/PGenerated/CSharp/net6.0/EspressoMachine.dll Build succeeded. 0 Warning(s) 0 Error(s) Time Elapsed 00:00:05.04 ---------------------------------------- [PTool]: Thanks for using P!","title":"Compiling EspressoMachine"},{"location":"tutorial/espressomachine/#checking-espressomachine","text":"You can get the list of test cases defined in the EspressoMachine project by running the P Checker: p check Expected Output $ p check .. Searching for a P compiled file locally in the current folder .. Found a P compiled file: P/Tutorial/3_EspressoMachine/PGenerated/CSharp/net6.0/EspressoMachine.dll .. Checking P/Tutorial/3_EspressoMachine/PGenerated/CSharp/net6.0/EspressoMachine.dll Error: We found '2' test cases. Please provide a more precise name of the test case you wish to check using (--testcase | -tc). Possible options are: tcSaneUserUsingCoffeeMachine tcCrazyUserUsingCoffeeMachine [PTool]: Thanks for using P! There are two test cases defined in the EspressoMachine project and you can specify which test case to run by using the -tc parameter along with the -i parameter for the number of schedules to explore. Check the tcSaneUserUsingCoffeeMachine test case for 10000 schedules: p check -tc tcSaneUserUsingCoffeeMachine -i 10000 Check the tcCrazyUserUsingCoffeeMachine test case for 10000 schedules: p check -tc tcCrazyUserUsingCoffeeMachine -i 10000","title":"Checking EspressoMachine"},{"location":"tutorial/espressomachine/#exercise-problem","text":"[Problem 1] Note that the current safety specification CoffeeMakerModesOfOperation does not capture the case where the CoffeeMaker can move to GroundsOpen and GroundsClosed state. Extend the spec to cover those modes of operations as well. Thinking! ... Can you think of other cases where you would like to check that your system evolves through a certain sequence of states? Or that it allows only those executions which follow a pattern? Can these be specified as P monitors? If not, what are the challenges? A typical example of such cases is when for files in a storage system the sequence of operations that must succeed need to have a pattern of the form: open \u2192 read* \u2192 close; and similarly, for lock services, lockAcquire \u2192 readSuccess \u2192 lockReleased. More interestingly, you can also check things like: AuthenticationSuccess(x) \u2192 ReadSuccess(x), and never see a case of AuthenticationFailure(x) \u2192 ReadSuccess(x) in your executions! What do you think? Post your comments in the github discussions . What did we learn through this example? This was a fun example to demonstrate how to model a reactive system using P state machines. We saw how using P monitors allows us to check that the system moves through the correct modes of operation and that the executions only allow certain patterns.","title":"Exercise Problem"},{"location":"tutorial/failuredetector/","text":"Energized with the Coffee , let's get back to modeling distributed systems. After the two phase commit protocol, the next protocol that we will jump to is a simple broadcast-based failure detector! By this point in the tutorial, we have gotten familiar with the P language and most of its features. So, working through this example should be super fast! How to use this example We assume that you have cloned the P repository locally. git clone https://github.com/p-org/P.git The recommended way to work through this example is to open the P/Tutorial folder in IntelliJ side-by-side a browser using which you can simultaneously read the description for each example and browse the P program in IntelliJ. To know more about P language primitives used in the example, please look them up in the language manual . System: We consider a simple failure detector that basically broadcasts ping messages to all the nodes in the system and uses a timer to wait for pong responses from all nodes. If a node does not respond with a pong message after multiple attempts (either because of network failure or node failure), the failure detector marks the node as down and notifies the clients about the nodes that are potentially down. We use this example to show how to model network message loss in P and discuss how to model other types of network behaviours. Correctness Specification: We would like to check - using a liveness specification - that if the failure injector shuts down a particular node then the failure detector always eventually detects the node failure and notifies the client. P Project The 4_FailureDetector folder contains the source code for the FailureDetector project. Please feel free to read details about the recommended P program structure and P project file . Models The P models ( PSrc ) for the FailureDetector example consist of four files: FailureDetector.p : Implements the FailureDetector machine. [Expand]: Let's walk through FailureDetector.p ( L1 - L4 ) \u2192 Event ePing and ePong are used to communicate between the FailureDetector and the Node state machines (manual: event declaration ). ( L6 ) \u2192 Event eNotifyNodesDown is used by the FailureDetector to inform the clients about the nodes that are potentially down. ( L14 - L129 ) \u2192 Declares the FailureDetector state machine (manual: P state machine ). The key points to note in the FailureDetector machine are the usage of the Timer machine to model the usage of OS timer, the usage of ReliableBroadCast , and the usage of UnReliableBroadCast defined in NetworkFunctions.p . Node.p : Implements the Node machine. [Expand]: Let's walk through Node.p ( L4 - L14 ) \u2192 Declares the Node state machine. The Node machine responds with a ePong message on receiving a ePing message from the FailureDetector . On receiving a eShutDown message from the FailureInjector , the machine halts itself. Client.p : Declares the Client machine. [Expand]: Let's walk through Client.p The Client machine is a dummy machine that gets a set of alive nodes when the system starts and maintains the set of currently alive nodes by removing the nodes that are marked as down by the FailureDetector . FailureDetectorModules.p : Declares the FailureDetector module. [Expand]: Let's walk through FailureDetectorModules.p Declares the FailureDetector module which is the union of the module consisting of the FailureDetector , Node , and Client machines and the Timer module. Specifications The P Specification ( PSpec ) for the FailureDetector is implemented in ReliableFailureDetector.p . We define a simple ReliableFailureDetector liveness specification to assert that all nodes that have been shutdown by the failure injector will eventually be detected by the failure detector as failed nodes. [Expand]: Let's walk through ReliableFailureDetector.p ( L6 - L57 ) \u2192 Declares the ReliableFailureDetector liveness monitor. ReliableFailureDetector spec machine basically maintains two sets nodesDownDetected (nodes that are detected as down by the detector) and nodesShutdownAndNotDetected (nodes that are shutdown by the failure injector but not yet detected). ReliableFailureDetector monitor observes the eNotifyNodesDown and eShutDown events to update these maps and move between the hot state (unstable state) and non-hot states. The system is in a hot state if there are nodes that are shutdown but not yet detected by the failure detector. The system violates a liveness specification if any of its execution paths terminates in a hot state. To understand the semantics of the P spec machines and the details about liveness monitors, please read the manual: p monitors . Test Scenarios The test scenarios folder in P has two parts: TestDrivers and TestScripts. TestDrivers are collections of state machines that implement the test harnesses (or environment state machines) for different test scenarios. TestScripts are collections of test cases that are automatically run by the P checker. The test scenarios folder for FailureDetector ( PTst ) consists of two files TestDriver.p and TestScript.p . [Expand]: Let's walk through TestDriver.p This file consists of a single test driver machine that sets up the system under test given the number of nodes and clients in the system. The SetupSystemWithFailureInjector function creates the clients, nodes, failure injector and the failure detector machines. [Expand]: Let's walk through TestScript.p There is a single testcase ( TestFailureDetector ) defined for the FailureDetector system. The test case asserts the ReliableFailureDetector specification on a system which is a composition of the FailureDetector , FailureInjector , and the test-driver TestMultipleClients . Compiling FailureDetector Run the following command to compile the FailureDetector project: p compile Expected Output $ p compile .. Searching for a P project file *.pproj locally in the current folder .. Found P project file: P/Tutorial/4_FailureDetector/FailureDetector.pproj ---------------------------------------- ==== Loading project file: P/Tutorial/4_FailureDetector/FailureDetector.pproj ....... includes p file: P/Tutorial/4_FailureDetector/PSrc/FailureDetectorModules.p ....... includes p file: P/Tutorial/4_FailureDetector/PSrc/Client.p ....... includes p file: P/Tutorial/4_FailureDetector/PSrc/FailureDetector.p ....... includes p file: P/Tutorial/4_FailureDetector/PSrc/Node.p ....... includes p file: P/Tutorial/4_FailureDetector/PSpec/ReliableFailureDetector.p ....... includes p file: P/Tutorial/4_FailureDetector/PTst/TestDriver.p ....... includes p file: P/Tutorial/4_FailureDetector/PTst/TestScript.p ==== Loading project file: P/Tutorial/Common/Timer/Timer.pproj ....... includes p file: P/Tutorial/Common/Timer/PSrc/Timer.p ....... includes p file: P/Tutorial/Common/Timer/PSrc/TimerModules.p ==== Loading project file: P/Tutorial/Common/FailureInjector/FailureInjector.pproj ....... includes p file: P/Tutorial/Common/FailureInjector/PSrc/NetworkFunctions.p ....... includes p file: P/Tutorial/Common/FailureInjector/PSrc/FailureInjector.p ---------------------------------------- ---------------------------------------- Parsing ... Type checking ... Code generation ... Generated FailureDetector.cs. ---------------------------------------- Compiling FailureDetector... MSBuild version 17.3.1+2badb37d1 for .NET Determining projects to restore... Restored P/Tutorial/4_FailureDetector/PGenerated/CSharp/FailureDetector.csproj (in 386 ms). FailureDetector -> P/Tutorial/4_FailureDetector/PGenerated/CSharp/net6.0/FailureDetector.dll Build succeeded. 0 Warning(s) 0 Error(s) Time Elapsed 00:00:04.85 ---------------------------------------- [PTool]: Thanks for using P! Checking FailureDetector There is only a single test case in the FailureDetector project and we can directly run the test case for 10000 iterations: p check -i 10000 Discussion: Modeling Message Reordering (to be added soon) Exercise Problem What did we learn through this example? In this example, we saw how to use data nondeterminism to model message loss and unreliable sends. We also discussed how to model other types of network nondeterminism.","title":"Failure Detector"},{"location":"tutorial/failuredetector/#p-project","text":"The 4_FailureDetector folder contains the source code for the FailureDetector project. Please feel free to read details about the recommended P program structure and P project file .","title":"P Project"},{"location":"tutorial/failuredetector/#models","text":"The P models ( PSrc ) for the FailureDetector example consist of four files: FailureDetector.p : Implements the FailureDetector machine. [Expand]: Let's walk through FailureDetector.p ( L1 - L4 ) \u2192 Event ePing and ePong are used to communicate between the FailureDetector and the Node state machines (manual: event declaration ). ( L6 ) \u2192 Event eNotifyNodesDown is used by the FailureDetector to inform the clients about the nodes that are potentially down. ( L14 - L129 ) \u2192 Declares the FailureDetector state machine (manual: P state machine ). The key points to note in the FailureDetector machine are the usage of the Timer machine to model the usage of OS timer, the usage of ReliableBroadCast , and the usage of UnReliableBroadCast defined in NetworkFunctions.p . Node.p : Implements the Node machine. [Expand]: Let's walk through Node.p ( L4 - L14 ) \u2192 Declares the Node state machine. The Node machine responds with a ePong message on receiving a ePing message from the FailureDetector . On receiving a eShutDown message from the FailureInjector , the machine halts itself. Client.p : Declares the Client machine. [Expand]: Let's walk through Client.p The Client machine is a dummy machine that gets a set of alive nodes when the system starts and maintains the set of currently alive nodes by removing the nodes that are marked as down by the FailureDetector . FailureDetectorModules.p : Declares the FailureDetector module. [Expand]: Let's walk through FailureDetectorModules.p Declares the FailureDetector module which is the union of the module consisting of the FailureDetector , Node , and Client machines and the Timer module.","title":"Models"},{"location":"tutorial/failuredetector/#specifications","text":"The P Specification ( PSpec ) for the FailureDetector is implemented in ReliableFailureDetector.p . We define a simple ReliableFailureDetector liveness specification to assert that all nodes that have been shutdown by the failure injector will eventually be detected by the failure detector as failed nodes. [Expand]: Let's walk through ReliableFailureDetector.p ( L6 - L57 ) \u2192 Declares the ReliableFailureDetector liveness monitor. ReliableFailureDetector spec machine basically maintains two sets nodesDownDetected (nodes that are detected as down by the detector) and nodesShutdownAndNotDetected (nodes that are shutdown by the failure injector but not yet detected). ReliableFailureDetector monitor observes the eNotifyNodesDown and eShutDown events to update these maps and move between the hot state (unstable state) and non-hot states. The system is in a hot state if there are nodes that are shutdown but not yet detected by the failure detector. The system violates a liveness specification if any of its execution paths terminates in a hot state. To understand the semantics of the P spec machines and the details about liveness monitors, please read the manual: p monitors .","title":"Specifications"},{"location":"tutorial/failuredetector/#test-scenarios","text":"The test scenarios folder in P has two parts: TestDrivers and TestScripts. TestDrivers are collections of state machines that implement the test harnesses (or environment state machines) for different test scenarios. TestScripts are collections of test cases that are automatically run by the P checker. The test scenarios folder for FailureDetector ( PTst ) consists of two files TestDriver.p and TestScript.p . [Expand]: Let's walk through TestDriver.p This file consists of a single test driver machine that sets up the system under test given the number of nodes and clients in the system. The SetupSystemWithFailureInjector function creates the clients, nodes, failure injector and the failure detector machines. [Expand]: Let's walk through TestScript.p There is a single testcase ( TestFailureDetector ) defined for the FailureDetector system. The test case asserts the ReliableFailureDetector specification on a system which is a composition of the FailureDetector , FailureInjector , and the test-driver TestMultipleClients .","title":"Test Scenarios"},{"location":"tutorial/failuredetector/#compiling-failuredetector","text":"Run the following command to compile the FailureDetector project: p compile Expected Output $ p compile .. Searching for a P project file *.pproj locally in the current folder .. Found P project file: P/Tutorial/4_FailureDetector/FailureDetector.pproj ---------------------------------------- ==== Loading project file: P/Tutorial/4_FailureDetector/FailureDetector.pproj ....... includes p file: P/Tutorial/4_FailureDetector/PSrc/FailureDetectorModules.p ....... includes p file: P/Tutorial/4_FailureDetector/PSrc/Client.p ....... includes p file: P/Tutorial/4_FailureDetector/PSrc/FailureDetector.p ....... includes p file: P/Tutorial/4_FailureDetector/PSrc/Node.p ....... includes p file: P/Tutorial/4_FailureDetector/PSpec/ReliableFailureDetector.p ....... includes p file: P/Tutorial/4_FailureDetector/PTst/TestDriver.p ....... includes p file: P/Tutorial/4_FailureDetector/PTst/TestScript.p ==== Loading project file: P/Tutorial/Common/Timer/Timer.pproj ....... includes p file: P/Tutorial/Common/Timer/PSrc/Timer.p ....... includes p file: P/Tutorial/Common/Timer/PSrc/TimerModules.p ==== Loading project file: P/Tutorial/Common/FailureInjector/FailureInjector.pproj ....... includes p file: P/Tutorial/Common/FailureInjector/PSrc/NetworkFunctions.p ....... includes p file: P/Tutorial/Common/FailureInjector/PSrc/FailureInjector.p ---------------------------------------- ---------------------------------------- Parsing ... Type checking ... Code generation ... Generated FailureDetector.cs. ---------------------------------------- Compiling FailureDetector... MSBuild version 17.3.1+2badb37d1 for .NET Determining projects to restore... Restored P/Tutorial/4_FailureDetector/PGenerated/CSharp/FailureDetector.csproj (in 386 ms). FailureDetector -> P/Tutorial/4_FailureDetector/PGenerated/CSharp/net6.0/FailureDetector.dll Build succeeded. 0 Warning(s) 0 Error(s) Time Elapsed 00:00:04.85 ---------------------------------------- [PTool]: Thanks for using P!","title":"Compiling FailureDetector"},{"location":"tutorial/failuredetector/#checking-failuredetector","text":"There is only a single test case in the FailureDetector project and we can directly run the test case for 10000 iterations: p check -i 10000","title":"Checking FailureDetector"},{"location":"tutorial/failuredetector/#discussion-modeling-message-reordering","text":"(to be added soon)","title":"Discussion: Modeling Message Reordering"},{"location":"tutorial/failuredetector/#exercise-problem","text":"What did we learn through this example? In this example, we saw how to use data nondeterminism to model message loss and unreliable sends. We also discussed how to model other types of network nondeterminism.","title":"Exercise Problem"},{"location":"tutorial/paxos/","text":"How can we finish our tutorials on modeling distributed systems without giving tribute to the Paxos protocol (and our inspiration Leslie Lamport ). Let's end the tutorial with a simplified single decree paxos . In this example, we present a simplified model of the single decree paxos. We say simplified because general paxos is resilient against arbitrary network (lossy, duplicate, re-order, and delay), in our case we only model message loss and delay, and check correctness of paxos in the presence of such a network. This is a fun exercise, we encourage you to play around and create variants of paxos! Summary In this example, we present a simplified model of the single decree paxos. (Todo: add details about the properties checked)","title":"Paxos"},{"location":"tutorial/twophasecommit/","text":"How to use this example We assume that you have cloned the P repository locally. git clone https://github.com/p-org/P.git The recommended way to work through this example is to open the P/Tutorial folder in IntelliJ side-by-side a browser using which you can simultaneously read the description for each example and browse the P program in IntelliJ. To know more about the P language primitives used in this example, please look them up in the language manual . Now that we understand the basic features of the P language, let's look at the modeling and analysis of a distributed system ! System: We use a simplified version of the classic two phase commit protocol to model a transaction commit service. The two phase commit protocol uses a coordinator to gain consensus for any transaction spanning across multiple participants. A transaction in our case is simply a write operation for a key-value data store where the data store is replicated across multiple participants. More concretely, a write transaction must be committed by the coordinator only if it's accepted by all the participant replicas, and must be aborted if any one of the participant replicas rejects the write request. A two phase commit protocol consists of two phases (figure above). On receiving a write transaction, the coordinator starts the first phase in which it sends a prepare request to all the participants and waits for a prepare success or prepare failure response. On receiving prepare responses from all the participants, the coordinator moves to the second phase where it sends a commit or abort message to the participants and also responds back to the client. Assumptions: Our transaction commit system is ridiculously simplified. To list a few: (1) our system does allow multiple concurrent clients to issue transactions in parallel, but the coordinator serializes these transactions and services them one-by-one; (2) our system is not fault-tolerant to node failures, failure of either the coordinator or any of the participants will block the progress forever. Also, we rely on P's reliable send semantics to model the behavior of the underlying network, hence, our system models assume reliable delivery of messages. Correctness Specification: We would like our transaction commit service to provide atomicity guarantees for each transaction. That is, if the service responds to the client that a transaction was committed then that transaction must have been committed by each of its participants; and, if a transaction is aborted then at least one of the participants must have rejected it. We would also like to check that under the assumptions above (no node failures and reliable network), each transaction request is eventually responded by the transaction commit service. P Project The 2_TwoPhaseCommit folder contains the source code for the TwoPhaseCommit project. Please feel free to read details about the recommended P program structure and P project file . Models The P models ( PSrc ) for the TwoPhaseCommit example consists of three files: Coordinator.p : Implements the Coordinator state machine. [Expand]: Let's walk through Coordinator.p ( L25 - L33 ) \u2192 Declares the write and read transaction events used to communicate between the coordinator and the client machines (manual: event declaration ). ( L35 - L43 ) \u2192 Declares the prepare , commit , and abort events used to communicate between the coordinator and the participants in the system. ( L3 - L16 ) \u2192 Declares the payload types associated with these events (manual: user defined type ). ( L65 - L177 ) \u2192 Declares the Coordinator state machine. The Coordinator machine receives write and read transactions from the clients. The coordinator machine services these transactions one by one in the order in which they were received. On receiving a write transaction, the coordinator sends a prepare request to all the participants and waits for prepare responses from all the participants. Based on the responses, the coordinator either commits or aborts the transaction. If the coordinator fails to receive agreement from the participants in time, then it times out and aborts the transaction. On receiving a read transaction, the coordinator randomly selects a participant and forwards the read request to that participant. Participant.p : Implements the Participant state machine. [Expand]: Let's walk through Participant.p Unlike the Coordinator state machine that has multiple states, the Participant state machine is fairly simple. Each participant waits for requests from the Coordinator and sends the response back based on whether the request can be accepted or has to be rejected. On receiving an eShutDown event, the participant executes a raise halt to destroy itself. To know more about the special halt event, please check the manual: halt event . Each participant maintains a local key-value store which is updated based on the transactions committed by the coordinator. On receiving a prepare request from the coordinator, the participant chooses to either accept or reject the transaction based on the associated transaction id. TwoPhaseCommitModules.p : Declares the P module corresponding to the two phase commit system. Timer and Failure Injector Our two phase commit project depends on two other components: OS Timer: The coordinator machine uses a timer to wait for prepare responses from all participants. The OS timer is modeled in P using the Timer machine declared in the Timer project . The Timer model demonstrates how when reasoning about the correctness of a system, we need to also model its interaction with any nondeterministic environment or service (in this case, an OS timer). Failure Injector: P allows programmers to explicitly model different types of failures in the system. The FailureInjector project demonstrates how to model node failures in P using the halt event. The FailureInjector machine nondeterministically picks a node and sends a eShutDown event. On receiving an eShutDown event, the corresponding node must halt to destroy itself. To know more about the special halt event, please check the manual: halt event . Specifications The P Specifications ( PSpec ) for the TwoPhaseCommit example are implemented in the Atomicity.p file. We define two specifications: Atomicity (safety property): if a transaction is committed by the coordinator then it was agreed on by all participants, and if the transaction is aborted then at least one participant must have rejected the transaction. Progress (liveness property): every received transaction must be eventually responded (in the absence of node failures). Weaker Property Note that we have asserted a weaker property than what is required for Atomicity. Ideally, we would like to check that if a transaction is committed by the coordinator then it was committed-locally by all participants, and if the transaction is aborted then at least one participant must have rejected the transaction and all the participants aborted the transaction. We leave implementing this stronger property as an exercise problem, which you can revisit after finishing the other problems in the tutorials. Test Scenarios The test scenarios folder in P has two parts: TestDrivers and TestScripts. TestDrivers are collections of state machines that implement the test harnesses (or environment state machines) for different test scenarios. TestScripts are collections of test cases that are automatically run by the P checker. The test scenarios folder for TwoPhaseCommit ( PTst ) consists of three files TestDriver.p , TestScript.p and Client.p . [Expand]: Let's walk through TestDriver.p ( L9 - L42 ) \u2192 Function SetUpTwoPhaseCommitSystem takes as input t2PCConfig that specifies the number of clients, participants, etc. to be created and sets up the system by creating the machines. The function also initializes the spec monitors by informing them about the number of participants in the system before the system starts executing here . ( L3 - L22 ) \u2192 Machines SingleClientNoFailure , MultipleClientsNoFailure and MultipleClientsWithFailure are simple test driver machines that configure the system to be checked by the P checker for different scenarios. [Expand]: Let's walk through TestScript.p P allows programmers to write different test cases. Each test case is checked separately and can use a different test driver. Using different test drivers triggers different behaviors in the system under test, as it implies different system configurations and input generators. To better understand the P test cases, please look at manual: P test cases . ( L1 - L12 ) \u2192 Declares three test cases each checking a different scenario in the system. The system under test is the union of the modules representing each component in the system (manual: P module system ). The assert module constructor is used to attach monitors or specifications to be checked on the modules (manual: assert ). [Expand]: Let's walk through Client.p The Client machine implements the client of the two-phase-commit transaction service. Each client issues N non-deterministic write-transactions, if the transaction succeeds then it performs a read-transaction on the same key and asserts that the value read is same as what was written by the write transaction. ( L60 ) \u2192 Declares a foreign function in P. Foreign functions are functions that are declared in P but implemented in the external foreign language. Please read the example in P foreign interface to know more about this functionality. In this example, the ChooseRandomTransaction function could have been very easily written in P itself but it's implemented as foreign function just to demonstrate that P supports this functionality. Compiling TwoPhaseCommit Navigate to the 2_TwoPhaseCommit folder and run the following command to compile the TwoPhaseCommit project: p compile Expected Output $ p compile .. Searching for a P project file *.pproj locally in the current folder .. Found P project file: P/Tutorial/2_TwoPhaseCommit/TwoPhaseCommit.pproj ---------------------------------------- ==== Loading project file: P/Tutorial/2_TwoPhaseCommit/TwoPhaseCommit.pproj ....... includes p file: P/Tutorial/2_TwoPhaseCommit/PSrc/Coordinator.p ....... includes p file: P/Tutorial/2_TwoPhaseCommit/PSrc/Participant.p ....... includes p file: P/Tutorial/2_TwoPhaseCommit/PSrc/TwoPhaseCommitModules.p ....... includes p file: P/Tutorial/2_TwoPhaseCommit/PSpec/Atomicity.p ....... includes p file: P/Tutorial/2_TwoPhaseCommit/PTst/TestDriver.p ....... includes p file: P/Tutorial/2_TwoPhaseCommit/PTst/Client.p ....... includes p file: P/Tutorial/2_TwoPhaseCommit/PTst/TestScripts.p ....... includes foreign file: P/Tutorial/2_TwoPhaseCommit/PForeign/ForeignCode.cs ==== Loading project file: P/Tutorial/Common/Timer/Timer.pproj ....... includes p file: P/Tutorial/Common/Timer/PSrc/Timer.p ....... includes p file: P/Tutorial/Common/Timer/PSrc/TimerModules.p ==== Loading project file: P/Tutorial/Common/FailureInjector/FailureInjector.pproj ....... includes p file: P/Tutorial/Common/FailureInjector/PSrc/NetworkFunctions.p ....... includes p file: P/Tutorial/Common/FailureInjector/PSrc/FailureInjector.p ---------------------------------------- ---------------------------------------- Parsing ... Type checking ... Code generation ... Generated TwoPhaseCommit.cs. ---------------------------------------- Compiling TwoPhaseCommit... MSBuild version 17.3.1+2badb37d1 for .NET Determining projects to restore... Restored P/Tutorial/2_TwoPhaseCommit/PGenerated/CSharp/TwoPhaseCommit.csproj (in 392 ms). TwoPhaseCommit -> P/Tutorial/2_TwoPhaseCommit/PGenerated/CSharp/net6.0/TwoPhaseCommit.dll Build succeeded. 0 Warning(s) 0 Error(s) Time Elapsed 00:00:04.87 ---------------------------------------- [PTool]: Thanks for using P! Checking TwoPhaseCommit You can get the list of test cases defined in the TwoPhaseCommit project by running the P Checker: p check Expected Output $ p check .. Searching for a P compiled file locally in the current folder .. Found a P compiled file: P/Tutorial/2_TwoPhaseCommit/PGenerated/CSharp/net6.0/TwoPhaseCommit.dll .. Checking P/Tutorial/2_TwoPhaseCommit/PGenerated/CSharp/net6.0/TwoPhaseCommit.dll Error: We found '3' test cases. Please provide a more precise name of the test case you wish to check using (--testcase | -tc). Possible options are: tcSingleClientNoFailure tcMultipleClientsNoFailure tcMultipleClientsWithFailure [PTool]: Thanks for using P! There are three test cases defined in the TwoPhaseCommit project and you can specify which test case to run by using the -tc parameter along with the -i parameter for the number of schedules to explore. Check the tcSingleClientNoFailure test case for 10000 schedules: p check -tc tcSingleClientNoFailure -i 10000 Check the tcMultipleClientsNoFailure test case for 10000 schedules: Error tcMultipleClientsNoFailure triggers a very subtle concurrency bug in the assumption made by the client of the two phase commit protocol. <ErrorLog> Assertion Failed: Record read is not same as what was written by the client:: read - X, written - Y Please use the guide to explore how to debug an error trace generated by P Checker. Hint If you dive deeper in the log, you would notice that the error happens when two clients write to the same key. There is a race between the two clients issueing a write and read transaction on the same key with different values. The fix for this problem is to update the assertion on the client side to: if the value that is read when confirming the transaction is not the same as the value that was written then it must have been overridden by a transaction with id greater than its transaction id. This is true because Participants accept transaction to the same key in the monotonically increasing transaction ids . Check the tcMultipleClientsWithFailure test case for 10000 schedules: p check -tc tcMultipleClientsWithFailure -i 10000 Error tcMultipleClientsWithFailure demonstrates the known case where in the presence of node failures the two phase commit protocol does not guarantee progress. <ErrorLog> Deadlock detected. Client(7) is waiting to receive an event, but no other controlled tasks are enabled. Please use the guide to explore how to debug an error trace generated by P Checker. If you comment out the part of the Client state machine code that performs the read transaction then you would see that the Progress liveness monitor starts complaining. Exercise Problem [Problem 1] Based on the hint above, try and fix the concurrency bug in the Client state machine and run the test cases again! [Problem 2] A really interesting exploratory problem would be to try and combine the two phase commit protocol with the failure detector system to overcome the progress issue faced by the two phase commit protocol in the presence of node failures. Can you really do that? Let's have a discussion and build a variant of the protocol to tolerate failures? What did we learn through this example? We dived deeper into: (1) modeling non-determinism in distributed systems, in particular, time-outs; (2) writing complex safety properties like atomicity of transactions in P; and finally, (3) modeling node failures in P using a failure injector state machine. We will also show how P allows invoking foreign code from the P programs. More details in P foreign interface .","title":"Two Phase Commit"},{"location":"tutorial/twophasecommit/#p-project","text":"The 2_TwoPhaseCommit folder contains the source code for the TwoPhaseCommit project. Please feel free to read details about the recommended P program structure and P project file .","title":"P Project"},{"location":"tutorial/twophasecommit/#models","text":"The P models ( PSrc ) for the TwoPhaseCommit example consists of three files: Coordinator.p : Implements the Coordinator state machine. [Expand]: Let's walk through Coordinator.p ( L25 - L33 ) \u2192 Declares the write and read transaction events used to communicate between the coordinator and the client machines (manual: event declaration ). ( L35 - L43 ) \u2192 Declares the prepare , commit , and abort events used to communicate between the coordinator and the participants in the system. ( L3 - L16 ) \u2192 Declares the payload types associated with these events (manual: user defined type ). ( L65 - L177 ) \u2192 Declares the Coordinator state machine. The Coordinator machine receives write and read transactions from the clients. The coordinator machine services these transactions one by one in the order in which they were received. On receiving a write transaction, the coordinator sends a prepare request to all the participants and waits for prepare responses from all the participants. Based on the responses, the coordinator either commits or aborts the transaction. If the coordinator fails to receive agreement from the participants in time, then it times out and aborts the transaction. On receiving a read transaction, the coordinator randomly selects a participant and forwards the read request to that participant. Participant.p : Implements the Participant state machine. [Expand]: Let's walk through Participant.p Unlike the Coordinator state machine that has multiple states, the Participant state machine is fairly simple. Each participant waits for requests from the Coordinator and sends the response back based on whether the request can be accepted or has to be rejected. On receiving an eShutDown event, the participant executes a raise halt to destroy itself. To know more about the special halt event, please check the manual: halt event . Each participant maintains a local key-value store which is updated based on the transactions committed by the coordinator. On receiving a prepare request from the coordinator, the participant chooses to either accept or reject the transaction based on the associated transaction id. TwoPhaseCommitModules.p : Declares the P module corresponding to the two phase commit system.","title":"Models"},{"location":"tutorial/twophasecommit/#timer-and-failure-injector","text":"Our two phase commit project depends on two other components: OS Timer: The coordinator machine uses a timer to wait for prepare responses from all participants. The OS timer is modeled in P using the Timer machine declared in the Timer project . The Timer model demonstrates how when reasoning about the correctness of a system, we need to also model its interaction with any nondeterministic environment or service (in this case, an OS timer). Failure Injector: P allows programmers to explicitly model different types of failures in the system. The FailureInjector project demonstrates how to model node failures in P using the halt event. The FailureInjector machine nondeterministically picks a node and sends a eShutDown event. On receiving an eShutDown event, the corresponding node must halt to destroy itself. To know more about the special halt event, please check the manual: halt event .","title":"Timer and Failure Injector"},{"location":"tutorial/twophasecommit/#specifications","text":"The P Specifications ( PSpec ) for the TwoPhaseCommit example are implemented in the Atomicity.p file. We define two specifications: Atomicity (safety property): if a transaction is committed by the coordinator then it was agreed on by all participants, and if the transaction is aborted then at least one participant must have rejected the transaction. Progress (liveness property): every received transaction must be eventually responded (in the absence of node failures). Weaker Property Note that we have asserted a weaker property than what is required for Atomicity. Ideally, we would like to check that if a transaction is committed by the coordinator then it was committed-locally by all participants, and if the transaction is aborted then at least one participant must have rejected the transaction and all the participants aborted the transaction. We leave implementing this stronger property as an exercise problem, which you can revisit after finishing the other problems in the tutorials.","title":"Specifications"},{"location":"tutorial/twophasecommit/#test-scenarios","text":"The test scenarios folder in P has two parts: TestDrivers and TestScripts. TestDrivers are collections of state machines that implement the test harnesses (or environment state machines) for different test scenarios. TestScripts are collections of test cases that are automatically run by the P checker. The test scenarios folder for TwoPhaseCommit ( PTst ) consists of three files TestDriver.p , TestScript.p and Client.p . [Expand]: Let's walk through TestDriver.p ( L9 - L42 ) \u2192 Function SetUpTwoPhaseCommitSystem takes as input t2PCConfig that specifies the number of clients, participants, etc. to be created and sets up the system by creating the machines. The function also initializes the spec monitors by informing them about the number of participants in the system before the system starts executing here . ( L3 - L22 ) \u2192 Machines SingleClientNoFailure , MultipleClientsNoFailure and MultipleClientsWithFailure are simple test driver machines that configure the system to be checked by the P checker for different scenarios. [Expand]: Let's walk through TestScript.p P allows programmers to write different test cases. Each test case is checked separately and can use a different test driver. Using different test drivers triggers different behaviors in the system under test, as it implies different system configurations and input generators. To better understand the P test cases, please look at manual: P test cases . ( L1 - L12 ) \u2192 Declares three test cases each checking a different scenario in the system. The system under test is the union of the modules representing each component in the system (manual: P module system ). The assert module constructor is used to attach monitors or specifications to be checked on the modules (manual: assert ). [Expand]: Let's walk through Client.p The Client machine implements the client of the two-phase-commit transaction service. Each client issues N non-deterministic write-transactions, if the transaction succeeds then it performs a read-transaction on the same key and asserts that the value read is same as what was written by the write transaction. ( L60 ) \u2192 Declares a foreign function in P. Foreign functions are functions that are declared in P but implemented in the external foreign language. Please read the example in P foreign interface to know more about this functionality. In this example, the ChooseRandomTransaction function could have been very easily written in P itself but it's implemented as foreign function just to demonstrate that P supports this functionality.","title":"Test Scenarios"},{"location":"tutorial/twophasecommit/#compiling-twophasecommit","text":"Navigate to the 2_TwoPhaseCommit folder and run the following command to compile the TwoPhaseCommit project: p compile Expected Output $ p compile .. Searching for a P project file *.pproj locally in the current folder .. Found P project file: P/Tutorial/2_TwoPhaseCommit/TwoPhaseCommit.pproj ---------------------------------------- ==== Loading project file: P/Tutorial/2_TwoPhaseCommit/TwoPhaseCommit.pproj ....... includes p file: P/Tutorial/2_TwoPhaseCommit/PSrc/Coordinator.p ....... includes p file: P/Tutorial/2_TwoPhaseCommit/PSrc/Participant.p ....... includes p file: P/Tutorial/2_TwoPhaseCommit/PSrc/TwoPhaseCommitModules.p ....... includes p file: P/Tutorial/2_TwoPhaseCommit/PSpec/Atomicity.p ....... includes p file: P/Tutorial/2_TwoPhaseCommit/PTst/TestDriver.p ....... includes p file: P/Tutorial/2_TwoPhaseCommit/PTst/Client.p ....... includes p file: P/Tutorial/2_TwoPhaseCommit/PTst/TestScripts.p ....... includes foreign file: P/Tutorial/2_TwoPhaseCommit/PForeign/ForeignCode.cs ==== Loading project file: P/Tutorial/Common/Timer/Timer.pproj ....... includes p file: P/Tutorial/Common/Timer/PSrc/Timer.p ....... includes p file: P/Tutorial/Common/Timer/PSrc/TimerModules.p ==== Loading project file: P/Tutorial/Common/FailureInjector/FailureInjector.pproj ....... includes p file: P/Tutorial/Common/FailureInjector/PSrc/NetworkFunctions.p ....... includes p file: P/Tutorial/Common/FailureInjector/PSrc/FailureInjector.p ---------------------------------------- ---------------------------------------- Parsing ... Type checking ... Code generation ... Generated TwoPhaseCommit.cs. ---------------------------------------- Compiling TwoPhaseCommit... MSBuild version 17.3.1+2badb37d1 for .NET Determining projects to restore... Restored P/Tutorial/2_TwoPhaseCommit/PGenerated/CSharp/TwoPhaseCommit.csproj (in 392 ms). TwoPhaseCommit -> P/Tutorial/2_TwoPhaseCommit/PGenerated/CSharp/net6.0/TwoPhaseCommit.dll Build succeeded. 0 Warning(s) 0 Error(s) Time Elapsed 00:00:04.87 ---------------------------------------- [PTool]: Thanks for using P!","title":"Compiling TwoPhaseCommit"},{"location":"tutorial/twophasecommit/#checking-twophasecommit","text":"You can get the list of test cases defined in the TwoPhaseCommit project by running the P Checker: p check Expected Output $ p check .. Searching for a P compiled file locally in the current folder .. Found a P compiled file: P/Tutorial/2_TwoPhaseCommit/PGenerated/CSharp/net6.0/TwoPhaseCommit.dll .. Checking P/Tutorial/2_TwoPhaseCommit/PGenerated/CSharp/net6.0/TwoPhaseCommit.dll Error: We found '3' test cases. Please provide a more precise name of the test case you wish to check using (--testcase | -tc). Possible options are: tcSingleClientNoFailure tcMultipleClientsNoFailure tcMultipleClientsWithFailure [PTool]: Thanks for using P! There are three test cases defined in the TwoPhaseCommit project and you can specify which test case to run by using the -tc parameter along with the -i parameter for the number of schedules to explore. Check the tcSingleClientNoFailure test case for 10000 schedules: p check -tc tcSingleClientNoFailure -i 10000 Check the tcMultipleClientsNoFailure test case for 10000 schedules: Error tcMultipleClientsNoFailure triggers a very subtle concurrency bug in the assumption made by the client of the two phase commit protocol. <ErrorLog> Assertion Failed: Record read is not same as what was written by the client:: read - X, written - Y Please use the guide to explore how to debug an error trace generated by P Checker. Hint If you dive deeper in the log, you would notice that the error happens when two clients write to the same key. There is a race between the two clients issueing a write and read transaction on the same key with different values. The fix for this problem is to update the assertion on the client side to: if the value that is read when confirming the transaction is not the same as the value that was written then it must have been overridden by a transaction with id greater than its transaction id. This is true because Participants accept transaction to the same key in the monotonically increasing transaction ids . Check the tcMultipleClientsWithFailure test case for 10000 schedules: p check -tc tcMultipleClientsWithFailure -i 10000 Error tcMultipleClientsWithFailure demonstrates the known case where in the presence of node failures the two phase commit protocol does not guarantee progress. <ErrorLog> Deadlock detected. Client(7) is waiting to receive an event, but no other controlled tasks are enabled. Please use the guide to explore how to debug an error trace generated by P Checker. If you comment out the part of the Client state machine code that performs the read transaction then you would see that the Progress liveness monitor starts complaining.","title":"Checking TwoPhaseCommit"},{"location":"tutorial/twophasecommit/#exercise-problem","text":"[Problem 1] Based on the hint above, try and fix the concurrency bug in the Client state machine and run the test cases again! [Problem 2] A really interesting exploratory problem would be to try and combine the two phase commit protocol with the failure detector system to overcome the progress issue faced by the two phase commit protocol in the presence of node failures. Can you really do that? Let's have a discussion and build a variant of the protocol to tolerate failures? What did we learn through this example? We dived deeper into: (1) modeling non-determinism in distributed systems, in particular, time-outs; (2) writing complex safety properties like atomicity of transactions in P; and finally, (3) modeling node failures in P using a failure injector state machine. We will also show how P allows invoking foreign code from the P programs. More details in P foreign interface .","title":"Exercise Problem"}]}